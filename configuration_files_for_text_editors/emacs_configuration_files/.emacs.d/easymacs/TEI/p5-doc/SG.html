<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en"><!--THIS FILE IS GENERATED FROM AN XML MASTER. DO NOT EDIT (4)-->
<head><title> TEI P5: Guidelines for Electronic Text Encoding and Interchange:  A Gentle Introduction to XML</title><link href="/favicon.ico" rel="icon" type="image/x-icon"/><link href="/favicon.ico" rel="shortcut icon" type="image/x-icon"/><meta name="author" content="edited by C.M. Sperberg-McQueen and&#10;&#9;Lou Burnard"/><meta name="generator" content="Text Encoding Initiative Consortium XSLT stylesheets"/><meta name="DC.Title" content="TEI P5: Guidelines for Electronic Text Encoding and Interchange:  A Gentle Introduction to XML"/><meta name="DC.Type" content="Text"/><meta name="DC.Format" content="application/xhtml+xml"/><meta http-equiv="Content-Type" content="application/xhtml+xml; charset=utf-8"/><link href="guidelines.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript">
	    function startUp() {
	  } 

	function openpopup(location){ 
	var newwin =
        window.open(location,"OUCSPopup","status=no,menu=no,toolbar=no,width=350,height=400,resizable=yes,scrollbars=yes")
          }
	</script></head><body onload="startUp()"><div id="hdr"><h2 class="subtitle">A Gentle Introduction to XML</h2><h1 class="title">TEI P5: Guidelines for Electronic Text Encoding and Interchange</h1></div><div id="accessibility"><span class="tocontent"><a href="?style=text">Text only</a>
      | <a class="skiplinks" href="#rh-column" title="Go to main page content">Skip links</a></span></div><div id="hdr2"><!--no nav --></div><div id="hdr3"><a href="#rh-column" title="Go to main page content" class="skiplinks">Skip links</a><a class="hide">|</a><div class="breadcrumb"><ul class="breadcrumb"><li class="breadcrumb-first"><a class="breadcrumb" href="index.html">TEI P5 Guidelines</a></li><li class="breadcrumb"><a class="breadcrumb" href="/"></a></li></ul></div><a class="hide">|</a><a class="bannerright" href="http://www.tei-c.org/Consortium/" title="Go to home page">TEI Consortium</a></div><div class="column-wrapper"><div id="lh-col"><div id="lh-col-top"><!--top of left-hand column--></div><div id="lh-col-bottom"><!--bottom of left-hand column--><div class="tocFront"><div class="tocContainer"><div class="toclist0"><a class="toclist" href="FM1.html"> Introductory Note</a>
</div><div class="toclist0"><a class="toclist" href="AB.html"> About These Guidelines</a>
</div><div class="toclist0"><span class="toclist-this"> A Gentle Introduction to XML</span>
<div class="toclist1"><a class="toclist" href="SG.html#SG11"> What's special about XML?</a>
</div><div class="toclist1"><a class="toclist" href="SG.html#SG12"> Textual structure</a>
</div><div class="toclist1"><a class="toclist" href="SG.html#SG13"> XML structures</a>
</div><div class="toclist1"><a class="toclist" href="SG.html#SG14"> Validating a document's structure</a>
</div><div class="toclist1"><a class="toclist" href="SG.html#SG152"> Complicating the issue</a>
</div><div class="toclist1"><a class="toclist" href="SG.html#SG16"> Attributes</a>
</div><div class="toclist1"><a class="toclist" href="SG.html#SG17"> Entities</a>
</div><div class="toclist1"><a class="toclist" href="SG.html#SG17BIS"> Marked sections</a>
</div><div class="toclist1"><a class="toclist" href="SG.html#front.1_div.4_div.9"> Other components of an XML document</a>
</div><div class="toclist1"><a class="toclist" href="SG.html#SG18"> Putting it all together</a>
</div></div></div></div><div class="tocBody"><!--start TOC--><div class="tocContainer"><!--TOC components--><div class="toclist0"><a class="toclist" href="CH.html">1  Languages and Character Sets</a>
</div><div class="toclist0"><a class="toclist" href="ST.html">2  The TEI infrastructure</a>
</div><div class="toclist0"><a class="toclist" href="HD.html">3  The TEI Header</a>
</div><div class="toclist0"><a class="toclist" href="CO.html">4  Elements Available in All TEI Documents</a>
</div><div class="toclist0"><a class="toclist" href="DS.html">5  Default Text Structure</a>
</div><div class="toclist0"><a class="toclist" href="VE.html">6  Verse</a>
</div><div class="toclist0"><a class="toclist" href="DR.html">7  Performance Texts</a>
</div><div class="toclist0"><a class="toclist" href="TS.html">8  Transcriptions of Speech</a>
</div><div class="toclist0"><a class="toclist" href="DI.html">9  Print Dictionaries</a>
</div><div class="toclist0"><a class="toclist" href="MS.html">10  Manuscript Description</a>
</div><div class="toclist0"><a class="toclist" href="SA.html">11  Linking, Segmentation, and Alignment</a>
</div><div class="toclist0"><a class="toclist" href="AI.html">12  Simple Analytic Mechanisms</a>
</div><div class="toclist0"><a class="toclist" href="FS.html">13  Feature Structures</a>
</div><div class="toclist0"><a class="toclist" href="CE.html">14  Certainty and Responsibility</a>
</div><div class="toclist0"><a class="toclist" href="PH.html">15  Transcription of Primary Sources</a>
</div><div class="toclist0"><a class="toclist" href="TC.html">16  Critical Apparatus</a>
</div><div class="toclist0"><a class="toclist" href="ND.html">17  Names and Dates</a>
</div><div class="toclist0"><a class="toclist" href="GD.html">18  Graphs, Networks, and Trees</a>
</div><div class="toclist0"><a class="toclist" href="FT.html">19  Tables, Formulae, and Graphics</a>
</div><div class="toclist0"><a class="toclist" href="CC.html">20  Language Corpora</a>
</div><div class="toclist0"><a class="toclist" href="WD.html">21  Representation of non-standard characters and glyphs</a>
</div><div class="toclist0"><a class="toclist" href="FD.html">22  Feature System Declaration</a>
</div><div class="toclist0"><a class="toclist" href="TD.html">23  Documentation Elements</a>
</div><div class="toclist0"><a class="toclist" href="USE.html">24  Using The TEI</a>
</div></div></div><div class="tocBack"><div class="tocContainer"><div class="toclist0"><a class="toclist" href="REFCLA.html">Appendix A  Classes</a>
</div><div class="toclist0"><a class="toclist" href="REFTAG.html">Appendix B  Elements</a>
</div><div class="toclist0"><a class="toclist" href="REFENT.html">Appendix C  Macros</a>
</div><div class="toclist0"><a class="toclist" href="BIB.html">Appendix D  Bibliography</a>
</div><div class="toclist0"><a class="toclist" href="PARTIND.html">Appendix E  Index</a>
</div><div class="toclist0"><a class="toclist" href="PREFS.html">Appendix F  Prefatory Notes</a>
</div><div class="toclist0"><a class="toclist" href="COL.html">Appendix G  Colophon</a>
</div></div></div></div></div><div id="rh-col"><a id="rh-column"/><div id="rh-col-top"><!--top of right-hand column--></div><div id="rh-col-bottom"><!--bottom of right-hand column--><h2> A Gentle Introduction to XML</h2><p><span id="id2351485"/>The encoding scheme defined by these Guidelines is formulated
as an application of the Extensible Markup
Language (XML).<a class="notelink" href="#Note4"><sup>4</sup></a>
XML is widely-used for the definition of device-independent,
system-independent methods of storing and processing texts in
electronic form; XML being in fact a simplification or derivation of
SGML, in which the TEI Guidelines were originally
formulated.  In the present chapter we introduce informally the basic
concepts underlying such markup languages and attempt to explain to
the reader encountering them for the first time how they are actually
used in the TEI scheme. For a more technical
account of TEI practice see chapter <a class="link_ptr" href="USE.html#CF" title="28">24.1  Conformance</a>
in the Guidelines.</p><p><span id="id2351519"/>XML is an extensible markup language used for the description of
marked-up electronic text.  More exactly, XML is a
<em>metalanguage</em>, that is, a means of formally describing a
language, in this case, a <em>markup</em> language.  Historically,
the word <em>markup</em> has been used to describe annotation or
other marks within a text intended to instruct a compositor or typist
how a particular passage should be printed or laid out.  Examples
include wavy underlining to indicate boldface, special symbols for
passages to be omitted or printed in a particular font and so forth.
As the formatting and printing of texts was automated, the term was
extended to cover all sorts of special codes inserted into electronic
texts to govern formatting, printing, or other processing.</p><p><span id="id2351546"/>Generalizing from that sense, we define markup, or (synonymously)
<em>encoding</em>, as any means of making explicit an
interpretation of a text.  Of course, all printed texts are
implicitly encoded (or marked up) in this sense: punctuation marks, use of capitalization,
disposition of letters around the page, even the spaces between words,
might be regarded as a kind of markup, the function of which is to
help the human reader determine where one word ends and another
begins, or how to identify gross structural features such as headings
or simple syntactic units such as dependent clauses or sentences.
Encoding a text for computer processing is in principle, like
transcribing a manuscript from scriptio
continua,<a class="notelink" href="#Note5"><sup>5</sup></a> a process of making explicit what is conjectural
or implicit, a process of directing the user as to how the content of
the text should be (or has been) interpreted.</p><p><span id="id2351585"/>By <em>markup
language</em> we mean a set of markup conventions used together for
encoding texts.  A markup language must specify what markup is
allowed, what markup is required, how markup is to be distinguished
from text, and what the markup means.  XML provides the means for
doing the first three; documentation such as these Guidelines is
required for the last.</p><p><span id="id2351598"/>The present chapter attempts to give an informal introduction to
those parts of XML of which a proper understanding is necessary to
make best use of these Guidelines. The interested reader should also
consult one or more of the dozens of excellent introductory text books
or web sites now available on the subject. </p><div class="div2" id="SG11"><h3> What's special about XML?</h3><div class="p"><span id="id2351618"/>Three characteristics of XML seem to us to make it unlike other
other markup languages: 
<ul><li>its emphasis on descriptive rather than
procedural markup;</li><li> its <em>document type</em> concept; </li><li>its independence of any one hardware or software
system.</li></ul> These three aspects are discussed briefly below,
and then in more depth in sections <a class="link_ptr" href="SG.html#SG13" title="XML structures"> XML structures</a> and <a class="link_ptr" href="SG.html#SG17" title="Entities"> Entities</a>.</div><div class="p"><span id="id2351651"/>The markup language with which XML is most frequently compared,
   however, is HTML, the language in which web pages had always been
   written until XML began to replace it. Compared with HTML, XML has
   some other important characteristics:
<ul><li>XML is extensible: it does not contain a fixed set of
   tags;</li><li>XML documents must be well-formed according to a defined
syntax;</li><li>an XML document can be formally  validated against a schema of
some kind;</li><li>XML focuses on the meaning of data, not its presentation.</li></ul></div><div class="div3" id="SG111"><h4> Descriptive markup</h4><p><span id="id2351689"/>In a descriptive markup system, the markup codes used do little
more than categorize parts of a document.  Markup codes such as
<span class="tag">&lt;para&gt;</span> or <tt>\end{list}</tt> simply identify a portion
of a document and assert of it that ‘the following item is a
paragraph,’ or ‘this is the end of the most recently begun
list,’ etc.  By contrast, a procedural markup system defines what
processing is to be carried out at particular points in a document:
‘call procedure PARA with parameters 1, b and x here’ or ‘move
the left margin 2 quads left, move the right margin 2 quads right,
skip down one line, and go to the new left margin,’ etc.  In XML,
the instructions needed to process a document for some particular
purpose (for example, to format it) are sharply distinguished from the
markup used to describe it. Usually, the markup or other information
needed to process a document will be maintained
separately from the document itself, typically  in a distinct document called a
<em>stylesheet</em>, though it may do much more than simply define
the rendition or visual appearance of a document.<a class="notelink" href="#Note6"><sup>6</sup></a></p><p><span id="id2351752"/>When descriptive markup is used, the same document can
readily be processed in many different ways, using only those parts of
it which are considered relevant.  For example, a content analysis
program might disregard entirely the footnotes embedded in an
annotated text, while a formatting program might extract and collect
them all together for printing at the end of each chapter. Different
kinds of processing can be carried out with the same part of a file.
For example, one program might extract names of persons and places
from a document to create an index or database, while another,
operating on the same text, but using a different stylesheet, might
print names of persons and places in a distinctive typeface.</p></div><div class="div3" id="SG112"><h4> Types of document</h4><p><span id="id2351781"/>A second key aspect of XML is its notion of a <em>document
type</em>:  documents are regarded as having types, just as other objects
processed by computers do.  The type of a document is formally defined
by its constituent parts and their structure.  The definition of a
‘report’, for example, might be that it consisted
of a ‘title’ and possibly an
‘author’, followed by an
‘abstract’ and a sequence of one or more
‘paragraphs’.  Anything lacking a title, according
to this formal definition, would not formally be a report, and neither
would a sequence of paragraphs followed by an abstract, whatever other
report-like characteristics these might have for the human reader.</p><p><span id="id2351815"/>If documents are of known types, a special purpose program (called
a <em>parser</em>), once provided with an unambiguous definition
of a document's type, can check that any  document claiming to be of a
that type does in fact conform to the specification. A parser
can check that all and only elements specified for a particular
document type are present, that they are combined in appropriate ways,
correctly ordered and so forth.  More significantly, different
documents of the same type can be processed in a uniform way. Programs
can be written which take advantage of the knowledge encapsulated in
the document structure information, and which can thus behave in a
more ‘intelligent’ fashion.</p></div><div class="div3" id="SG113"><h4> Data independence</h4><p><span id="id2351848"/>A basic design goal of XML is to ensure that documents encoded
according to its provisions can move from one hardware and software
environment to another without loss of information. The two features
discussed so far both address this requirement at an abstract level;
the third feature addresses it at the level of the strings of data
characters of which documents are composed.  All XML documents,
whatever language or writing system they employ, use the same
underlying character encoding (that is, the same method of
representing the graphic forms making up a particular writing system
as binary data).<a class="notelink" href="#Note7"><sup>7</sup></a> This
encoding is defined by an international standard,<a class="notelink" href="#Note8"><sup>8</sup></a>
which is implemented by a universal character set maintained by an
industry group called the Unicode Consortium, and known as
Unicode;<a class="notelink" href="#Note9"><sup>9</sup></a> this
provides a standardised way of representing any of the thousands of
discrete symbols making up the world's writing systems, past and
present.</p><p><span id="id2351899"/>For technical and historical reasons which need not concern us, it
is often necessary to translate texts encoded as Unicode into some
smaller or less general encoding scheme. XML uses a general purpose
<em>string substitution</em> mechanism for this purpose, inherited
from SGML (which predates the availability of Unicode). In simple
terms, this mechanism allows for the indirect representation of
arbitrary parts of a document (be they single characters, character
strings, or whole files) within it. One obvious application for this
mechanism is to ensure consistency of nomenclature; another, more
significant one, is to counter the notorious inability of different
computer systems to understand each other's character sets, or of any
one system to provide all the graphic characters needed for a
particular application. The strings defined by this
string-substitution mechanism are called <em>entities</em> and
they are discussed in section <a class="link_ptr" href="SG.html#SG17" title="Entities"> Entities</a>.</p></div></div><div class="div2" id="SG12"><h3> Textual structure</h3><p><span id="id2351940"/>A text is not an undifferentiated sequence of words, much less of
bytes. For different purposes, it may be divided into many different
units, of different types or sizes.  A prose text such as this one
might be divided into sections, chapters, paragraphs, and sentences.  A
verse text might be divided into cantos, stanzas, and lines.  Once
printed, sequences of prose and verse might be divided into volumes,
gatherings, and pages.</p><p><span id="id2351952"/>Structural units of this kind are most often used to identify
specific locations or reference points within a text (‘the third
sentence of the second paragraph in chapter ten’; ‘canto 10, line
1234’; ‘page 412,’ etc.) but they may also be used to
subdivide a text into meaningful fragments for analytic purposes
(‘is the average sentence length of section 2 different from that of
section 5?’‘how many paragraphs separate each occurrence of the
word nature?’‘how many pages?’).
Other structural units are more clearly analytic, in that they
characterize a section of a text.  A dramatic text might regard each
speech by a different character as a unit of one kind, and stage
directions or pieces of action as units of another kind.  Such an
analysis is less useful for locating parts of the text (‘the 93rd
speech by Horatio in Act 2’) than for facilitating comparisons
between the words used by one character and those of another, or those
used by the same character at different points of the play.</p><p><span id="id2351999"/>In a prose text one might similarly wish to regard as units of
different types passages in direct or indirect speech, passages
employing different stylistic registers (narrative, polemic,
commentary, argument, etc.), passages of different authorship and so
forth.  And for certain types of analysis (most notably textual
criticism) the physical appearance of one particular printed or
manuscript source may be of importance:  paradoxically, one may wish to
use descriptive markup to describe presentational features such as
typeface, line breaks, use of whitespace and so forth.</p><p><span id="id2352013"/>These textual structures overlap with each other in complex and
unpredictable ways.  Particularly when dealing with texts as
instantiated by paper technology, the reader needs to be aware of both
the physical organization of the book and the logical structure of the
work it contains.  Many great works (Sterne's <i>Tristram
Shandy</i> for example) cannot be fully appreciated without an
awareness of the interplay between narrative units (such as chapters or
paragraphs) and page divisions.  For many types of research, it is the
interplay between different levels of analysis which is crucial:  the
extent to which syntactic structure and narrative structure mesh, or
fail to mesh, for example, or the extent to which phonological
structures reflect morphology.</p></div><div class="div2" id="SG13"><h3> XML structures</h3><p><span id="id2352044"/>This section describes the simple and consistent mechanism for the
markup or identification of textual structure
provided by XML.  It also describes the methods XML provides for
the expression of rules defining how units of textual structure can
   meaningfully be combined in a text.</p><div class="div3" id="SG131"><h4> Elements</h4><p><span id="id2352064"/>The technical term used in
XML for a textual unit, viewed as a structural component,
is <em>element</em>.  Different types of elements are given
different names, but XML provides no way of expressing the meaning of
a particular type of element, other than its relationship to other
element types.  That is, all one can say about an element called (for
instance) <code>&lt;blort&gt;</code> is that instances of it may (or may not)
occur within elements of type <code>&lt;farble&gt;</code>, and that it may (or may
not) be decomposed into elements of type <code>&lt;blortette&gt;</code>.  It
should be stressed that XML is entirely unconcerned with
the semantics of textual elements: these are application dependent. It
is up to the creators of XML vocabularies (such as these Guidelines)
to choose intelligible names for the elements they identify and to
define their proper use in text markup.  That is the chief purpose
of documents such as the TEI Guidelines.  From the need to choose element names indicative of
function comes the technical term for the name of an element type,
which is <em>generic identifier</em>, or GI.</p><div class="p"><span id="id2352103"/>Within a marked up text (a <em>document instance</em>), each
element must be explicitly marked or tagged in some way.  This is done
by inserting a tag at the beginning of the element (a
<em>start-tag</em>) and another at its end (an
<em>end-tag</em>). The start- and end-tag pair are used to bracket
off the element occurrences within the running text, in rather the
same way as different types of parentheses or quotation marks are used
in conventional punctuation. For example, a quotation element in a
text might be tagged as follows:
<div class="pre">... Rosalind's remarks  <span class="element">&lt;quote&gt;</span>This is the silliest stuff
that ere I heard of!<span class="element">&lt;/quote&gt;</span> clearly indicate ...</div>
As this example shows, a start-tag takes the form <span class="tag">&lt;quote&gt;</span>,
where the opening angle bracket indicates the start of the start-tag,
‘quote’ is the generic identifier of the element which is being
delimited, and the closing angle bracket indicates the end of a tag.
An end-tag takes an identical form, except that the opening angle
bracket is followed by a solidus (slash) character, so that the
corresponding end-tag is <span class="tag">&lt;/quote&gt;</span>.<a class="notelink" href="#Note10"><sup>10</sup></a></div></div><div class="div3" id="SG132"><h4> Content models:  an example</h4><p><span id="id2352177"/>An element may be <em>empty</em>, that is, it may have no
content at all, or it may contain just a sequence of characters with
no other elements.  More usually, however,
elements of one type will be <em>embedded</em> (contained entirely)
within elements of a different type.
</p><div class="p"><span id="id2352192"/>To illustrate this, we will consider a very simple structural
model. Let us assume that we wish to identify within an anthology
only poems, their titles, and the stanzas and lines of which they are
composed. In XML terms, our <em>document type</em> is the
<em>anthology</em>, and it consists of a series of
<em>poem</em>s. Each poem has embedded within it one element, a
<em>title</em>, and several occurrences of another, a
<em>stanza</em>, each stanza having embedded within it a number of
<em>line</em> elements. Fully marked up, a text conforming to
this model might appear as follows:<a class="notelink" href="#Note11"><sup>11</sup></a><div class="pre">&lt;anthology&gt;
  &lt;poem&gt;&lt;title&gt;The SICK ROSE&lt;/title&gt;
    &lt;stanza&gt;
      &lt;line&gt;O Rose thou art sick.&lt;/line&gt;
      &lt;line&gt;The invisible worm,&lt;/line&gt;
      &lt;line&gt;That flies in the night&lt;/line&gt;
      &lt;line&gt;In the howling storm:&lt;/line&gt;
    &lt;/stanza&gt;
    &lt;stanza&gt;
      &lt;line&gt;Has found out thy bed&lt;/line&gt;
      &lt;line&gt;Of crimson joy:&lt;/line&gt;
      &lt;line&gt;And his dark secret love&lt;/line&gt;
      &lt;line&gt;Does thy life destroy.&lt;/line&gt;
    &lt;/stanza&gt;
  &lt;/poem&gt;
  &lt;!-- more poems go here --&gt;
&lt;/anthology&gt;</div></div><div class="p"><span id="id2352240"/>It should be stressed that this example does <em>not</em> use
the same names as are proposed for corresponding elements elsewhere
in these Guidelines: the above is <em>not</em> a valid TEI document.
It will however serve as an introduction to the basic notions of XML.
Whitespace and line breaks have been added to the example for the
sake of visual clarity only; they have no particular significance in the
XML encoding itself.  Also, the line
<div class="pre"><br/>&lt;!-- more poems go here    --&gt;</div>
is an XML <em>comment</em> and is not treated as part of the text.</div><div class="p"><span id="id2352280"/>As it stands, the above example is what is known as a
<em>well-formed</em> XML document: to achieve this status, an XML
document must obey the following simple rules:
<ul><li>there should be a single element (start- and end- tag pair)
which encloses the whole document: this is known as the <em>root
element</em> (<code>&lt;anthology&gt;</code> in our case);</li><li>each element should be completely contained by the root element,
or by an element which is so contained; elements may not partially
overlap one another;</li><li>the tags marking the start and end of each element must always
be present. <a class="notelink" href="#Note12"><sup>12</sup></a></li></ul></div><p><span id="id2352323"/>An XML document which is well-formed can be processed in a number
of useful ways.  A simple indexing program could extract only the
relevant text elements in order to make a list of titles, first lines,
or words used in the poem text; a simple formatting program could
insert blank lines between stanzas, perhaps indenting the first line
of each, or inserting a stanza number.  Different parts of each poem
could be typeset in different ways.  A more ambitious analytic program
could relate the use of punctuation marks to stanzaic and metrical
divisions.<a class="notelink" href="#Note13"><sup>13</sup></a> Scholars wishing to see
the implications of changing the stanza or line divisions chosen by
the editor of this poem can do so simply by altering the position of
the tags.  And of course, the text as presented above can be
transported from one computer to another and processed by any program
(or person) capable of making sense of the tags embedded within it
with no need for the sort of transformations and translations needed
to move word processor files around.</p><p><span id="id2352357"/>However, well-formedness alone is not enough for the full range of
what might be useful in marking up a document. It might well be useful
if, in the process of preparing our digital anthology, a computer
system could check some basic rules about how stanzas, lines, and
titles can sensibly co-occur in a document. It would be even more
useful if the system could check that stanzas are always labelled
<span class="tag">&lt;stanza&gt;</span> and not occasionally <span class="tag">&lt;canto&gt;</span> or
<span class="tag">&lt;Stanza&gt;</span>.  An XML document in which such rules have been
checked is technically known as a <em>valid</em> document, and the
ability to perform such validation is one of the key advantages of
using XML. To carry this out, some way of formally stating the
criteria for successful validation is necessary: in XML this formal
statement may be provided by an additional document known as a
<em>document type declaration</em> (DTD) or by an <em>XML
schema</em>. One important schema language is that provided by
another W3C Recommendation: the XML Schema language (<a class="link_ptr" href="http://www.w3.org/XML/Schema" title=""><span>http://www.w3.org/XML/Schema</span></a>); another is provided by the OASIS Committee's
specification for Relax NG (<a class="link_ptr" href="http://www.oasis-open.org/committees/relax-ng/" title=""><span>http://www.oasis-open.org/committees/relax-ng/</span></a>).  The
TEI Guidelines use Relax NG internally for defining TEI elements,
although schemas in other languages, or DTDs, may be generated.
This chapter gives examples using DTD and Relax NG notation.</p></div></div><div class="div2" id="SG14"><h3> Validating a document's structure</h3><p><span id="id2352425"/>In creating a DTD or Schema, the document
designer may be as lax or as restrictive as the occasion warrants.  A
balance must be struck between the convenience of following simple
rules and the complexity of handling real texts. This is particularly
the case when the rules being defined relate to texts which already
exist: the designer may have only the haziest of notions as to an
ancient text's original purpose or meaning and hence find it very
difficult to specify consistent rules about its structure.  On the
other hand, where a new text is being prepared to an exact
specification, for example for entry into a textual database of some
kind, the more precisely stated the rules, the better they can be
enforced.  Even in the case where an existing text is being marked up,
it may be beneficial to define a restrictive set of rules relating to
one particular view or hypothesis about the text – if only as a
means of testing the usefulness of that view or hypothesis.  It is
important to remember that every document type declaration results
from an interpretation of a text.  There is no single schema which
encompasses any kind of absolute truth about a text, although it may
be convenient to privilege some schemas above others for particular types
of analysis.</p><p><span id="id2352460"/>XML is widely used in environments where uniformity
of document structure is a major desideratum.  In the production of
technical documentation, for example, it is of major importance that
sections and subsections should be properly nested, that cross
references should be properly resolved and so forth.  In such
situations, documents are seen as raw material to match against
pre-defined sets of rules.  As discussed above, however, the use of
simple rules can also greatly simplify the task of tagging accurately
elements of less rigidly constrained texts.  By making these rules
explicit, the scholar reduces his or her own burdens in marking up and
verifying the electronic text, while also being forced to make explicit
an interpretation of the structure and significant particularities of
the text being encoded.</p><div class="div3" id="SG141bis"><h4> An example Relax NG schema</h4><div class="p"><span id="id2352489"/>A Relax NG schema is expressed as a set of declarative statements,
using an XML notation <a class="notelink" href="#Note14"><sup>14</sup></a>
For a simple model of a poem, the following schema would be
appropriate:
<div class="pre">&lt;grammar xmlns="http://relaxng.org/ns/structure/1.0"&gt;
  &lt;define name="anthology"&gt;
    &lt;element name="anthology"&gt;
      &lt;oneOrMore&gt;
        &lt;ref name="poem"/&gt;
      &lt;/oneOrMore&gt;
    &lt;/element&gt;
  &lt;/define&gt;
  &lt;define name="poem"&gt;
    &lt;element name="poem"&gt;
      &lt;optional&gt;
        &lt;ref name="title"/&gt;
      &lt;/optional&gt;
      &lt;oneOrMore&gt;
        &lt;ref name="stanza"/&gt;
      &lt;/oneOrMore&gt;
    &lt;/element&gt;
  &lt;/define&gt;
  &lt;define name="title"&gt;
    &lt;element name="title"&gt;
      &lt;text/&gt;
    &lt;/element&gt;
  &lt;/define&gt;
  &lt;define name="stanza"&gt;
    &lt;element name="stanza"&gt;
      &lt;oneOrMore&gt;
        &lt;ref name="line"/&gt;
      &lt;/oneOrMore&gt;
    &lt;/element&gt;
  &lt;/define&gt;
  &lt;define name="line"&gt;
    &lt;element name="line"&gt;
      &lt;text/&gt;
    &lt;/element&gt;
  &lt;/define&gt;
  &lt;start&gt;
    &lt;choice&gt;
      &lt;ref name="anthology"/&gt;
    &lt;/choice&gt;
  &lt;/start&gt;
&lt;/grammar&gt;</div>
The Relax NG language defines a set of <em>patterns</em>
for each element, which link to one another. </div></div><div class="div3" id="SG141"><h4> An example DTD</h4><div class="p"><span id="id2352524"/>A DTD is expressed as a set of declarative statements.
Unlike the schema languages, it uses a
special purpose syntax which we introduce informally below.
For our simple model of a poem, the following declarations
would be appropriate:
<div class="pre">&lt;!ELEMENT anthology     (poem+)&gt;
&lt;!ELEMENT poem          (title?, stanza+)&gt;
&lt;!ELEMENT title         (#PCDATA) &gt;
&lt;!ELEMENT stanza        (line+)   &gt;
&lt;!ELEMENT line          (#PCDATA) &gt;</div>
These five lines are examples of formal XML element declarations.  A
declaration, like an element, is delimited by angle brackets; the
first character following the opening bracket must be an exclamation
mark, followed immediately by one of a small set of XML-defined
keywords, specifying the kind of object being declared.  The five
declarations above are all of the same type: each begins with an
<tt>ELEMENT</tt> keyword, indicating that it declares an element,
in the technical sense defined above.  Each consists of two parts: a
name, or <em>generic identifier</em> and a <em>content
model</em>.  Each of these parts is discussed further below.
Components of the declaration are separated by <em>whitespace</em>
characters, that is one or more blanks, tabs or newlines.</div><div class="div4" id="SG141x"><h5> Generic identifier</h5><p><span id="id2352592"/>The first part of each declaration above gives the generic
identifier (often abbreviated to GI) of the element which is being
declared, for example poem,
title, etc.  A GI may contain alphabetic
characters, digits, hyphens, underscore characters, or fullstops, and
must begin with a letter. In general, uppercase and lowercase letters
are regarded as distinct characters: an element with the GI
<code>&lt;foo&gt;</code> is <em>not</em> the same as an element with the GI
<code>&lt;Foo&gt;</code>: the root element of a TEI-conformant document is thus
<code>&lt;TEI&gt;</code>, <em>not </em><code>&lt;tei&gt;</code>.<a class="notelink" href="#Note15"><sup>15</sup></a></p></div><div class="div4" id="SG143"><h5> Content model</h5><p><span id="id2352666"/>The second part of each declaration, enclosed in parentheses, is
called the <em>content model</em> of the element being defined, because it
specifies what may legitimately be contained within it.  Contents
are specified either in terms of other elements or using special
reserved words.  There are several such reserved words, of which by
far the most commonly encountered is <tt>#PCDATA</tt>, as in this example.
This is an abbreviation for  and
it means that the element being defined may contain any valid
character data (but no elements).  If an XML declaration is thought of as a structure
like a family tree, with a single ancestor at the top (in our case,
this would be <span class="tag">&lt;anthology&gt;</span>), then almost always, following the
branches of the tree downwards (for example, from <code>&lt;anthology&gt;</code>
to <code>&lt;poem&gt;</code> to <code>&lt;stanza&gt;</code> to <code>&lt;line&gt;</code> and
<code>&lt;title&gt;</code>) will lead eventually to <tt>#PCDATA</tt>. In our example,
<code>&lt;title&gt;</code> and <code>&lt;line&gt;</code> are so defined, since their content
models say <tt>#PCDATA</tt> only and name no embedded elements.</p></div><div class="div4" id="SG144"><h5> Occurrence indicators</h5><p><span id="id2352744"/>The declaration for <code>&lt;stanza&gt;</code> in the example above states
that a stanza consists of one or more lines.  It uses an
<em>occurrence indicator</em> (the plus sign) to indicate how many
times the element named in its content model may occur.  There are
three occurrence indicators: the plus sign, the question mark, and the
asterisk or star.  The plus sign means that there may be one or more
occurrences of the element concerned; the question mark means that
there may be at most one and possibly no occurrence; the star means
that the element concerned may either be absent or appear one or more
times.  Thus, if the content model for <code>&lt;stanza&gt;</code> were
<tt>(line*)</tt>, stanzas with no lines would be possible as well
as those with more than one line.  If it were <tt>(line?)</tt>,
again empty stanzas would be countenanced, but no stanza could have
more than a single line.  The declaration for <code>&lt;poem&gt;</code> in the
example above thus states that a <code>&lt;poem&gt;</code> cannot have more than
one title, but may have none, and that it must have at least one
<code>&lt;stanza&gt;</code> and may have several.
</p></div><div class="div4" id="SG145"><h5> Connectors</h5><p><span id="id2352804"/>The content model <tt>(title?, stanza+)</tt> contains more than
one component, and thus needs additionally to specify the order in
which these elements (<code>&lt;title&gt;</code> and <code>&lt;stanza&gt;</code>) may appear.
This ordering is determined by the <em>connector</em> (the comma)
used between its components.  There are two possible connectors: the
comma, representing sequence, and the vertical bar, representing
alternation.  If the comma in this example were replaced by a vertical
bar, then a <code>&lt;poem&gt;</code> would consist of either a title or just
stanzas – but not both!</p></div><div class="div4" id="SG146"><h5> Model groups</h5><div class="p"><span id="id2352846"/>In our example so far, the components of each content model have
been either single elements or <tt>#PCDATA</tt>.  It is quite
permissible however to define content models in which the components
are lists of elements, combined by connectors.  Such lists, known as
<em>model groups</em>, may also be modified by occurrence
indicators and themselves combined by connectors.  To demonstrate
these facilities, let us now expand our example to include
non-stanzaic types of verse.  For the sake of demonstration, we will
categorize poems as one of <em>stanzaic</em>,
<em>couplets</em>, or <em>blank</em> (or
<em>stichic</em>).  A blank-verse poem consists simply of lines
(we ignore the possibility of verse paragraphs for the moment)<a class="notelink" href="#Note16"><sup>16</sup></a> so no additional elements need be defined for
it.  A couplet is defined as a <code>&lt;firstLine&gt;</code> followed by a
<code>&lt;secondLine&gt;</code>.
<div class="pre">&lt;!ELEMENT couplet (firstLine, secondLine) &gt;</div></div><div class="p"><span id="id2352919"/>The elements <code>&lt;firstLine&gt;</code> and <code>&lt;secondLine&gt;</code> (which are
distinguished to enable studies of rhyme scheme, for example) have
exactly the same content model as the existing <code>&lt;line&gt;</code>
element; we will therefore add the following two
lines to our example DTD:
<div class="pre">&lt;!ELEMENT firstLine  (#PCDATA)&gt;
&lt;!ELEMENT secondLine (#PCDATA)&gt;</div>
Next, we can change the declaration for the <code>&lt;poem&gt;</code> element 
to include all three possibilities:
<div class="pre">&lt;!ELEMENT poem  (title?, (stanza+ | couplet+ | line+) ) &gt;</div>
That is, a poem consists of an optional title, followed by one or
several stanzas, or one or several couplets, or one or several lines.
Note the difference between this declaration and the following:
<div class="pre">&lt;!ELEMENT poem  (title?, (stanza | couplet | line)+ ) &gt;</div>
The second version, by applying the occurrence indicator to the group
rather than to each element within it, would allow for a single poem to
contain a mixture of stanzas, couplets, or lines.</div><div class="p"><span id="id2352967"/>A model group can contain <tt>#PCDATA</tt> as well as named elements: this
combination, known as <em>mixed content</em>, allows for elements
in which the sub-components appear with intervening stretches of
character data. For example, if we wished to mark place names wherever
they appear inside our verse lines, then, assuming we have also added a suitable declaration for the
<code>&lt;name&gt;</code> element, we could change the
definition for <code>&lt;line&gt;</code> to
<div class="pre">&lt;!ELEMENT line  (#PCDATA | name )* &gt;</div></div><p><span id="id2352997"/>XML places several constraints on the way that mixed
content models may be defined. In brief, if <tt>#PCDATA</tt> appears with other
elements in a
content model: it must always appear as the first option in an
alternation; it may appear once only, and in the outermost model
group; and if the group containing it is repeated, the star operator
must be used.<a class="notelink" href="#Note17"><sup>17</sup></a></p><div class="p"><span id="id2353018"/>Quite complex models can easily be built up in this way, to match
the structural complexity of many types of text.  As a further example,
consider the case of stanzaic verse in which a refrain or chorus
appears.  Like a stanza, a refrain consists of repetitions of the line element.
A refrain can
appear at the start of a poem only, or as an optional addition
following each stanza.  This could be expressed by a content model such
as the following:
<div class="pre">&lt;!ELEMENT refrain (line+)&gt;
&lt;!ELEMENT poem   (title?, ( line+ | (refrain?, (stanza, refrain?)+ ))) &gt;</div>
That is, a poem consists of an optional title, followed by either
a sequence of lines, or an un-named group, which starts with an
optional refrain, followed by one of more occurrences of another group,
each member of which is composed of a stanza followed by an optional
refrain.  A sequence such as refrain - stanza - stanza - refrain
follows this pattern, as does the sequence stanza - refrain -
stanza
- refrain.  The sequence refrain - refrain - stanza -
stanza
does not, however, and neither does the sequence ‘stanza - refrain -
refrain - stanza.’  Among other conditions made explicit by this
content model are the requirements that at least one stanza must appear
in a poem, if it is not composed simply of lines, and that if there is
both a title and a stanza they must appear in that order.</div><div class="p"><span id="id2353063"/>Note that the apparent complexity of this model derives from the
constraints expressed informally above. A simpler model, such as <div class="pre">&lt;!ELEMENT poem   (title?, (line|refrain|stanza)+ ) &gt;</div> would not enforce any of them, and would therefore permit
such anomalies as a poem consisting only of refrains, or an arbitrary mixture of
lines and refrains. </div></div></div></div><div class="div2" id="SG152"><h3> Complicating the issue</h3><div class="p"><span id="id2353092"/>In the simple cases described so far, it has been assumed that one
can identify the immediate constituents of every element  in a
textual structure.  A poem consists of stanzas, and an anthology
consists of poems.  Stanzas do not float around unattached to poems or
combined into some other unrelated element; a poem cannot contain an
anthology.  All the elements of a given document type may be arranged
into a hierarchic structure, arranged like a family tree with a single
ancestor at one end and many children (mostly the elements containing
simple text) at the other. For example, we could represent an anthology
containing two poems, the first of which contains two four-line
stanzas and the second a single stanza,  by a tree structure like the following figure:
<div class="figure"><img src="./xmlpic.png" width="480" alt=""/></div></div><p><span id="id2353117"/>Clearly, there are many such trees that might be drawn to describe
the structure of this or other anthologies.  Some of them might be
representable as further subdivisions of this tree: for example, we
might subdivide the lines into individual words, since no word crosses
a line boundary. Surprisingly perhaps, this grossly simplified view of
what text is (memorably termed an <em>ordered hierarchy of content
objects</em> (OHCO) view of text by Renear et
al)<a class="notelink" href="#Note18"><sup>18</sup></a> turns out to be very effective for a large number
of purposes. It is not however adequate for the full complexity of
real textual structures, for which more complex mechanisms need to be
employed.  For there are many other trees that might be drawn which do
<em>not</em> fit within this tree.  We might, for example, be
interested in syntactic structures — which rarely respect the
formal boundaries of verse.  Or, to take a simpler example, we might
want to represent the pagination of different editions of the same
text.</p><p><span id="id2353176"/>In the OHCO model of text, representation of cases where different
elements overlap so that several different trees may be identified in
the same document, is generally problematic. A single hierarchy must
be chosen, and the points at which other hierarchies intersect with it
marked (so we might, for example, mark the pagination by means of
empty elements marking the boundary between one page and the next). Or
we could represent alternative hierarchies by means of the pointing
and linking mechanisms described in chapter <a class="link_ptr" href="SA.html" title="14">11  Linking, Segmentation, and Alignment</a> of the
Guidelines. These mechanisms all depend on the use of
<em>attributes</em> which may be used both to identify particular
elements within a document, and to point to, link, or align them into
arbitrary structures.</p></div><div class="div2" id="SG16"><h3> Attributes</h3><p><span id="id2353211"/>In the XML context, the word attribute, like
some other words, has a specific technical sense.  It is used to
describe information which is in some sense descriptive of a specific
element occurrence but not regarded as part of its content. For
example, you might wish to add a <span class="att">status</span> attribute to
occurrences of some elements in a document to indicate their degree of
reliability, or to add an <span class="att">identifier</span> attribute so that you
could refer to particular element occurrences from elsewhere within a
document.  Attributes are useful in precisely such circumstances.</p><p><span id="id2353235"/>Although different elements may have attributes with the same name,
(for example, in the TEI scheme, every element is defined as having an
attribute named <span class="att">rend</span>), they are always regarded as
different, and may have different values assigned to them.  If an
element has been defined as having attributes, the attribute values
are supplied in the document instance as <em>attribute-value
pairs</em> inside the start-tag for the element occurrence. An
end-tag may not contain an attribute-value specification, since it
would be redundant.</p><p><span id="id2353255"/>The order in which attribute-value pairs are supplied inside a tag
has no significance; they must however be separated by at least one
whitespace (blank, newline, or tab) character. In XML, the value part
must always be given inside matching quotation marks, either single or
double.</p><div class="p"><span id="id2353264"/>For example:
	  <div class="pre">&lt;poem xml:id="P1" status="draft"&gt; ... &lt;/poem&gt;</div>
Here attribute values are being specified for two attributes
    previously declared
    for the <code>&lt;poem&gt;</code> element: <span class="att">xml:id</span> and
    <span class="att">status.</span> For the instance of a <code>&lt;poem&gt;</code> in this
    example, represented here by an ellipsis, the <span class="att">xml:id</span>
    attribute has the value <tt>P1</tt> and the <span class="att">status</span>
    attribute has the value <tt>draft</tt>. An XML processor can
    use the values of the attributes in any way it chooses; for
    example, a formatter might print a poem element which has the
    status attribute set to <tt>draft</tt> in a different way from
    one with the same attribute set to <tt>revised</tt>; another
    processor might use the same attribute to determine whether or not
    poem elements are to be processed at all.  The <span class="att">xml:id</span>
    attribute is a slightly special case in that, by convention, it is
    always used to supply a unique value to identify a particular
    element occurrence, which may be used for cross reference
    purposes, as discussed further below.</div><div class="div3" id="front.1_div.4_div.6_div.1"><h4> Declaring attributes</h4><p><span id="id2353336"/>Like elements, attributes are declared in the XML DTD
or schema.  As well as specifying its name and the element to
which it is to be attached, it is possible to specify (within limits)
what kind of value is acceptable for an attribute and a default
value.</p><div class="p"><span id="id2353345"/>The following DTD declarations could be used to define the two attributes
we have supplied above for the <code>&lt;poem&gt;</code> element:
<div class="pre">&lt;!ATTLIST poem
          id       ID                              #IMPLIED
          status   (draft | revised | published)   "draft"        &gt;</div></div><p><span id="id2353357"/>The declaration begins with the symbol <tt>ATTLIST</tt>, which
introduces an <em>attribute list specification</em>. This first
specifies the element concerned, <tt>poem</tt> in this
example. Following this name is a series of
rows, one for each attribute being declared, each containing three
parts.<a class="notelink" href="#Note19"><sup>19</sup></a> These specify the name
of the attribute, the type of value it takes, and a default value
respectively.</p><div class="p"><span id="id2353390"/>The second part of an attribute specification can take one of two
forms, both illustrated above.  The first case uses one of a number of
special keywords to declare what kind of value an attribute may take.
In the example above, the special keyword <tt>ID</tt> is used to
indicate that the attribute <span class="att">xml:id</span> will be used to supply a
unique identifying value for each poem instance (see further the
discussion in section <a class="link_ptr" href="SG.html#SG-id" title="ID and IDREF attributes"> ID and IDREF attributes</a>).  Possible
keywords include:
<ul><li><tt>CDATA</tt>: the attribute value may contain any valid character data,
including spaces or punctuation marks; even tags may be included in
the value, but they will not be recognized by the XML parser, and will
not be processed as tags normally are; </li><li><tt>NMTOKEN</tt>: the attribute value must contain only
          those characters that are valid within a name or a generic
          identifier. </li><li><tt>NMTOKENS</tt>: the attribute value must contain one or
more <tt>NMTOKEN</tt> values separated by one or more whitespace characters.</li><li><tt>ID</tt>: the attribute value must be a single word starting with an
          alphabetic character, which can be used as a unique
          identifier (i.e. a given value can only be used once as the
          value for any <tt>ID</tt> attribute);</li><li><tt>IDREF</tt>: The attribute value must contain a single
          word, which has been used as a unique identifier on  some
other element; </li><li><tt>IDREFS</tt>: The attribute value must contain one or
more <tt>IDREF</tt> values, separated by one or more whitespace characters;
</li><li><tt>ENTITY</tt>: The attribute value must contain a <tt>NMTOKEN</tt>
value which has previously been declared to be the name of some XML
<em>entity</em> (<a class="link_ptr" href="SG.html#SG17" title="Entities"> Entities</a>).</li><li><tt>ENTITIES</tt>: The attribute value must contain one or
more <tt>ENTITY</tt> values, separated by one or more whitespace characters.</li></ul></div><div class="p"><span id="id2353506"/>In a Relax NG schema, the attribute would be defined within
the element declaration as follows:
<div class="pre">&lt;optional&gt;
      &lt;attribute name="id"&gt;
        &lt;data type="ID"/&gt;
      &lt;/attribute&gt;
    &lt;/optional&gt;
    &lt;optional&gt;
      &lt;attribute name="status" a:defaultValue="draft"&gt;
        &lt;choice&gt;
          &lt;value&gt;draft&lt;/value&gt;
          &lt;value&gt;revised&lt;/value&gt;
          &lt;value&gt;published&lt;/value&gt;
        &lt;/choice&gt;
      &lt;/attribute&gt;
    &lt;/optional&gt;</div></div></div><div class="div3" id="front.1_div.4_div.6_div.2"><h4> Attribute names</h4><p><span id="id2353530"/>Attribute names (<span class="att">xml:id</span> and <span class="att">status</span> in
this example) are subject to the same restrictions as other names in
XML; they need not be unique across the whole DTD, however, but only
within the list of attributes for a given element.</p></div><div class="div3" id="front.1_div.4_div.6_div.3"><h4> Attribute values</h4><p><span id="id2353554"/>In the examples above, a list of the possible values for the
<span class="att">status</span> attribute have been supplied.  This means that a
parser can check that no <code>&lt;poem&gt;</code> is defined for which the
<span class="att">status</span> attribute does not have one of <tt>draft</tt>,
<tt>revised</tt>, or <tt>published</tt> as its value.
Alternatively, a parser would have accepted almost any unbroken string
of characters (<tt>status="awful"</tt>,
<tt>status="awe-ful"</tt>, or <tt>status="12345678"</tt>) if
it had been a <tt>NMTOKEN</tt>; or almost any string at all
(<tt>status="anything goes"</tt> or <tt>status = "well, ALMOST
anything"</tt>) if it were <tt>CDATA</tt>.  Sometimes, of
course, the set of possible values cannot be pre-defined.  Where it
can, as in this case, it is generally better to do so.  </p></div><div class="div3" id="front.1_div.4_div.6_div.4"><h4> Default value</h4><div class="p"><span id="id2353624"/>The last piece of information in
each attribute declaration specifies how a parser should interpret the
absence of the attribute concerned.  This can be done by supplying one
of the special keywords listed below, or (as in this case) by
supplying a specific value which is then regarded as the value for
every element which does not supply a value for the attribute
concerned.  Using the example above, if a poem is simply tagged
<span class="tag">&lt;poem&gt;</span>, the parser will treat it exactly as if it were tagged
<span class="tag">&lt;poem status="draft"&gt;</span>.  Alternatively, it is possible to
specify a default value for an attribute. Thus, if the attribute
declaration above were rewritten in DTD language as
<div class="pre">&lt;!ATTLIST poem   id ID #IMPLIED 
                 status (draft | revised | published) #REQUIRED &gt;</div>
then poems which appear in the anthology simply tagged <span class="tag">&lt;poem&gt;</span>
would be reported as erroneously tagged, as would any for which some
value other than <tt>draft,</tt><tt>published,</tt> or
<tt>revised</tt> were supplied.</div></div><div class="div3" id="SG-id"><h4> ID and IDREF attributes</h4><p><span id="id2353687"/>It is sometimes necessary to refer to an occurrence of one textual
element from within another, an obvious example being phrases such as
‘see note 6’ or ‘as discussed in chapter 5.’  When a text is
being produced the actual numbers associated with the notes or chapters
may not be certain.  If we are using descriptive markup, such
things as page or chapter numbers, being entirely matters of
presentation, will not in any case be present in the marked up text:
they will be assigned by whatever processor is operating on the text
(and may indeed differ in different applications).  XML therefore
provides a special mechanism by which any element occurrence may be
given a special identifier, a kind of label, which may be used to refer
to it from anywhere  else within the same text.  The cross-reference
itself is regarded as an element occurrence of a specific kind, which
must also be declared in the DTD.  In each case, the identifying label
(which may be arbitrary) is supplied as the value of a special
attribute.</p><div class="p"><span id="id2353715"/>Suppose, for example, we wish to include a reference within
the notes on one poem that refers to another poem.  We will
first need to provide some way of attaching a label to each
poem:  this is done in the DTD language by defining an attribute for the
<code>&lt;poem&gt;</code> element, as suggested above.
<div class="pre">&lt;!ATTLIST poem
          id       ID     #IMPLIED &gt;</div></div><div class="p"><span id="id2353732"/>Here we define an attribute <span class="att">xml:id</span>, the value of which must be
of type <tt>ID</tt>.  It is not required that any attribute
of type <tt>ID</tt> have the name <span class="att">xml:id</span> as
well; it is however a useful convention almost universally observed.
Note that not every poem need carry an <span class="att">xml:id</span> attribute and the
parser may safely ignore the lack of one in those which do not.  Only
poems to which we intend to refer need use this attribute; for each such
poem we should now include in its start-tag some unique identifier, for
example:
<div class="pre">&lt;poem xml:id="ROSE"&gt;
&lt;/poem&gt;
&lt;poem xml:id="P40"&gt;
&lt;/poem&gt;
&lt;poem&gt;
&lt;/poem&gt;
</div></div><div class="p"><span id="id2353767"/>Next we need to define a new element for the cross reference
itself.  This will not have any content – it is only a
pointer – but it has an attribute, the value of which will be
the identifier of the element pointed at.  This is achieved by
the following declarations; in DTD:
<div class="pre">&lt;!ELEMENT poemRef   EMPTY                  &gt;
&lt;!ATTLIST poemRef   target IDREF #REQUIRED &gt;</div>
and in Relax NG:
<div class="pre_eg">&lt;define name="poemRef"&gt;
    &lt;element name="poemRef"&gt;
      &lt;attribute name="target"&gt;
	&lt;data type="IDREF"/&gt;
      &lt;/attribute&gt;
      &lt;empty/&gt;
    &lt;/element&gt;
  &lt;/define&gt;</div></div><p><span id="id2353796"/>The <code>&lt;poemRef&gt;</code> element has a special content model
because it has
no content.  It has a single attribute called <span class="att">target</span>.  The
value of this attribute must be of type <tt>IDREF</tt> (the keyword used for
cross reference pointers of this type); furthermore, because the
default value is required, it must be supplied on each
occurrence — a <code>&lt;poemRef&gt;</code> with no referent is an impossibility.</p><div class="p"><span id="id2353822"/>With these declarations in force, we can now encode a reference to
the poem whose <span class="att">xml:id</span> attribute specifies that its identifier
is <tt>Rose</tt> as follows:
<div class="pre">Blake's poem on the sick rose 
&lt;poemRef target='Rose'/&gt; ...</div>
In this example, we have used the special syntax defined by XML for
representing empty elements in which the end-tag and the start-tag are
combined into a single tag.  XML also permits representation of empty
elements by an immediately adjacent start- and end-tag, thus <div class="pre">&lt;poemRef
target="#Rose"&gt;&lt;/poemRef&gt;</div>.</div><p><span id="id2353852"/>When an XML parser encounters this empty element it will simply
check that an element exists with the identifier <tt>Rose</tt>.
Different XML processors could take any number of additional actions:
a formatter might construct an exact page and line reference for the
location of the poem in the current document and insert it, or just
quote the poem's title or first lines.  A hypertext style processor
might use this element as a signal to activate a link to the poem
being referred to.  The purpose of the XML markup is simply to
indicate that a cross reference exists: it does not determine what the
processor is to do with it.</p></div></div><div class="div2" id="SG17"><h3> Entities</h3><p><span id="id2353880"/>The aspects of XML discussed so far are all concerned with the
markup of structural elements within a document.  XML also provides a
simple and flexible method of encoding and naming arbitrary parts of
the actual content of a document in a portable way.  In XML the word
<em>entity</em> has a special sense: it means a named part of a
marked up document, irrespective of any structural considerations.  An
entity might be a string of characters or a whole file of text.
Entities can only be declared in a DTD, in the same way as elements or
attributes, and they are included in a document using a construction
known as an <em>entity reference</em>. In the schema, they can
only be declared in a DTD subset (see section <a class="link_ptr" href="SG.html#SG182" title="The DOCTYPE declaration"> The DOCTYPE declaration</a>)
in the document itself.
  </p><div class="div3" id="SG-ents"><h4> Entity declarations</h4><div class="p"><span id="id2353919"/>Like all other declarations, an  entity declaration begins with a
     special keyword, in this case the word
     <span class="ident-kw">ENTITY</span>, followed by the name of the entity
     to be declared, and the value to be used when it is referenced in
     the document. For example, the following declaration
<div class="pre">&lt;!ENTITY tei "Text Encoding Initiative"&gt;</div>
defines an entity whose name is <span class="ident-ge">tei</span> and
whose value is the string <tt>Text Encoding Initiative</tt>. This is an
instance of an <em>entity declaration</em>, which declares an
<em>internal entity</em>.  The following declaration, by contrast,
declares an <em>external entity</em> (sometimes called, loosely, a
<em>system entity</em>):
<div class="pre">&lt;!ENTITY ChapTwo SYSTEM "p4chap2.xml"&gt;</div>
This defines an external entity whose name is <span class="ident-ge">ChapTwo</span> and whose value is the text associated with
the system identifier — in this case, the system identifier is
the name of an operating system file and the replacement text of the
entity is the contents of the file. However, XML does not require
system identifiers to be operating-system file names.<a class="notelink" href="#Note20"><sup>20</sup></a> We might define the same entity as
referring to a web page: <div class="pre">&lt;!ENTITY ChapTwo SYSTEM
"http://www.tei-c.org/P4X/p4chap2.xml"&gt;</div></div><div class="p"><span id="id2354025"/>System identifiers are, by their nature, system dependent; in the
interests of data portability, therefore, XML provides another way of
declaring external entities, shown here: <div class="pre">&lt;!ENTITY p3.sg PUBLIC
"-//TEI//TEXT Guidelines Chapter on XML//EN" "p4chap2.xml"&gt;</div>
Here, the keyword <tt>SYSTEM</tt> has been replaced by the keyword
<tt>PUBLIC</tt>, and the system identifier has been preceded by a
special string known as a <em>formal public identifier</em>.
Although public identifiers can (in principle) take virtually any
form; it is usual to use the form shown above, in which the delimiters
// divide the identifier into the following
parts: <dl><dt>TEI</dt><dd>indicates the owner
of this public identifier (often but not necessarily the owner of the
data in question); the preceding - signals that
this particular owner identifier is not registered with ISO (a
+ would imply that one could find out the full
name and address of the owner from the official registry of owner
identifiers)</dd><dt>TEXT</dt><dd>is a keyword indicating
the nature of the entity: other legal values are <tt>DOCUMENT</tt>
(for full XML documents), <tt>DTD</tt> (for document type
declarations), <tt>ELEMENTS</tt> (for sets of element
declarations), <tt>ENTITIES</tt> (for sets of entity
declarations), <tt>NOTATION</tt> (for notation definitions), and a
number of others which are less frequently needed and will not be
discussed here.</dd><dt>Guidelines Chapter on XML</dt><dd>gives a descriptive name to the entity.</dd><dt>EN</dt><dd>is the ISO language code for the human language in which the
entity is written.</dd></dl></div><p><span id="id2354125"/>Public identifiers help make XML documents less dependent on
particular computer systems, by making it possible to confine the
mapping between entity names and system identifiers to a single
place. As with other such techniques, they require XML systems to
provide mechanisms for mapping from the public identifiers to file
identifiers or other system identifiers: such a mapping is typically
provided by an additional component known as a <em>catalog
file</em> (<a class="link_ptr" href="SG.html#SGPATANC" title="Ancillary Files"> Ancillary Files</a>).</p></div><div class="div3" id="SG-er"><h4> Entity references</h4><p><span id="id2354157"/>Once an entity has been declared it may be referenced anywhere
within a document. This is done by supplying its name prefixed with
the ampersand character and followed by the semicolon.</p><p><span id="id2354164"/>When an XML parser encounters such an <em>entity
reference,</em> it immediately substitutes the value declared for
the entity name. Thus, the passage <tt>The work of the &amp;tei; has
only just begun</tt> will be interpreted by an XML processor exactly
as if it read <tt>The work of the Text Encoding Initiative has only
just begun</tt>. In the case of an external entity, it is, of
course, the contents of the operating system file which are
substituted, so that the passage <tt>The following text has been
suppressed: &amp;ChapTwo;</tt> will be expanded to include the whole
of whatever the system finds in the file <span class="ident-file">p4chap2.xml</span>.</p><p><span id="id2354202"/>This obviously saves typing, and simplifies the task of maintaining
consistency in a set of documents.  If the printing of a complex
document is to be done at many sites, the document body itself might use
an entity reference, such as <tt>&amp;site;</tt>, wherever
the name of the site is required.  Different entity declarations could
then be used at different sites to supply the appropriate string to be
substituted for this name, with no need to change the text of the
document itself.</p><p><span id="id2354217"/>In XML documents, two special entities are predefined, with the names
<span class="ident-ge">amp</span> and <span class="ident-ge">lt</span>. These are available  without
     declaration, so that the ampersand character or less-than sign
can be represented  in a text without their being confused with the start of
     an entity reference or a tag respectively.</p></div><div class="div3" id="SG-cer"><h4> Character references</h4><p><span id="id2354250"/>As mentioned above, XML documents all use the same internal
     character encoding. Since not all computer systems currently
     support this encoding directly, a special form of entity
     reference is defined which can be used to represent individual
     characters from the Unicode  character set in a portable
     way by simply representing their numeric value, in decimal or
     hexadecimal notation. </p><p><span id="id2354261"/>For example, the character é is represented within an XML
     document as the Unicode character with hexadecimal value
     <tt>00E9</tt>. If such a document is being prepared on (or
     exported to) a system using a different character set, say ISO
     646, in which this character is not available, it may instead be
     represented by the character entity reference
     <tt>&amp;#x00E9;</tt> (the x indicating that what follows
     is a hexadecimal value) or <tt>&amp;#0233;</tt>. Entity
     references of this type do not need to be predefined in XML,
     since the underlying character encoding for XML is always the same.
    </p><div class="p"><span id="id2354289"/>To aid legibility however, it is common practice instead to use a
     mnemonic name (such as <tt>eacute</tt>) for such character
     references, and to map these to the appropriate Unicode value by
     means of entity declarations of exactly the same type as those
     already discussed. Standard mnemonic names have been defined by
     ISO for the characters in most widely-used writing systems, and
     grouped together into widely-available <em>entity
     sets</em>. The standard ‘ISO lat1’ entity
     set, for example, includes a declaration like the following for
     the character é:
<div class="pre">&lt;!ENTITY eacute	"&amp;#x00E9;"&gt; &lt;!-- LATIN SMALL LETTER E WITH ACUTE --&gt;</div>
so that, for an XML document which embeds this entity set in its DTD,
a non-Unicode enabled input system may also represent this character
by the entity reference <tt>&amp;eacute;</tt>.</div><div class="p"><span id="id2354327"/>This <em>string substitution</em> mechanism has many other
applications. Suppose, for example, that we wish to encode the use of ligatures
in early printed texts.  The ligatured form of
ct might be distinguished from the
non-ligatured form by encoding it as <tt>&amp;ctlig;</tt>
rather than <tt>ct.</tt> Other special typographic features such
as leafstops or rules could equally well be represented by mnemonic
entity references in the text.  When processing such texts, an entity
declaration would be added giving the desired representation for such
textual elements.  If, for example, ligatured letters are of no
interest, we would simply add a declaration such as
<div class="pre">&lt;!ENTITY ctlig "ct" &gt;</div>
and the distinction present in the source document would be removed.
If, on the other hand, a formatting program capable of representing
ligatured characters is to be used, we might replace the entity
declaration to give whatever sequence of characters such a program
requires as the expansion.</div><p><span id="id2354366"/>More detailed discussion of this and related character encoding
issues is provided in chapter <a class="link_ptr" href="CH.html" title="4">1  Languages and Character Sets</a> of the
Guidelines.</p></div><div class="div3" id="SG-ue"><h4> Unparsed entities and Notations</h4><div class="p"><span id="id2354387"/>An XML entity may contain non-textual information such as pictures,
video, or sound in digitized form. Such objects can be embedded in a
document by reference in exactly the same way as any other external
entity. When such entities are declared, however, it is essential to
indicate that they contain data which an XML parser or processor
cannot handle in the same way as the surrounding data — it is no
use trying to process entities contain pictures or sound as if they
contain text! This is accomplished by including an additional keyword
in the declaration of such entities, as in the following example:
<div class="pre">&lt;!ENTITY fig1 SYSTEM "figure1.png" NDATA png&gt;</div></div><div class="p"><span id="id2354411"/>The keyword <span class="ident-kw">NDATA</span> indicates that this external entity is
<em>unparsed</em>: it contains non-XML data which an XML parser
should ignore. It is followed by an additional name (<tt>png</tt>
in the example above) which identifies the <em>notation</em> used
for this data, that is, the set of conventions which a processor must
understand in order to process the data correctly. XML may itself be
thought of as a notation, which is implied for all external entities
not otherwise labelled. Notations should be declared in a DTD along with
everything else: for the DTD in which the above declaration appears, a
notation declaration like the following would also be appropriate:
<div class="pre">&lt;!NOTATION png PUBLIC
    '-//TEI//NOTATION IETF RFC2083 Portable Network Graphics//EN'&gt;</div>
This gives a formal public identifier for the place where the notation
<tt>png</tt> is defined.</div><p><span id="id2354452"/>More detailed discussion of external unparsed entities and of
recommended graphics notations are given in section <a class="link_ptr" href="FT.html#FTGRA" title="Specific Elements for Graphic Images">19.3  Specific Elements for Graphic Images</a> of the Guidelines.  </p></div><div class="div3" id="SG-pe"><h4> Parameter entities</h4><div class="p"><span id="id2354474"/>A special form of entities, <em>parameter entities</em>, may be
used within XML markup declarations; these differ from the entities
discussed above (which technically are known as <em>general
entities</em>) in two ways:
<ul><li>Parameter entities are used <em>only</em> within XML markup
declarations; they may not appear  within the document
itself.</li><li>Parameter entity references are delimited by percent sign and semicolon,
rather than by ampersand and semicolon.</li></ul></div><div class="p"><span id="id2354507"/>Declarations for parameter entities take the same form as those for
general entities, but insert a percent sign between the keyword
<tt>ENTITY</tt> and the name of the entity itself.  Whitespace characters
(blanks, tabs, or line breaks) must occur on both sides of the percent
sign.  For example, an internal parameter entity named <span class="ident-pe">a.global</span> might be declared with the  expansion
<tt>id ID #REQUIRED  rend CDATA #IMPLIED</tt> as follows:
<div class="pre">&lt;!ENTITY % a.global 
         'id ID #REQUIRED  rend CDATA #IMPLIED'&gt;</div></div><div class="p"><span id="id2354537"/>With this declaration at the start of a DTD, the task (for example) of declaring
attributes consistently on all elements within a DTD becomes much
simpler: all that is needed is to reference the parameter entity, as
in this example:
<div class="pre">&lt;!ATTLIST myElement %a.global;
                    another CDATA #IMPLIED &gt;</div>
since the attribute list  for <span class="tag">&lt;myElement&gt;</span> will now be
understood to contain whatever list of attribute definitions was
declared as the value for the parameter entity <span class="ident-pe">a.global</span>, followed by the definition for an
attribute called <span class="att">another</span>.</div><div class="p"><span id="id2354567"/>Moreover, if we wish to change the global attributes
or add another, all we need do is provide a new declaration for <span class="ident-pe">a.global</span> in the DTD. We do not even need to modify
the existing declaration, but simply ensure that the new one precedes
the old one in the DTD being processed. This is because of one very significant aspect of entity
declarations not mentioned above: if a declaration is given for the
same entity more than once, then only the first declaration is
applicable. If, for example, an XML processor finds the following:
<div class="pre">&lt;!ENTITY switch "UP"&gt; 
&lt;!-- several other declarations --&gt;
&lt;!ENTITY switch "DOWN"&gt;
&lt;!ENTITY switch "SIDEWAYS"&gt;
&lt;!-- .... --&gt;
The switch is &amp;switch;</div>
then the entity reference at the end (assumed to be inside a document)
will be resolved as the string "UP" because that is the first
declaration encountered. This rule applies equally to general entities
and parameter entities, and has important consequences for the TEI
scheme. The TEI DTDs makes extensive use of parameter
entities to control the selection of different tag sets. They are also used to
     control the behaviour of conditional marked sections, as further
     discussed in section <a class="link_ptr" href="SG.html#SG-cond" title="CDATA marked section"> CDATA marked section</a> below. </div></div></div><div class="div2" id="SG17BIS"><h3> Marked sections</h3><p><span id="id2354617"/>It is occasionally necessary to mark some portion of an XML
document for special treatment.  Within the body of a document, it is
often convenient to be able to mark some portion as containing XML
markup which is to be ignored. Within a DTD, it is often convenient to
mark certain parts to be included or excluded in specific
circumstances. To deal with the former situation, XML defines a
construct known as a <em>CDATA marked section</em>; to deal with
the latter, a syntactically similar construct known as a
<em>conditional marked section</em> may be used.</p><p><span id="id2354637"/>Most users of the TEI encoding scheme will never need to use marked
sections, and may safely skip the remainder of this discussion.  The
TEI DTD makes extensive use of conditional marked sections, however,
and this section should be read carefully by anyone wishing to follow
in detail the discussions in chapter <a class="link_ptr" href="ST.html" title="3">2  The TEI infrastructure</a> of the
Guidelines.</p><div class="div3" id="SG-cond"><h4> CDATA marked section</h4><p><span id="id2354663"/>A <tt>CDATA</tt> marked section is delimited by two rather
arcane sequences of characters: its start is marked by the string
<tt>&lt;![CDATA[</tt>, and its end by the string
<tt>]]&gt;</tt>. Note that spaces are not permitted within either
string. </p><div class="p"><span id="id2354681"/>Within a <tt>CDATA</tt> marked section any strings of characters which look
like XML tags or entity references will not be recognized as such by
the XML parser: they are thus a very useful way of including examples
of XML tagging within a document itself written in XML. For example:
<div class="pre"> <span class="element">&lt;p&gt;</span>The
<span class="element">&lt;gi&gt;</span>term<span class="element">&lt;/gi&gt;</span> element may be used to mark any technical<br/> term: <span class="element">&lt;eg&gt;</span>&lt;![CDATA[ This &lt;term&gt;recursion&lt;/term&gt;
is giving me a headache. ]]&gt;<span class="element">&lt;/eg&gt;</span><br/> <span class="element">&lt;/p&gt;</span></div></div><p><span id="id2354707"/>In this extract from a document describing the way that an XML
element called <code>&lt;term&gt;</code> may be used, the cited example (tagged
with a <code>&lt;eg&gt;</code> element) includes an instance of the <code>&lt;term&gt;</code>
element which will not be recognised as such, but simply as a string
of characters, because it is contained by a marked section.</p><div class="p"><span id="id2354727"/>A similar effect can be achieved by simply replacing the angle
brackets by entity references, but this makes the text somewhat
unreadable in its native XML form if the example is of any length:
<div class="pre"> <span class="element">&lt;p&gt;</span>The <span class="element">&lt;gi&gt;</span>term<span class="element">&lt;/gi&gt;</span> element may<br/> be used to mark any technical term: <span class="element">&lt;egXML&gt;</span> This
&lt;term&gt;recursion&lt;/term&gt; is giving me a headache.
<span class="element">&lt;/egXML&gt;</span><br/> <span class="element">&lt;/p&gt;</span></div></div></div><div class="div3" id="SG-cms"><h4> Conditional marked section</h4><p><span id="id2354761"/>The <tt>CDATA</tt> marked section is a special case of the more
general <em>marked section</em> construct. Within the body of a
DTD (but not within the body of a document), two other kinds of marked
section are possible: an <tt>IGNORE</tt> marked section, and an
<tt>INCLUDE</tt> marked section. As the names suggest, material
within an <tt>IGNORE</tt> marked section is ignored during
processing, while material within an <tt>INCLUDE</tt> marked
section is included. These can be used to include and exclude portions
of a DTD selectively, so as to adjust it to relevant
circumstances. </p><div class="p"><span id="id2354795"/>Suppose, for example, that we want to allow for poems which contain
either only stanzas, or only couplets. A content model to enforce this
rule is easy to define, but it does require us to to declare both
possibilities — we must provide declarations for both
<code>&lt;stanza&gt;</code> and <code>&lt;line&gt;</code> elements, even though in a given
document we know that only one will appear. An alternative approach
might be to provide two different declarations for <code>&lt;poem&gt;</code>, as
follows: <div class="pre">
&lt;![INCLUDE[ &lt;!ELEMENT poem (stanza+)&gt; 
&lt;!ELEMENT stanza (line+)&gt; ]]
&lt;![IGNORE[ &lt;!ELEMENT poem (couplet+)&gt; 
&lt;!ELEMENT couplet (line,line)&gt; ]]
</div>
The first declaration here will be the one used, since it is within an
<tt>INCLUDE</tt> marked section. The second one will be ignored. To swap
around, we change <tt>INCLUDE</tt> to <tt>IGNORE</tt>, and vice-versa.</div><p><span id="id2354841"/>The literal keywords <tt>INCLUDE</tt> and <tt>IGNORE</tt>,
however, are not much use in adjusting a DTD or a document to a user's
requirements.  If modifying a DTD to match user requirements involves
editing the text manually (changing <tt>IGNORE</tt> to
<tt>INCLUDE</tt> as appropriate), it is probably just as easy to
add or delete the affected parts of the DTD directly. However, the
<tt>IGNORE</tt> and <tt>INCLUDE</tt> keywords need not be
given as literal values; they can also be represented by a parameter
entity reference.  </p><div class="p"><span id="id2354874"/>In the following DTD example, we have replaced the keywords by
references to two parameter entities:
<div class="pre">
&lt;![%stanzas;[
   &lt;!ELEMENT poem (stanza+)&gt; 
   &lt;!ELEMENT stanza (line+)&gt; 
   &lt;!ENTITY couplets "IGNORE"&gt;
]]
&lt;![%couplets;[
   &lt;!ELEMENT poem (couplet+)&gt; 
   &lt;!ELEMENT couplet (line,line)&gt; 
]]
</div>
The exact meaning of this will depend on the values of the parameter
entities <span class="ident-pe">stanzas</span> and <span class="ident-pe">couplets</span> when the
DTD is processed. When parameter entities are used in this way to
control marked sections in a DTD, the  DTD file must
contain default declarations for them.  If the user wishes to override
any of the
defaults, all that needs to be done is to supply a new declaration and
ensure that it will be processed before the existing default. The
easiest way of doing this is to supply it within a special part of the
DTD known as the <em>DTD subset</em>.<a class="notelink" href="#Note21"><sup>21</sup></a></div><div class="p"><span id="id2354937"/>With the following default declarations, poems will consist only of
stanzas and the second set of declarations will be ignored:
<div class="pre">&lt;!ENTITY % stanzas "INCLUDE"&gt;
&lt;![%stanzas;[
   &lt;!ELEMENT poem (stanza+)&gt; 
   &lt;!ELEMENT stanza (line+)&gt; 
   &lt;!ENTITY % couplets "IGNORE"&gt;
]]&lt;![CDATA[&gt;
&lt;!ENTITY % couplets "INCLUDE"&gt;
&lt;![%couplets;[
   &lt;!ELEMENT poem (couplet+)&gt; 
   &lt;!ELEMENT couplet (line,line)&gt; 
]]
</div>
This works because, although there are two declarations for the
parameter entity <span class="ident-pe">couplets</span>, only the first is
effective. It declares the parameter entity <span class="ident-pe">couplets</span> to
have the value <tt>IGNORE</tt>, and so the declarations within the
second conditional marked section are ignored. Suppose however that a
declaration for <span class="ident-pe">stanzas</span> giving it the value
<tt>IGNORE</tt> were processed before this part of the DTD. In
that event, only the second declaration for the entity
<span class="ident-pe">couplets</span> would be effective, since all the declarations
within the conditional marked section governed by
<span class="ident-pe">stanzas</span> would be ignored. </div><div class="p"><span id="id2354996"/>Variations on this technique are used to control how the various
parts of a TEI DTD are constructed. For example:
<div class="pre_eg">
&lt;!ENTITY % TEI.prose 'INCLUDE'&gt;
&lt;!ENTITY % extensions SYSTEM 'mystuff.dtd'&gt;
</div>
These declarations have two effects: they activate a section of the
DTD containing declarations relevant to prose and they add into the
DTD whatever additional declarations are held in the external file
<span class="ident-file">mystuff.dtd</span>. In the standard DTD files, there is a
marked section controlled by the parameter entity <span class="ident-pe">TEI.prose</span>, the default value of which is
<tt>IGNORE</tt>, and there is also a reference to the parameter
entity <span class="ident-pe">extensions</span>, the default value
for which is the null string. The declarations cited above over-ride
both these defaults: the declarations within the marked section
controlled by the parameter entity <span class="ident-pe">TEI.prose</span>
are thus made active; and the reference to the <span class="ident-pe">extensions</span> parameter entity is replaced by
the content of the file <span class="ident-file">mystuff.dtd</span>.</div></div></div><div class="div2" id="front.1_div.4_div.9"><h3> Other components of an XML document</h3><p><span id="id2355065"/>In addition to the elements and entities so far discussed, an XML
document can contain a few other formally distinct things. An XML
document may contain arbitrary signals or flags for use when the
document is processed in a particular way by some class of processor:
a common example in document production is the need to force a
formatter to start a new page at some specific point in a document:
such flags are called <em>processing instructions</em>. An XML
document may also contain instances of elements which are defined in
some other DTD than the one declared in its <tt>DOCTYPE</tt>
declaration, or (more generally) from some other
<em>namespace</em>. </p><div class="div3" id="SG-pi"><h4> Processing instructions</h4><p><span id="id2355101"/>Although one of the aims of using XML is to remove any information
specific to the processing of a document from the document itself, it
is occasionally very convenient to be able to include such information
— if only so that it can be clearly distinguished from the
structure of the document. As suggested above, one common example is
the need, when processing an XML document for printed output, to
include a suggestion that the formatting processor might use to
determine where to begin a new page of output. Page-breaking decisions
are usually best made by the formatting engine alone, but there will
always be occasions when it may be necessary to over-ride these. An XML
processing instruction inserted into the document is one very simple
and effective way of doing this without interfering with other aspects
of the markup.</p><div class="p"><span id="id2355140"/>Here is an example XML processing instruction:
<div class="pre"/>
It begins with <tt>&lt;?</tt> and
ends  with <tt>?&gt;</tt>. In between are two space-separated
strings: by convention, the first is the name of some processor (<tt>tex</tt> in
the above example) and the second is some data intended for the use of
that processor (in this case, the instruction to start a new
page). The only constraint placed by XML on the strings is that the
first one must be a valid XML name; the other can be any arbitrary
sequence of characters, not including 
the closing character-sequence <tt>?&gt;</tt>,
</div></div><div class="div3" id="SGname"><h4> Namespaces</h4><p><span id="id2355183"/>A valid XML document necessarily specifies the DTD in which its
constituent elements are defined. However, a well-formed XML document
is not required to specify its DTD — indeed, it may not even have a
DTD; it would still be useful to indicate that the element names used
in it have some defined provenance. Furthermore, it might be desirable
to include in a document elements which are defined (possibly
differently) in different DTDs. A cabinet-maker's DTD might well
define an element called <code>&lt;table&gt;</code> with very different
characteristics from those of a documentalist's. </p><p><span id="id2355215"/>The concept of <em>namespace</em> was introduced into the XML
language as a means of addressing these and related problems. If an
XML document is thought of as an expression in some language, then a
namespace may be thought of as analogous to the lexicon of that
language. Just as a document can contain words taken from different
languages, so a well-formed XML document can include elements taken
from different namespaces. Note however that because a document can
only specify a single DTD, elements which belong to namespaces other
than that defined by the DTD will appear to be illegal to a simple XML
validator: documents which use namespaces require special handling by
such processors. Like a DTD, a namespace contains a list of valid element
names; unlike a DTD, a namespace also has a distinctive
<em>prefix</em> and  an identifying <em>name</em>. </p><div class="p"><span id="id2355243"/>Suppose for example that we wish to extend our simple verse DTD to
include markup of wordclass information such as
‘noun’, ‘verb’, etc. Suppose
further that a DTD already exists in which all the tags we wish to use
have been defined. We could (of course) simply combine the two DTDs to
form a new one, but this may not be practicable: for example, there
might be an element defined with the same name but different meanings
in eachschema. Instead, we supply the <em>prefix</em> associated
with the grammatical schema's namespace (<tt>gram</tt>, for example) on each
element which is taken from that namespace, as in the following
example:
<div class="pre">&lt;line xmlns:gram="http://www.gram.org"&gt;
      &lt;gram:aux&gt;Shall&lt;/gram:aux&gt;
      &lt;gram:pron&gt;I&lt;/gram:pron&gt;
      &lt;gram:verb&gt;compare&lt;/gram:verb&gt;
      &lt;gram:pron&gt;thee&lt;/gram:pron&gt;
      &lt;gram:prep&gt;to&lt;/gram:prep&gt;
      &lt;gram:art&gt;a&lt;/gram:art&gt;
      &lt;gram:noun&gt;summer&lt;/gram:noun&gt;
      's
      &lt;gram:noun&gt;day&lt;/gram:noun&gt;
      ?
&lt;/line&gt;</div></div><div class="p"><span id="id2355275"/>In this example, the elements <code>&lt;aux&gt;</code>, <code>&lt;pron&gt;</code> etc. are
understood to be taken from a namespace named
<tt>http://www.gram.org</tt>, which uses the prefix
<tt>gram</tt>, as indicated by the special purpose attribute
<span class="att">xmlns:gram</span>. The element <code>&lt;line&gt;</code> (and the two untagged
text fragments it contains) however are in no particular
namespace. We could specify that they belong, by default, to the TEI
namespace by supplying a default namespace declaration, as follows:
<div class="pre">&lt;line
      xmlns:gram="http://www.gram.org"&gt;
      &lt;gram:aux&gt;Shall&lt;/gram:aux&gt;
      &lt;gram:pron&gt;I&lt;/gram:pron&gt;
      &lt;gram:verb&gt;compare&lt;/gram:verb&gt;
      &lt;gram:pron&gt;thee&lt;/gram:pron&gt;
      &lt;gram:prep&gt;to&lt;/gram:prep&gt;
      &lt;gram:art&gt;a&lt;/gram:art&gt;
      &lt;gram:noun&gt;summer&lt;/gram:noun&gt;
      's
      &lt;gram:noun&gt;day&lt;/gram:noun&gt;
      ?
&lt;/line&gt;</div></div><div class="p"><span id="id2355317"/>As shown here, an XML
document may have one default namespace declaration, and also any
number of other namespace declarations.  The scope of a namespace
declaration is the element on which it is declared: in the example
above, both the default TEI namespace and the additional gram
namespace apply to all elements in the document since they are declared on the
root element. In the following example, the gram namespace is
available only within the <code>&lt;body&gt;</code> element, while the TEI
namespace remains the default for the whole document:
<div class="pre">&lt;text xmlns="http://www.tei-c.org"&gt;
  &lt;front&gt;
    &lt;!-- gram prefix not available here --&gt;
  &lt;/front&gt;
  &lt;body xmlns:gram="http://www.gram.org"&gt;
    &lt;!-- gram prefix is available here --&gt;
  &lt;/body&gt;
&lt;/text&gt;</div></div></div></div><div class="div2" id="SG18"><h3> Putting it all together</h3><p><span id="id2355360"/>An XML conformant document has a number of parts, not all of which
have been discussed in this chapter, and many of which the user of these
Guidelines may safely ignore.  For completeness, the following summary
of how the parts are inter-related may however be found useful.</p><p><span id="id2355369"/>An XML document consists of a  <em>prolog</em> and a
<em>document instance</em>.  The prolog contains an <em>XML
declaration</em> (described below)
and (optionally) a <em>document type declaration</em>, which
contains element and entity declarations such as those described above.
Different software systems may provide different ways of associating the
document instance with the prolog; in some cases, for example, the
prolog may be ‘hard-wired’ into the software used, so that it is
completely invisible to the user.</p><div class="div3" id="SG181"><h4> XML declarations</h4><div class="p"><span id="id2355410"/>SGML allowed for variation in several aspects of the dialect of
SGML being used such as the character set, the codes used for SGML
delimiters, the length of identifiers, etc. All XML documents,
however, use the same SGML declaration, and it is therefore erroneous
to supply one. The only aspect of an XML document which may vary is
the external character encoding used, which is specified by the
<span class="att">encoding</span> parameter on an initial <em>XML
declaration</em>. This looks syntactically like a processing
instruction (<a class="link_ptr" href="SG.html#SG-pi" title="Processing instructions"> Processing instructions</a>): <div class="pre_eg">&lt;?xml version="1.0"
encoding="iso-8859-1"?&gt;</div> but is generally regarded as a
special kind of declaration. If supplied, the XML declaration must be
the first thing found in an XML document. It can specify the version
number of the XML Recommendation applicable to the document it
introduces (in this case, version 1.0), and additionally the character
encoding used to represent the Unicode characters within it. In this
case, the 16 bit characters of Unicode have been mapped to the 8 bit
character set known as ISO 8859-1; any characters present in the
document but not available in the target character set will be
represented as character entity references (<a class="link_ptr" href="SG.html#SG-cer" title="Character references"> Character references</a>).
</div></div><div class="div3" id="SG182"><h4> The DOCTYPE declaration</h4><p><span id="id2355469"/>An XML file which is valid (as opposed to simply well-formed) can
specify a DTD against which its content is to be validated. This is
the function of the <tt>DOCTYPE</tt> declaration. If you use
schemas, the particular schema you wish to validate a document against
is usually specified externally.</p><p><span id="id2355482"/>The <tt>DOCTYPE</tt> declaration contains, following the
<tt>DOCTYPE</tt> keyword, at least two parts: the name of the root
element for the associated document, and a set of declarations for all
the elements, attributes, notations, entities, etc. which together
define the document type declaration (DTD) of that document. Note,
incidentally, that the root element name (and hence the
<tt>DOCTYPE</tt> name) may be that of any element whose
declaration is supplied in this set. The declarations may be supplied
explicitly, or by reference to an external entity such as a file, or
by a combination of the two.
    </p><div class="p"><span id="id2355506"/>Taking each of these possibilities in turn, we first present a
    <tt>DOCTYPE</tt> declaration in which the declarations for all the
    elements, attributes, etc. required are given explicitly:
<div class="pre">&lt;!DOCTYPE myDoc [
  &lt;!ELEMENT myDoc (p+) &gt;
  &lt;!ATTLIST myDoc n CDATA #IMPLIED&gt;
  &lt;!ELEMENT p (#PCDATA)&gt;
]&gt;
&lt;myDoc n="1"&gt;
  &lt;p&gt;This is an instance of a "my.doc" document&lt;/p&gt;
&lt;/myDoc&gt;</div>
Note that the required declarations are enclosed within square
    brackets inside the <tt>DOCTYPE</tt> declaration: this part of the
    declaration is technically known
    as the <em>DTD subset</em>. </div><div class="p"><span id="id2355535"/>More usually, however, the required  declarations  will be held in a
separate entity and invoked by reference, as follows:
<div class="pre">&lt;!DOCTYPE myDoc SYSTEM "myDoc.dtd" []&gt;
&lt;myDoc&gt;
  &lt;p&gt;This is another instance of a "myDoc" document.&lt;/p&gt;
  &lt;p&gt;It has two paragraphs.&lt;/p&gt;
&lt;/myDoc&gt;</div>
Note the similarity between the syntax used to reference the external
entity containing the required declarations and that used to define
any other system entity (see <a class="link_ptr" href="SG.html#SG-ents" title="Entity declarations"> Entity declarations</a>). The square
brackets may be supplied even though they enclose nothing, as in this
example, or they may be omitted.</div><div class="p"><span id="id2355557"/>Next, we present a case where declarations are given both within
    the DTD subset and by reference to an external entity:
<div class="pre">&lt;!DOCTYPE myDoc SYSTEM "myDoc.dtd" [
  &lt;!ENTITY tla "three letter acronym"&gt;]&gt;
&lt;myDoc&gt;
  &lt;p&gt;This is yet another instance of a "myDoc" document.&lt;/p&gt;
  &lt;p&gt;It is surprisingly free of &amp;tla;s.&lt;/p&gt;
&lt;/myDoc&gt;</div></div><div class="p"><span id="id2355567"/>Any kind of declaration may be added to a DTD subset; as we have
already seen (<a class="link_ptr" href="SG.html#SG-cms" title="Conditional marked section"> Conditional marked section</a>), this is the mechanism by which the TEI DTD is
customized. 
<div class="pre">&lt;!DOCTYPE TEI PUBLIC "-//TEI P3//DTD Main Document Type//EN" "tei2.dtd" [
  &lt;!ENTITY % TEI.prose 'INCLUDE'&gt;
  &lt;!ENTITY % TEI.XML   'INCLUDE'&gt;
  &lt;!ENTITY tla "Three Letter Acronym"&gt;
  &lt;!ENTITY % x.phrase  'myTag|'&gt;	 
  &lt;!ELEMENT myTag (#PCDATA)    &gt;
  &lt;!-- any other special-purpose declarations or
       re-declarations go  here --&gt;
  ]&gt;
&lt;TEI&gt;
  &lt;!-- This is an instance of a modified TEI type document, which
       may contain &lt;myTag&gt;my special tags&lt;/myTag&gt; and references 
       to my usual entities such as &amp;tla;. --&gt;
&lt;/TEI&gt;</div>
When, as here, the document type declaration in force includes both
the contents of the DTD subset, and the contents of some external
entity (in the case above, whatever file is specified by the
<tt>PUBLIC</tt> identifier given, <span class="ident-file">tei2.dtd</span> by
default), declarations in the DTD subset are always carried out first.
As noted above, (<a class="link_ptr" href="SG.html#SG-pe" title="Parameter entities"> Parameter entities</a>), the order is important,
because in XML only the first declaration of an entity counts.  In the
above example, therefore, the declaration of the entity <span class="ident-ge">tla</span> in the DTD subset takes precedence over any
declaration of the same entity in the file <span class="ident-file">tei2.dtd</span>.  Similarly, the declaration for <span class="ident-pe">x.phrase</span> takes precedence over the existing
declaration for that entity in the TEI dtd. It is perfectly legal for
entities to be declared more than once; elements, by contrast, may not
be declared more than once; if a declaration for <code>&lt;myTag&gt;</code> were
already contained in file <span class="ident-file">tei.dtd</span>, the XML
parser would signal an error.</div></div><div class="div3" id="SG183"><h4> The Document Instance</h4><div class="p"><span id="id2355662"/>The document instance is the content of the document itself.  It
contains only text, markup, and entity references, and thus may
not contain any new declarations.
A convenient way of building up large documents in a modular fashion
might be to use the DTD subset to declare entities for the individual
pieces or modules, thus:
<div class="pre">&lt;!DOCTYPE TEI 
          PUBLIC "-//TEI P4//DTD Main Document Type//EN"
		         "tei2.dtd" [
   &lt;!ENTITY % TEI.prose "INCLUDE"&gt;
   &lt;!ENTITY % TEI.XML "INCLUDE"&gt;
   &lt;!ENTITY chap1 SYSTEM "chap1.txt"&gt;
   &lt;!ENTITY chap2 SYSTEM "chap2.txt"&gt;
   &lt;!ENTITY chap3 "-- not yet written --"&gt;
   ]&gt;
&lt;TEI&gt;
  &lt;teiHeader&gt; &lt;!-- ... --&gt; &lt;/teiHeader&gt;
    &lt;text&gt;
      &lt;body&gt;
        &amp;chap1;
        &amp;chap2;
        &amp;chap3;
        &lt;!-- ... --&gt;
     &lt;/body&gt;
  &lt;/text&gt;
&lt;/TEI&gt;</div></div><p><span id="id2355674"/>In this example, the TEI DTD 
has been extended by entity declarations
for each chapter of some document.  The first two are external entities
referring to the file in which the text of particular chapters is to
be found; the third a dummy, indicating that the text does not yet
exist (alternatively, an entity with a null value could be used).  In
the document instance, the entity references <tt>&amp;chap1;</tt> etc. will
be resolved by the parser to give the required contents.  The chapter
files themselves will not, of course, contain any element, attribute
list, or entity declarations – just tagged text.</p></div><div class="div3" id="SGPATANC"><h4> Ancillary Files</h4><p><span id="id2355715"/>A working XML system is likely to use a number of ancillary files
to hold configuration information.  These may include stylesheets, 
specialized processing instructions,  collections of relevant entity
declarations, setup information for specific programs, and many other components. In general, the ways in which such components are to be
assembled or configured vary with the system and cannot readily be
described here.</p><p><span id="id2355726"/>To assist in this process many systems take advantage of an
additional <em>catalog file</em>, the chief function of which is
to associate the formal public identifiers used in a document or DTD
with specific system entities, over-riding any default
association. One widely used format for such catalog files was
defined by an industry group originally known as SGML Open, and such
files are therefore known as SGML Open catalogs, even though they may
also be used by XML processors. The group has more recently redefined
itself under the name of the Organization for the Advancement of
Structured Information Standards (OASIS), and in August 2001 published
a specification for catalog files in XML form. <a class="notelink" href="#Note22"><sup>22</sup></a> Catalog files in both SGML Open and
XML formats are distributed along with the current TEI DTDs.</p></div></div><p class="left"><i> Up: </i><a class="navigation" href="index.html">Contents</a><i> Previous: </i><a class="navigation" href="AB.html"> About These Guidelines</a><i> Next: </i><a class="navigation" href="CH.html">1  Languages and Character Sets</a></p><div class="notes"><div class="noteHeading">Notes</div><div class="note"><a id="Note4">4.</a>World Wide Web Consortium:
<i>Extensible Markup Language (XML) 1.0</i>, available from
<a class="link_ptr" href="http://www.w3.org/TR/REC-xml" title=""><span>http://www.w3.org/TR/REC-xml</span></a></div><div class="note"><a id="Note5">5.</a>In the ‘continuous writing’
characteristic of manuscripts from the early classical period, words
are written continuously with no intervening spaces or
punctuation.</div><div class="note"><a id="Note6">6.</a>We
do not here discuss in any detail the ways that a style sheet can be
used or defined, nor do we discuss the popular W3C Stylesheet
Languages. See <a class="link_ptr" href="http://www.w3.org/TR/xsl" title=""><span>http://www.w3.org/TR/xsl</span></a> for the Extensible Stylesheet
Language (XSL), and <a class="link_ptr" href="http://www.w3.org/TR/xslt" title=""><span>http://www.w3.org/TR/xslt</span></a> for the XSL Transformations
(XSLT) Language.</div><div class="note"><a id="Note7">7.</a>See <i>Extensible Markup
Language (XML) 1.0</i>, Section 2.2 Characters.</div><div class="note"><a id="Note8">8.</a>ISO/IEC 10646-1993 <i>Information Technology —
Universal Multiple-Octed Coded Character Set</i> (UCS)</div><div class="note"><a id="Note9">9.</a>See <a class="link_ptr" href="http://www.unicode.org/" title=""><span>http://www.unicode.org/</span></a></div><div class="note"><a id="Note10">10.</a>Because
the opening angle bracket has this special function in an XML
document, special steps must be taken to use that character for other
purposes (for example, as the mathematical less-than operator); see
further section <a class="link_ptr" href="SG.html#SG-er" title="Entity references"> Entity references</a>.</div><div class="note"><a id="Note11">11.</a>The example is
taken from William Blake's <i>Songs of innocence and
experience</i> (1794). The markup is designed for illustrative
purposes and is not TEI-conformant.</div><div class="note"><a id="Note12">12.</a>This is not strictly true for empty
elements, for which start- and end-tags can be combined, as further discussed below.</div><div class="note"><a id="Note13">13.</a>Note that this simple example has not
addressed the problem of marking elements such as sentences
explicitly; the implications of this are discussed in section <a class="link_ptr" href="SG.html#SG152" title="Complicating the issue"> Complicating the issue</a>.</div><div class="note"><a id="Note14">14.</a>Relax NG also supports a compact, non-XML,
syntax, used in the printed TEI Guidelines.</div><div class="note"><a id="Note15">15.</a>In XML,
a single colon may also appear in a GI, where it has a special
significance related to the use of <em>namespaces</em>, as further
discussed in section <a class="link_ptr" href="SG.html#SGname" title="Namespaces"> Namespaces</a>. The
characters defined by Unicode as <em>combining characters</em> and
as <em>extenders</em> are also permitted. </div><div class="note"><a id="Note16">16.</a>It will not have escaped the astute reader that the fact
that verse paragraphs need not start on a line boundary seriously
complicates the issue; see further section <a class="link_ptr" href="SG.html#SG152" title="Complicating the issue"> Complicating the issue</a>.</div><div class="note"><a id="Note17">17.</a>The (good) rationale for these restrictions
is beyond the scope of this tutorial, as are the consequences of
attempting to evade them. The TEI content models all obey these constraints.</div><div class="note"><a id="Note18">18.</a>See <span id="index-bibl-id2353138"/>Renear, A., Mylonas, E.,
Durand, D. ‘Refining our notion of what text really
is: the problem of overlapping hierarchies’  in Ide and Hockey,
eds., <i>Research in Humanities Computing</i>, OUP,
1996</div><div class="note"><a id="Note19">19.</a>These parts are conventionally lined up in
rows for human readability; the parser only requires that there be
some kind of whitespace between them.</div><div class="note"><a id="Note20">20.</a>In general, an external entity can be any data source
available to the XML processor: files, results of database queries,
results of calls to system functions, web pages — anything at
all. System identifiers can use any method to name an entity which the
XML parser's interface to its operating environment can use to elicit
data from the environment.</div><div class="note"><a id="Note21">21.</a>This is
explained in more detail in section <a class="link_ptr" href="SG.html#SG182" title="The DOCTYPE declaration"> The DOCTYPE declaration</a> below; the
key point for our present purposes is that declarations in the DTD
subset are always read before those in the external DTD file, and, as
mentioned above in section <a class="link_ptr" href="SG.html#SG-pe" title="Parameter entities"> Parameter entities</a>, the first
declaration of a given entity is the one which counts.</div><div class="note"><a id="Note22">22.</a>The
SGML Open catalog format is documented in <span id="index-bibl-id2355759"/>SGML Open Technical
Resolution 9401:1997, <i>Entity Management</i>, which
is available from <a class="link_ptr" href="http://xml.coverpages.org/sotr9401-a2.html" title=""><span>http://xml.coverpages.org/sotr9401-a2.html</span></a>; the XML Catalog
specification, also produced by OASIS is available from their site at
<a class="link_ptr" href="http://www.oasis-open.org/committees/entity/spec.html" title=""><span>http://www.oasis-open.org/committees/entity/spec.html</span></a>.</div></div><div class="stdfooter"><hr/><div class="footer"><a class="plain" href="http://www.tei-c.org/Consortium/">TEI Consortium</a> | <a class="plain" href="index.html">TEI P5</a> | <a class="plain" href="http://www.tei-c.org/Consortium/contact.xml">Feedback</a></div><hr/><address> edited by C.M. Sperberg-McQueen and
	Lou Burnard.
      Date: 2007<br/>Copyright TEI Consortium 2007<!--
	  Generated  using an XSLT version 1.0 stylesheet
	  based on http://www.tei-c.org/Stylesheets/teic/tei.xsl
	  processed using libxslt
	  on 2007-03-13T16:02:57Z--></address></div></div></div></div></body></html>
