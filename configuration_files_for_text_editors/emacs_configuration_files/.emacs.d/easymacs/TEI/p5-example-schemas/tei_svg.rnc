default namespace = "http://www.tei-c.org/ns/1.0"
namespace a = "http://relaxng.org/ns/compatibility/annotations/1.0"
namespace a1 = "http://relaxng.org/ns/compatibility/annotations/1.0"
namespace ns1 = "http://www.w3.org/2000/svg"
namespace rng = "http://relaxng.org/ns/structure/1.0"
namespace teix = "http://www.tei-c.org/ns/Examples"
namespace xlink = "http://www.w3.org/1999/xlink"

# Schema generated from ODD source 2007-03-13T16:06:05Z.

# 
# This template file is freely available and you are hereby
#             authorised to copy, modify, and redistribute it in any way without
#             further reference or permissions.
# When making such modifications, you are strongly recommended to
#             change the present text to include an accurate statement of the
#             licencing conditions applicable to your modified text.
div {
  Boolean.datatype = "false" | "true"
  # 'clip-rule' or 'fill-rule' property/attribute value
  ClipFillRule.datatype = "nonzero" | "evenodd" | "inherit"
  # media type, as per [RFC2045]
  ContentType.datatype = string
  # a <coordinate>
  Coordinate.datatype = string
  # a list of <coordinate>s
  Coordinates.datatype = string
  # a <color> value
  Color.datatype = string
  # a <integer>
  Integer.datatype = string
  # a language code, as per [RFC3066]
  LanguageCode.datatype = xsd:NMTOKEN
  # comma-separated list of language codes, as per [RFC3066]
  LanguageCodes.datatype = string
  # a <length>
  Length.datatype = string
  # a list of <length>s
  Lengths.datatype = string
  # a <number>
  Number.datatype = string
  # a list of <number>s
  Numbers.datatype = string
  # opacity value (e.g., <number>)
  OpacityValue.datatype = string
  # a path data specification
  PathData.datatype = string
  # 'preserveAspectRatio' attribute specification
  PreserveAspectRatioSpec.datatype = string
  # script expression
  Script.datatype = string
  # An SVG color value (RGB plus optional ICC)
  SVGColor.datatype = string
  # arbitrary text string
  Text.datatype = string
  # list of transforms
  TransformList.datatype = string
  # a Uniform Resource Identifier, see [URI]
  URI.datatype = string
  # 'viewBox' attribute specification
  ViewBoxSpec.datatype = string
  # end of svg-datatypes.mod
  
  # .......................................................................
  
  # SVG 1.1 Qualified Name Module .........................................
  
  # file: svg-qname.mod
  # 
  # This is SVG, a language for describing two-dimensional graphics in XML.
  # Copyright 2001, 2002 W3C (MIT, INRIA, Keio), All Rights Reserved.
  # Revision: $Id: svg-qname.mod,v 1.3 2002/11/03 15:54:14 fujisawa Exp $
  # 
  # This DTD module is identified by the PUBLIC and SYSTEM identifiers:
  # 
  #    PUBLIC "-//W3C//ENTITIES SVG 1.1 Qualified Name//EN"
  #    SYSTEM "http://www.w3.org/Graphics/SVG/1.1/DTD/svg-qname.mod"
  # 
  # .......................................................................
  
  # Qualified Name
  # 
  # This module is contained in two parts, labeled Section 'A' and 'B':
  # 
  #    Section A declares parameter entities to support namespace-
  #    qualified names, namespace declarations, and name prefixing
  #    for SVG and extensions.
  # 
  #    Section B declares parameter entities used to provide
  #    namespace-qualified names for all SVG element types:
  
  # Section A: SVG XML Namespace Framework ::::::::::::::::::::::
  
  # 1. Declare a %SVG.prefixed; conditional section keyword, used
  # to activate namespace prefixing. The default value should
  # inherit '%NS.prefixed;' from the DTD driver, so that unless
  # overridden, the default behaviour follows the overall DTD
  # prefixing scheme.
  
  # 2. Declare a parameter entity (eg., %SVG.xmlns;) containing
  # the URI reference used to identify the SVG namespace:
  
  # 3. Declare parameter entities (eg., %SVG.prefix;) containing
  # the default namespace prefix string(s) to use when prefixing
  # is enabled. This may be overridden in the DTD driver or the
  # internal subset of an document instance. If no default prefix
  # is desired, this may be declared as an empty string.
  
  # 4. Declare parameter entities (eg., %SVG.pfx;) containing the
  # colonized prefix(es) (eg., '%SVG.prefix;:') used when
  # prefixing is active, an empty string when it is not.
  
  # 5. The parameter entity %SVG.xmlns.extra.attrib; may be
  # redeclared to contain any non-SVG namespace declaration
  # attributes for namespaces embedded in SVG. The default
  # is an empty string.
  
  # Declare a parameter entity XLINK.xmlns.attrib containing
  # the XML Namespace declarations for XLink.
  XLINK.xmlns.attrib = empty
  # Declare a parameter entity %NS.decl.attrib; containing
  # all XML Namespace declarations used in the DTD, plus the
  # xmlns declaration for SVG, its form dependent on whether
  # prefixing is active.
  
  # Declare a parameter entity %SVG.xmlns.attrib; containing
  # all XML namespace declaration attributes used by SVG,
  # including a default xmlns attribute when prefixing is
  # inactive.
  SVG.xmlns.attrib = XLINK.xmlns.attrib
  # Section B: SVG Qualified Names ::::::::::::::::::::::::::::::
  
  # 6. This section declares parameter entities used to provide
  # namespace-qualified names for all SVG element types.
  
  # module: svg-structure.mod .........................
  
  # module: svg-conditional.mod .......................
  
  # module: svg-image.mod .............................
  
  # module: svg-style.mod .............................
  
  # module: svg-shape.mod .............................
  
  # module: svg-text.mod ..............................
  
  # module: svg-marker.mod ............................
  
  # module: svg-profile.mod ...........................
  
  # module: svg-gradient.mod ..........................
  
  # module: svg-pattern.mod ...........................
  
  # module: svg-clip.mod ..............................
  
  # module: svg-mask.mod ..............................
  
  # module: svg-filter.mod ............................
  
  # module: svg-cursor.mod ............................
  
  # module: svg-hyperlink.mod .........................
  
  # module: svg-view.mod ..............................
  
  # module: svg-script.mod ............................
  
  # module: svg-animation.mod .........................
  
  # module: svg-font.mod ..............................
  
  # module: svg-extensibility.mod .....................
  
  # end of svg-qname.mod
  
  # instantiate the Document Model declared in the DTD driver
  
  # .......................................................................
  
  # SVG 1.1 Document Model Module .........................................
  
  # file: svg11-model.mod
  # 
  # This is SVG, a language for describing two-dimensional graphics in XML.
  # Copyright 2001, 2002 W3C (MIT, INRIA, Keio), All Rights Reserved.
  # Revision: $Id: svg11-model.mod,v 1.3 2002/11/14 15:11:03 fujisawa Exp $
  # 
  # This DTD module is identified by the PUBLIC and SYSTEM identifiers:
  # 
  #    PUBLIC "-//W3C//ENTITIES SVG 1.1 Document Model//EN"
  #    SYSTEM "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11-model.mod"
  # 
  # .......................................................................
  
  # SVG 1.1 Document Model
  # 
  # This module describes the groupings of elements that make up
  # common content models for SVG elements.
  
  # module: svg-structure.mod .........................
  SVG.Description.extra.class = notAllowed
  SVG.Description.class =
    desc | title | metadata | SVG.Description.extra.class
  SVG.Use.extra.class = notAllowed
  SVG.Use.class = use | SVG.Use.extra.class
  SVG.Structure.extra.class = notAllowed
  SVG.Structure.class =
    svg | g | defs | symbol | SVG.Use.class | SVG.Structure.extra.class
  # module: svg-conditional.mod .......................
  SVG.Conditional.extra.class = notAllowed
  SVG.Conditional.class = switch | SVG.Conditional.extra.class
  # module: svg-image.mod .............................
  SVG.Image.extra.class = notAllowed
  SVG.Image.class = image | SVG.Image.extra.class
  # module: svg-style.mod .............................
  SVG.Style.extra.class = notAllowed
  SVG.Style.class = style | SVG.Style.extra.class
  # module: svg-shape.mod .............................
  SVG.Shape.extra.class = notAllowed
  SVG.Shape.class =
    path
    | rect
    | circle
    | line
    | ellipse
    | polyline
    | polygon
    | SVG.Shape.extra.class
  # module: svg-text.mod ..............................
  SVG.Text.extra.class = notAllowed
  SVG.Text.class = \text | altGlyphDef | SVG.Text.extra.class
  SVG.TextContent.extra.class = notAllowed
  SVG.TextContent.class =
    tspan | tref | textPath | altGlyph | SVG.TextContent.extra.class
  # module: svg-marker.mod ............................
  SVG.Marker.extra.class = notAllowed
  SVG.Marker.class = marker | SVG.Marker.extra.class
  # module: svg-profile.mod ...........................
  SVG.ColorProfile.extra.class = notAllowed
  SVG.ColorProfile.class = color-profile | SVG.ColorProfile.extra.class
  # module: svg-gradient.mod ..........................
  SVG.Gradient.extra.class = notAllowed
  SVG.Gradient.class =
    linearGradient | radialGradient | SVG.Gradient.extra.class
  # module: svg-pattern.mod ...........................
  SVG.Pattern.extra.class = notAllowed
  SVG.Pattern.class = svgpattern | SVG.Pattern.extra.class
  # module: svg-clip.mod ..............................
  SVG.Clip.extra.class = notAllowed
  SVG.Clip.class = clipPath | SVG.Clip.extra.class
  # module: svg-mask.mod ..............................
  SVG.Mask.extra.class = notAllowed
  SVG.Mask.class = mask | SVG.Mask.extra.class
  # module: svg-filter.mod ............................
  SVG.Filter.extra.class = notAllowed
  SVG.Filter.class = filter | SVG.Filter.extra.class
  SVG.FilterPrimitive.extra.class = notAllowed
  SVG.FilterPrimitive.class =
    feBlend
    | feColorMatrix
    | feComponentTransfer
    | feComposite
    | feConvolveMatrix
    | feDiffuseLighting
    | feDisplacementMap
    | feFlood
    | feGaussianBlur
    | feImage
    | feMerge
    | feMorphology
    | feOffset
    | feSpecularLighting
    | feTile
    | feTurbulence
    | SVG.FilterPrimitive.extra.class
  # module: svg-cursor.mod ............................
  SVG.Cursor.extra.class = notAllowed
  SVG.Cursor.class = cursor | SVG.Cursor.extra.class
  # module: svg-hyperlink.mod .........................
  SVG.Hyperlink.extra.class = notAllowed
  SVG.Hyperlink.class = a | SVG.Hyperlink.extra.class
  # module: svg-view.mod ..............................
  SVG.View.extra.class = notAllowed
  SVG.View.class = view | SVG.View.extra.class
  # module: svg-script.mod ............................
  SVG.Script.extra.class = notAllowed
  SVG.Script.class = script | SVG.Script.extra.class
  # module: svg-animation.mod .........................
  SVG.Animation.extra.class = notAllowed
  SVG.Animation.class =
    animate
    | set
    | animateMotion
    | animateColor
    | animateTransform
    | SVG.Animation.extra.class
  # module: svg-font.mod ..............................
  SVG.Font.extra.class = notAllowed
  SVG.Font.class = font | font-face | SVG.Font.extra.class
  # module: svg-extensibility.mod .....................
  SVG.Extensibility.extra.class = notAllowed
  SVG.Extensibility.class =
    foreignObject | SVG.Extensibility.extra.class
  # end of svg11-model.mod
  
  # instantiate the Attribute Collection declared in the DTD driver
  
  # .......................................................................
  
  # SVG 1.1 Attribute Collection Module ...................................
  
  # file: svg11-attribs.mod
  # 
  # This is SVG, a language for describing two-dimensional graphics in XML.
  # Copyright 2001, 2002 W3C (MIT, INRIA, Keio), All Rights Reserved.
  # Revision: $Id: svg11-attribs.mod,v 1.4 2002/11/14 15:11:03 fujisawa Exp $
  # 
  # This DTD module is identified by the PUBLIC and SYSTEM identifiers:
  # 
  #    PUBLIC "-//W3C//ENTITIES SVG 1.1 Attribute Collection//EN"
  #    SYSTEM "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11-attribs.mod"
  # 
  # .......................................................................
  
  # SVG 1.1 Attribute Collection
  # 
  # This module defines the set of common attributes that can be present
  # on many SVG elements.
  
  # module: svg-conditional.mod .......................
  ExtensionList.datatype = string
  FeatureList.datatype = string
  SVG.Conditional.extra.attrib = empty
  SVG.Conditional.attrib =
    attribute requiredFeatures { FeatureList.datatype }?,
    attribute requiredExtensions { ExtensionList.datatype }?,
    attribute systemLanguage { LanguageCodes.datatype }?,
    SVG.Conditional.extra.attrib
  # module: svg-style.mod .............................
  ClassList.datatype = string
  StyleSheet.datatype = string
  SVG.Style.extra.attrib = empty
  SVG.Style.attrib =
    attribute style { StyleSheet.datatype }?,
    attribute class { ClassList.datatype }?,
    SVG.Style.extra.attrib
  # module: svg-text.mod ..............................
  BaselineShiftValue.datatype = string
  FontFamilyValue.datatype = string
  FontSizeValue.datatype = string
  FontSizeAdjustValue.datatype = string
  GlyphOrientationHorizontalValue.datatype = string
  GlyphOrientationVerticalValue.datatype = string
  KerningValue.datatype = string
  SpacingValue.datatype = string
  TextDecorationValue.datatype = string
  SVG.Text.extra.attrib = empty
  SVG.Text.attrib =
    attribute writing-mode {
      "lr-tb" | "rl-tb" | "tb-rl" | "lr" | "rl" | "tb" | "inherit"
    }?,
    SVG.Text.extra.attrib
  SVG.TextContent.extra.attrib = empty
  SVG.TextContent.attrib =
    attribute alignment-baseline {
      "auto"
      | "baseline"
      | "before-edge"
      | "text-before-edge"
      | "middle"
      | "central"
      | "after-edge"
      | "text-after-edge"
      | "ideographic"
      | "alphabetic"
      | "hanging"
      | "mathematical"
      | "inherit"
    }?,
    attribute baseline-shift { BaselineShiftValue.datatype }?,
    attribute direction { "ltr" | "rtl" | "inherit" }?,
    attribute dominant-baseline {
      "auto"
      | "use-script"
      | "no-change"
      | "reset-size"
      | "ideographic"
      | "alphabetic"
      | "hanging"
      | "mathematical"
      | "central"
      | "middle"
      | "text-after-edge"
      | "text-before-edge"
      | "inherit"
    }?,
    attribute glyph-orientation-horizontal {
      GlyphOrientationHorizontalValue.datatype
    }?,
    attribute glyph-orientation-vertical {
      GlyphOrientationVerticalValue.datatype
    }?,
    attribute kerning { KerningValue.datatype }?,
    attribute letter-spacing { SpacingValue.datatype }?,
    attribute text-anchor { "start" | "middle" | "end" | "inherit" }?,
    attribute text-decoration { TextDecorationValue.datatype }?,
    attribute unicode-bidi {
      "normal" | "embed" | "bidi-override" | "inherit"
    }?,
    attribute word-spacing { SpacingValue.datatype }?,
    SVG.TextContent.extra.attrib
  SVG.Font.extra.attrib = empty
  SVG.Font.attrib =
    attribute font-family { FontFamilyValue.datatype }?,
    attribute font-size { FontSizeValue.datatype }?,
    attribute font-size-adjust { FontSizeAdjustValue.datatype }?,
    attribute font-stretch {
      "normal"
      | "wider"
      | "narrower"
      | "ultra-condensed"
      | "extra-condensed"
      | "condensed"
      | "semi-condensed"
      | "semi-expanded"
      | "expanded"
      | "extra-expanded"
      | "ultra-expanded"
      | "inherit"
    }?,
    attribute font-style {
      "normal" | "italic" | "oblique" | "inherit"
    }?,
    attribute font-variant { "normal" | "small-caps" | "inherit" }?,
    attribute font-weight {
      "normal"
      | "bold"
      | "bolder"
      | "lighter"
      | "100"
      | "200"
      | "300"
      | "400"
      | "500"
      | "600"
      | "700"
      | "800"
      | "900"
      | "inherit"
    }?,
    SVG.Font.extra.attrib
  # module: svg-marker.mod ............................
  MarkerValue.datatype = string
  SVG.Marker.extra.attrib = empty
  SVG.Marker.attrib =
    attribute marker-start { MarkerValue.datatype }?,
    attribute marker-mid { MarkerValue.datatype }?,
    attribute marker-end { MarkerValue.datatype }?,
    SVG.Marker.extra.attrib
  # module: svg-profile.mod ...........................
  SVG.ColorProfile.extra.attrib = empty
  SVG.ColorProfile.attrib =
    attribute color-profile { text }?,
    SVG.ColorProfile.extra.attrib
  # module: svg-gradient.mod ..........................
  NumberOrPercentage.datatype = string
  SVG.Gradient.extra.attrib = empty
  SVG.Gradient.attrib =
    attribute stop-color { SVGColor.datatype }?,
    attribute stop-opacity { OpacityValue.datatype }?,
    SVG.Gradient.extra.attrib
  # module: svg-clip.mod ..............................
  ClipPathValue.datatype = string
  SVG.Clip.extra.attrib = empty
  SVG.Clip.attrib =
    attribute clip-path { ClipPathValue.datatype }?,
    attribute clip-rule { ClipFillRule.datatype }?,
    SVG.Clip.extra.attrib
  # module: svg-mask.mod ..............................
  MaskValue.datatype = string
  SVG.Mask.extra.attrib = empty
  SVG.Mask.attrib =
    attribute mask { MaskValue.datatype }?,
    SVG.Mask.extra.attrib
  # module: svg-filter.mod ............................
  FilterValue.datatype = string
  NumberOptionalNumber.datatype = string
  SVG.Filter.extra.attrib = empty
  SVG.Filter.attrib =
    attribute filter { FilterValue.datatype }?,
    SVG.Filter.extra.attrib
  SVG.FilterColor.extra.attrib = empty
  SVG.FilterColor.attrib =
    attribute color-interpolation-filters {
      "auto" | "sRGB" | "linearRGB" | "inherit"
    }?,
    SVG.FilterColor.extra.attrib
  # module: svg-cursor.mod ............................
  CursorValue.datatype = string
  SVG.Cursor.extra.attrib = empty
  SVG.Cursor.attrib =
    attribute cursor { CursorValue.datatype }?,
    SVG.Cursor.extra.attrib
  # end of svg11-attribs.mod
  
  # end of svg-framework.mod
  
  # Post-Framework Redeclaration Placeholder ....................
  
  # :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
  
  # Core Attribute Module .......................................
  
  # .......................................................................
  
  # SVG 1.1 Core Attribute Module .........................................
  
  # file: svg-core-attrib.mod
  # 
  # This is SVG, a language for describing two-dimensional graphics in XML.
  # Copyright 2001, 2002 W3C (MIT, INRIA, Keio), All Rights Reserved.
  # Revision: $Id: svg-core-attrib.mod,v 1.3 2002/04/28 13:50:23 fujisawa Exp $
  # 
  # This DTD module is identified by the PUBLIC and SYSTEM identifiers:
  # 
  #    PUBLIC "-//W3C//ENTITIES SVG 1.1 Core Attribute//EN"
  #    SYSTEM "http://www.w3.org/Graphics/SVG/1.1/DTD/svg-core-attrib.mod"
  # 
  # .......................................................................
  
  # Core Attribute
  # 
  #    id, xml:base, xml:lang, xml:space
  # 
  # This module defines the core set of attributes that can be present on
  # any element.
  SVG.id.attrib = attribute id { xsd:ID }?
  SVG.base.attrib = attribute xml:base { URI.datatype }?
  SVG.lang.attrib = attribute xml:lang { LanguageCode.datatype }?
  SVG.space.attrib = attribute xml:space { "default" | "preserve" }?
  SVG.Core.extra.attrib = empty
  SVG.Core.attrib =
    SVG.id.attrib,
    SVG.base.attrib,
    SVG.lang.attrib,
    SVG.space.attrib,
    SVG.Core.extra.attrib
  # end of svg-core-attrib.mod
  
  # Container Attribute Module ..................................
  
  # .......................................................................
  
  # SVG 1.1 Container Attribute Module ....................................
  
  # file: svg-container-attrib.mod
  # 
  # This is SVG, a language for describing two-dimensional graphics in XML.
  # Copyright 2001, 2002 W3C (MIT, INRIA, Keio), All Rights Reserved.
  # Revision: $Id: svg-container-attrib.mod,v 1.2 2002/04/20 18:07:42 fujisawa Exp $
  # 
  # This DTD module is identified by the PUBLIC and SYSTEM identifiers:
  # 
  #    PUBLIC "-//W3C//ENTITIES SVG 1.1 Container Attribute//EN"
  #    SYSTEM "http://www.w3.org/Graphics/SVG/1.1/DTD/svg-container-attrib.mod"
  # 
  # .......................................................................
  
  # Container Attribute
  # 
  #    enable-background
  # 
  # This module defines the Container attribute set.
  
  # 'enable-background' property/attribute value (e.g., 'new', 'accumulate')
  EnableBackgroundValue.datatype = string
  SVG.enable-background.attrib =
    attribute enable-background { EnableBackgroundValue.datatype }?
  SVG.Container.extra.attrib = empty
  SVG.Container.attrib =
    SVG.enable-background.attrib, SVG.Container.extra.attrib
  # end of svg-container-attrib.mod
  
  # Viewport Attribute Module ...................................
  
  # .......................................................................
  
  # SVG 1.1 Viewport Attribute Module .....................................
  
  # file: svg-viewport-attrib.mod
  # 
  # This is SVG, a language for describing two-dimensional graphics in XML.
  # Copyright 2001, 2002 W3C (MIT, INRIA, Keio), All Rights Reserved.
  # Revision: $Id: svg-viewport-attrib.mod,v 1.2 2002/04/20 18:07:43 fujisawa Exp $
  # 
  # This DTD module is identified by the PUBLIC and SYSTEM identifiers:
  # 
  #    PUBLIC "-//W3C//ENTITIES SVG 1.1 Viewport Attribute//EN"
  #    SYSTEM "http://www.w3.org/Graphics/SVG/1.1/DTD/svg-viewport-attrib.mod"
  # 
  # .......................................................................
  
  # Viewport Attribute
  # 
  #    clip, overflow
  # 
  # This module defines the Viewport attribute set.
  
  # 'clip' property/attribute value (e.g., 'auto', rect(...))
  ClipValue.datatype = string
  SVG.clip.attrib = attribute clip { ClipValue.datatype }?
  SVG.overflow.attrib =
    attribute overflow {
      "visible" | "hidden" | "scroll" | "auto" | "inherit"
    }?
  SVG.Viewport.extra.attrib = empty
  SVG.Viewport.attrib =
    SVG.clip.attrib, SVG.overflow.attrib, SVG.Viewport.extra.attrib
  # end of svg-viewport-attrib.mod
  
  # Paint Attribute Module ......................................
  
  # .......................................................................
  
  # SVG 1.1 Paint Attribute Module ........................................
  
  # file: svg-paint-attrib.mod
  # 
  # This is SVG, a language for describing two-dimensional graphics in XML.
  # Copyright 2001, 2002 W3C (MIT, INRIA, Keio), All Rights Reserved.
  # Revision: $Id: svg-paint-attrib.mod,v 1.2 2002/04/20 18:07:43 fujisawa Exp $
  # 
  # This DTD module is identified by the PUBLIC and SYSTEM identifiers:
  # 
  #    PUBLIC "-//W3C//ENTITIES SVG 1.1 Paint Attribute//EN"
  #    SYSTEM "http://www.w3.org/Graphics/SVG/1.1/DTD/svg-paint-attrib.mod"
  # 
  # .......................................................................
  
  # Paint Attribute
  # 
  #    fill, fill-rule, stroke, stroke-dasharray, stroke-dashoffset,
  #    stroke-linecap, stroke-linejoin, stroke-miterlimit, stroke-width, color,
  #    color-interpolation, color-rendering
  # 
  # This module defines the Paint and Color attribute sets.
  
  # a 'fill' or 'stroke' property/attribute value: <paint>
  Paint.datatype = string
  # 'stroke-dasharray' property/attribute value (e.g., 'none', list of <number>s)
  StrokeDashArrayValue.datatype = string
  # 'stroke-dashoffset' property/attribute value (e.g., 'none', <legnth>)
  StrokeDashOffsetValue.datatype = string
  # 'stroke-miterlimit' property/attribute value (e.g., <number>)
  StrokeMiterLimitValue.datatype = string
  # 'stroke-width' property/attribute value (e.g., <length>)
  StrokeWidthValue.datatype = string
  SVG.fill.attrib = attribute fill { Paint.datatype }?
  SVG.fill-rule.attrib = attribute fill-rule { ClipFillRule.datatype }?
  SVG.stroke.attrib = attribute stroke { Paint.datatype }?
  SVG.stroke-dasharray.attrib =
    attribute stroke-dasharray { StrokeDashArrayValue.datatype }?
  SVG.stroke-dashoffset.attrib =
    attribute stroke-dashoffset { StrokeDashOffsetValue.datatype }?
  SVG.stroke-linecap.attrib =
    attribute stroke-linecap {
      "butt" | "round" | "square" | "inherit"
    }?
  SVG.stroke-linejoin.attrib =
    attribute stroke-linejoin {
      "miter" | "round" | "bevel" | "inherit"
    }?
  SVG.stroke-miterlimit.attrib =
    attribute stroke-miterlimit { StrokeMiterLimitValue.datatype }?
  SVG.stroke-width.attrib =
    attribute stroke-width { StrokeWidthValue.datatype }?
  SVG.Paint.extra.attrib = empty
  SVG.Paint.attrib =
    SVG.fill.attrib,
    SVG.fill-rule.attrib,
    SVG.stroke.attrib,
    SVG.stroke-dasharray.attrib,
    SVG.stroke-dashoffset.attrib,
    SVG.stroke-linecap.attrib,
    SVG.stroke-linejoin.attrib,
    SVG.stroke-miterlimit.attrib,
    SVG.stroke-width.attrib,
    SVG.Paint.extra.attrib
  SVG.color.attrib = attribute color { Color.datatype }?
  SVG.color-interpolation.attrib =
    attribute color-interpolation {
      "auto" | "sRGB" | "linearRGB" | "inherit"
    }?
  SVG.color-rendering.attrib =
    attribute color-rendering {
      "auto" | "optimizeSpeed" | "optimizeQuality" | "inherit"
    }?
  SVG.Color.extra.attrib = empty
  SVG.Color.attrib =
    SVG.color.attrib,
    SVG.color-interpolation.attrib,
    SVG.color-rendering.attrib,
    SVG.Color.extra.attrib
  # end of svg-paint-attrib.mod
  
  # Paint Opacity Attribute Module ..............................
  
  # .......................................................................
  
  # SVG 1.1 Paint Opacity Attribute Module ................................
  
  # file: svg-opacity-attrib.mod
  # 
  # This is SVG, a language for describing two-dimensional graphics in XML.
  # Copyright 2001, 2002 W3C (MIT, INRIA, Keio), All Rights Reserved.
  # Revision: $Id: svg-opacity-attrib.mod,v 1.2 2002/04/20 18:07:43 fujisawa Exp $
  # 
  # This DTD module is identified by the PUBLIC and SYSTEM identifiers:
  # 
  #    PUBLIC "-//W3C//ENTITIES SVG 1.1 Paint Opacity Attribute//EN"
  #    SYSTEM "http://www.w3.org/Graphics/SVG/1.1/DTD/svg-opacity-attrib.mod"
  # 
  # .......................................................................
  
  # Paint Opacity Attribute
  # 
  #    opacity, fill-opacity, stroke-opacity
  # 
  # This module defines the Opacity attribute set.
  SVG.opacity.attrib = attribute opacity { OpacityValue.datatype }?
  SVG.fill-opacity.attrib =
    attribute fill-opacity { OpacityValue.datatype }?
  SVG.stroke-opacity.attrib =
    attribute stroke-opacity { OpacityValue.datatype }?
  SVG.Opacity.extra.attrib = empty
  SVG.Opacity.attrib =
    SVG.opacity.attrib,
    SVG.fill-opacity.attrib,
    SVG.stroke-opacity.attrib,
    SVG.Opacity.extra.attrib
  # end of svg-opacity-attrib.mod
  
  # Graphics Attribute Module ...................................
  
  # .......................................................................
  
  # SVG 1.1 Graphics Attribute Module .....................................
  
  # file: svg-graphics-attrib.mod
  # 
  # This is SVG, a language for describing two-dimensional graphics in XML.
  # Copyright 2001, 2002 W3C (MIT, INRIA, Keio), All Rights Reserved.
  # Revision: $Id: svg-graphics-attrib.mod,v 1.2 2002/04/20 18:07:43 fujisawa Exp $
  # 
  # This DTD module is identified by the PUBLIC and SYSTEM identifiers:
  # 
  #    PUBLIC "-//W3C//ENTITIES SVG 1.1 Graphics Attribute//EN"
  #    SYSTEM "http://www.w3.org/Graphics/SVG/1.1/DTD/svg-graphics-attrib.mod"
  # 
  # .......................................................................
  
  # Graphics Attribute
  # 
  #    display, image-rendering, pointer-events, shape-rendering,
  #    text-rendering, visibility
  # 
  # This module defines the Graphics attribute set.
  SVG.display.attrib =
    attribute display {
      "inline"
      | "block"
      | "list-item"
      | "run-in"
      | "compact"
      | "marker"
      | "table"
      | "inline-table"
      | "table-row-group"
      | "table-header-group"
      | "table-footer-group"
      | "table-row"
      | "table-column-group"
      | "table-column"
      | "table-cell"
      | "table-caption"
      | "none"
      | "inherit"
    }?
  SVG.image-rendering.attrib =
    attribute image-rendering {
      "auto" | "optimizeSpeed" | "optimizeQuality" | "inherit"
    }?
  SVG.pointer-events.attrib =
    attribute pointer-events {
      "visiblePainted"
      | "visibleFill"
      | "visibleStroke"
      | "visible"
      | "painted"
      | "fill"
      | "stroke"
      | "all"
      | "none"
      | "inherit"
    }?
  SVG.shape-rendering.attrib =
    attribute shape-rendering {
      "auto"
      | "optimizeSpeed"
      | "crispEdges"
      | "geometricPrecision"
      | "inherit"
    }?
  SVG.text-rendering.attrib =
    attribute text-rendering {
      "auto"
      | "optimizeSpeed"
      | "optimizeLegibility"
      | "geometricPrecision"
      | "inherit"
    }?
  SVG.visibility.attrib =
    attribute visibility { "visible" | "hidden" | "inherit" }?
  SVG.Graphics.extra.attrib = empty
  SVG.Graphics.attrib =
    SVG.display.attrib,
    SVG.image-rendering.attrib,
    SVG.pointer-events.attrib,
    SVG.shape-rendering.attrib,
    SVG.text-rendering.attrib,
    SVG.visibility.attrib,
    SVG.Graphics.extra.attrib
  # end of svg-graphics-attrib.mod
  
  # Document Events Attribute Module ............................
  
  # .......................................................................
  
  # SVG 1.1 Document Events Attribute Module ..............................
  
  # file: svg-docevents-attrib.mod
  # 
  # This is SVG, a language for describing two-dimensional graphics in XML.
  # Copyright 2001, 2002 W3C (MIT, INRIA, Keio), All Rights Reserved.
  # Revision: $Id: svg-docevents-attrib.mod,v 1.2 2002/04/20 18:07:42 fujisawa Exp $
  # 
  # This DTD module is identified by the PUBLIC and SYSTEM identifiers:
  # 
  #    PUBLIC "-//W3C//ENTITIES SVG 1.1 Document Events Attribute//EN"
  #    SYSTEM "http://www.w3.org/Graphics/SVG/1.1/DTD/svg-docevents-attrib.mod"
  # 
  # .......................................................................
  
  # Document Events Attribute
  # 
  #    onunload, onabort, onerror, onresize, onscroll, onzoom
  # 
  # This module defines the DocumentEvents attribute set.
  SVG.onunload.attrib = attribute onunload { Script.datatype }?
  SVG.onabort.attrib = attribute onabort { Script.datatype }?
  SVG.onerror.attrib = attribute onerror { Script.datatype }?
  SVG.onresize.attrib = attribute onresize { Script.datatype }?
  SVG.onscroll.attrib = attribute onscroll { Script.datatype }?
  SVG.onzoom.attrib = attribute onzoom { Script.datatype }?
  SVG.DocumentEvents.extra.attrib = empty
  SVG.DocumentEvents.attrib =
    SVG.onunload.attrib,
    SVG.onabort.attrib,
    SVG.onerror.attrib,
    SVG.onresize.attrib,
    SVG.onscroll.attrib,
    SVG.onzoom.attrib,
    SVG.DocumentEvents.extra.attrib
  # end of svg-docevents-attrib.mod
  
  # Graphical Element Events Attribute Module ...................
  
  # .......................................................................
  
  # SVG 1.1 Graphical Element Events Attribute Module .....................
  
  # file: svg-graphevents-attrib.mod
  # 
  # This is SVG, a language for describing two-dimensional graphics in XML.
  # Copyright 2001, 2002 W3C (MIT, INRIA, Keio), All Rights Reserved.
  # Revision: $Id: svg-graphevents-attrib.mod,v 1.2 2002/04/20 18:07:43 fujisawa Exp $
  # 
  # This DTD module is identified by the PUBLIC and SYSTEM identifiers:
  # 
  #    PUBLIC "-//W3C//ENTITIES SVG 1.1 Graphical Element Events Attribute//EN"
  #    SYSTEM "http://www.w3.org/Graphics/SVG/1.1/DTD/svg-graphevents-attrib.mod"
  # 
  # .......................................................................
  
  # Graphical Element Events Attribute
  # 
  #    onfocusin, onfocusout, onactivate, onclick, onmousedown, onmouseup,
  #    onmouseover, onmousemove, onmouseout, onload
  # 
  # This module defines the GraphicalEvents attribute set.
  SVG.onfocusin.attrib = attribute onfocusin { Script.datatype }?
  SVG.onfocusout.attrib = attribute onfocusout { Script.datatype }?
  SVG.onactivate.attrib = attribute onactivate { Script.datatype }?
  SVG.onclick.attrib = attribute onclick { Script.datatype }?
  SVG.onmousedown.attrib = attribute onmousedown { Script.datatype }?
  SVG.onmouseup.attrib = attribute onmouseup { Script.datatype }?
  SVG.onmouseover.attrib = attribute onmouseover { Script.datatype }?
  SVG.onmousemove.attrib = attribute onmousemove { Script.datatype }?
  SVG.onmouseout.attrib = attribute onmouseout { Script.datatype }?
  SVG.onload.attrib = attribute onload { Script.datatype }?
  SVG.GraphicalEvents.extra.attrib = empty
  SVG.GraphicalEvents.attrib =
    SVG.onfocusin.attrib,
    SVG.onfocusout.attrib,
    SVG.onactivate.attrib,
    SVG.onclick.attrib,
    SVG.onmousedown.attrib,
    SVG.onmouseup.attrib,
    SVG.onmouseover.attrib,
    SVG.onmousemove.attrib,
    SVG.onmouseout.attrib,
    SVG.onload.attrib,
    SVG.GraphicalEvents.extra.attrib
  # end of svg-graphevents-attrib.mod
  
  # Animation Events Attribute Module ...........................
  
  # .......................................................................
  
  # SVG 1.1 Animation Events Attribute Module .............................
  
  # file: svg-animevents-attrib.mod
  # 
  # This is SVG, a language for describing two-dimensional graphics in XML.
  # Copyright 2001, 2002 W3C (MIT, INRIA, Keio), All Rights Reserved.
  # Revision: $Id: svg-animevents-attrib.mod,v 1.3 2002/04/28 13:50:23 fujisawa Exp $
  # 
  # This DTD module is identified by the PUBLIC and SYSTEM identifiers:
  # 
  #    PUBLIC "-//W3C//ENTITIES SVG 1.1 Animation Events Attribute//EN"
  #    SYSTEM "http://www.w3.org/Graphics/SVG/1.1/DTD/svg-animevents-attrib.mod"
  # 
  # .......................................................................
  
  # Animation Events Attribute
  # 
  #    onbegin, onend, onrepeat, onload
  # 
  # This module defines the AnimationEvents attribute set.
  SVG.onbegin.attrib = attribute onbegin { Script.datatype }?
  SVG.onend.attrib = attribute onend { Script.datatype }?
  SVG.onrepeat.attrib = attribute onrepeat { Script.datatype }?
  SVG.AnimationEvents.extra.attrib = empty
  SVG.AnimationEvents.attrib =
    SVG.onbegin.attrib,
    SVG.onend.attrib,
    SVG.onrepeat.attrib,
    SVG.onload.attrib,
    SVG.AnimationEvents.extra.attrib
  # end of svg-animevents-attrib.mod
  
  # XLink Attribute Module ......................................
  
  # .......................................................................
  
  # SVG 1.1 XLink Attribute Module ........................................
  
  # file: svg-xlink-attrib.mod
  # 
  # This is SVG, a language for describing two-dimensional graphics in XML.
  # Copyright 2001, 2002 W3C (MIT, INRIA, Keio), All Rights Reserved.
  # Revision: $Id: svg-xlink-attrib.mod,v 1.2 2002/04/20 18:07:43 fujisawa Exp $
  # 
  # This DTD module is identified by the PUBLIC and SYSTEM identifiers:
  # 
  #    PUBLIC "-//W3C//ENTITIES SVG 1.1 XLink Attribute//EN"
  #    SYSTEM "http://www.w3.org/Graphics/SVG/1.1/DTD/svg-xlink-attrib.mod"
  # 
  # .......................................................................
  
  # XLink Attribute
  # 
  #   type, href, role, arcrole, title, show, actuate
  # 
  # This module defines the XLink, XLinkRequired, XLinkEmbed, and
  # XLinkReplace attribute set.
  SVG.XLink.extra.attrib = empty
  SVG.XLink.attrib =
    XLINK.xmlns.attrib,
    [ a:defaultValue = "simple" ] attribute xlink:type { "simple" }?,
    attribute xlink:href { URI.datatype }?,
    attribute xlink:role { URI.datatype }?,
    attribute xlink:arcrole { URI.datatype }?,
    attribute xlink:title { text }?,
    [ a:defaultValue = "other" ] attribute xlink:show { "other" }?,
    [ a:defaultValue = "onLoad" ] attribute xlink:actuate { "onLoad" }?,
    SVG.XLink.extra.attrib
  SVG.XLinkRequired.extra.attrib = empty
  SVG.XLinkRequired.attrib =
    XLINK.xmlns.attrib,
    [ a:defaultValue = "simple" ] attribute xlink:type { "simple" }?,
    attribute xlink:href { URI.datatype },
    attribute xlink:role { URI.datatype }?,
    attribute xlink:arcrole { URI.datatype }?,
    attribute xlink:title { text }?,
    [ a:defaultValue = "other" ] attribute xlink:show { "other" }?,
    [ a:defaultValue = "onLoad" ] attribute xlink:actuate { "onLoad" }?,
    SVG.XLinkRequired.extra.attrib
  SVG.XLinkEmbed.extra.attrib = empty
  SVG.XLinkEmbed.attrib =
    XLINK.xmlns.attrib,
    [ a:defaultValue = "simple" ] attribute xlink:type { "simple" }?,
    attribute xlink:href { URI.datatype },
    attribute xlink:role { URI.datatype }?,
    attribute xlink:arcrole { URI.datatype }?,
    attribute xlink:title { text }?,
    [ a:defaultValue = "embed" ] attribute xlink:show { "embed" }?,
    [ a:defaultValue = "onLoad" ] attribute xlink:actuate { "onLoad" }?,
    SVG.XLinkEmbed.extra.attrib
  SVG.XLinkReplace.extra.attrib = empty
  SVG.XLinkReplace.attrib =
    XLINK.xmlns.attrib,
    [ a:defaultValue = "simple" ] attribute xlink:type { "simple" }?,
    attribute xlink:href { URI.datatype },
    attribute xlink:role { URI.datatype }?,
    attribute xlink:arcrole { URI.datatype }?,
    attribute xlink:title { text }?,
    [ a:defaultValue = "replace" ]
    attribute xlink:show { "new" | "replace" }?,
    [ a:defaultValue = "onRequest" ]
    attribute xlink:actuate { "onRequest" }?,
    SVG.XLinkReplace.extra.attrib
  # end of svg-xlink-attrib.mod
  
  # External Resources Attribute Module .........................
  
  # .......................................................................
  
  # SVG 1.1 External Resources Attribute Module ...........................
  
  # file: svg-extresources-attrib.mod
  # 
  # This is SVG, a language for describing two-dimensional graphics in XML.
  # Copyright 2001, 2002 W3C (MIT, INRIA, Keio), All Rights Reserved.
  # Revision: $Id: svg-extresources-attrib.mod,v 1.2 2002/04/20 18:07:42 fujisawa Exp $
  # 
  # This DTD module is identified by the PUBLIC and SYSTEM identifiers:
  # 
  #    PUBLIC "-//W3C//ENTITIES SVG 1.1 External Resources Attribute//EN"
  #    SYSTEM "http://www.w3.org/Graphics/SVG/1.1/DTD/svg-extresources-attrib.mod"
  # 
  # .......................................................................
  
  # External Resources Attribute
  # 
  #    externalResourcesRequired
  # 
  # This module defines the External attribute set.
  SVG.externalResourcesRequired.attrib =
    attribute externalResourcesRequired { Boolean.datatype }?
  SVG.External.extra.attrib = empty
  SVG.External.attrib =
    SVG.externalResourcesRequired.attrib, SVG.External.extra.attrib
  # end of svg-extresources-attrib.mod
  
  # :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
  
  # Structure Module ............................................
  
  # .......................................................................
  
  # SVG 1.1 Structure Module ..............................................
  
  # file: svg-structure.mod
  # 
  # This is SVG, a language for describing two-dimensional graphics in XML.
  # Copyright 2001, 2002 W3C (MIT, INRIA, Keio), All Rights Reserved.
  # Revision: $Id: svg-structure.mod,v 1.5 2002/11/14 15:11:03 fujisawa Exp $
  # 
  # This DTD module is identified by the PUBLIC and SYSTEM identifiers:
  # 
  #    PUBLIC "-//W3C//ELEMENTS SVG 1.1 Structure//EN"
  #    SYSTEM "http://www.w3.org/Graphics/SVG/1.1/DTD/svg-structure.mod"
  # 
  # .......................................................................
  
  # Structure
  # 
  #    svg, g, defs, desc, title, metadata, symbol, use
  # 
  # This module declares the major structural elements and their attributes.
  
  # Qualified Names (Default) .........................
  
  # Attribute Collections (Default) ...................
  
  # SVG.Description.class .............................
  
  # SVG.Use.class .....................................
  
  # SVG.Structure.class ...............................
  
  # SVG.Presentation.attrib ...........................
  SVG.Presentation.extra.attrib = empty
  SVG.Presentation.attrib =
    SVG.Container.attrib,
    SVG.Viewport.attrib,
    SVG.Text.attrib,
    SVG.TextContent.attrib,
    SVG.Font.attrib,
    SVG.Paint.attrib,
    SVG.Color.attrib,
    SVG.Opacity.attrib,
    SVG.Graphics.attrib,
    SVG.Marker.attrib,
    SVG.ColorProfile.attrib,
    SVG.Gradient.attrib,
    SVG.Clip.attrib,
    SVG.Mask.attrib,
    SVG.Filter.attrib,
    SVG.FilterColor.attrib,
    SVG.Cursor.attrib,
    attribute flood-color { SVGColor.datatype }?,
    attribute flood-opacity { OpacityValue.datatype }?,
    attribute lighting-color { SVGColor.datatype }?,
    SVG.Presentation.extra.attrib
  # svg: SVG Document Element .........................
  SVG.svg.extra.content = notAllowed
  SVG.svg.content =
    (SVG.Description.class
     | SVG.Animation.class
     | SVG.Structure.class
     | SVG.Conditional.class
     | SVG.Image.class
     | SVG.Style.class
     | SVG.Shape.class
     | SVG.Text.class
     | SVG.Marker.class
     | SVG.ColorProfile.class
     | SVG.Gradient.class
     | SVG.Pattern.class
     | SVG.Clip.class
     | SVG.Mask.class
     | SVG.Filter.class
     | SVG.Cursor.class
     | SVG.Hyperlink.class
     | SVG.View.class
     | SVG.Script.class
     | SVG.Font.class
     | SVG.svg.extra.content)*
  svg = element ns1:svg { attlist.svg, SVG.svg.content }
  # end of SVG.svg.element
  attlist.svg &=
    SVG.xmlns.attrib,
    SVG.Core.attrib,
    SVG.Conditional.attrib,
    SVG.Style.attrib,
    SVG.Presentation.attrib,
    SVG.DocumentEvents.attrib,
    SVG.GraphicalEvents.attrib,
    SVG.External.attrib,
    attribute x { Coordinate.datatype }?,
    attribute y { Coordinate.datatype }?,
    attribute width { Length.datatype }?,
    attribute height { Length.datatype }?,
    attribute viewBox { ViewBoxSpec.datatype }?,
    [ a:defaultValue = "xMidYMid meet" ]
    attribute preserveAspectRatio { PreserveAspectRatioSpec.datatype }?,
    [ a:defaultValue = "magnify" ]
    attribute zoomAndPan { "disable" | "magnify" }?,
    [ a:defaultValue = "1.1" ] attribute version { string "1.1" }?,
    attribute baseProfile { Text.datatype }?,
    [ a:defaultValue = "text/ecmascript" ]
    attribute contentScriptType { ContentType.datatype }?,
    [ a:defaultValue = "text/css" ]
    attribute contentStyleType { ContentType.datatype }?
  # end of SVG.svg.attlist
  
  # g: Group Element ..................................
  SVG.g.extra.content = notAllowed
  SVG.g.content =
    (SVG.Description.class
     | SVG.Animation.class
     | SVG.Structure.class
     | SVG.Conditional.class
     | SVG.Image.class
     | SVG.Style.class
     | SVG.Shape.class
     | SVG.Text.class
     | SVG.Marker.class
     | SVG.ColorProfile.class
     | SVG.Gradient.class
     | SVG.Pattern.class
     | SVG.Clip.class
     | SVG.Mask.class
     | SVG.Filter.class
     | SVG.Cursor.class
     | SVG.Hyperlink.class
     | SVG.View.class
     | SVG.Script.class
     | SVG.Font.class
     | SVG.g.extra.content)*
  g = element ns1:g { attlist.g, SVG.g.content }
  # end of SVG.g.element
  attlist.g &=
    SVG.Core.attrib,
    SVG.Conditional.attrib,
    SVG.Style.attrib,
    SVG.Presentation.attrib,
    SVG.GraphicalEvents.attrib,
    SVG.External.attrib,
    attribute transform { TransformList.datatype }?
  # end of SVG.g.attlist
  
  # defs: Definisions Element .........................
  SVG.defs.extra.content = notAllowed
  SVG.defs.content =
    (SVG.Description.class
     | SVG.Animation.class
     | SVG.Structure.class
     | SVG.Conditional.class
     | SVG.Image.class
     | SVG.Style.class
     | SVG.Shape.class
     | SVG.Text.class
     | SVG.Marker.class
     | SVG.ColorProfile.class
     | SVG.Gradient.class
     | SVG.Pattern.class
     | SVG.Clip.class
     | SVG.Mask.class
     | SVG.Filter.class
     | SVG.Cursor.class
     | SVG.Hyperlink.class
     | SVG.View.class
     | SVG.Script.class
     | SVG.Font.class
     | SVG.defs.extra.content)*
  defs = element ns1:defs { attlist.defs, SVG.defs.content }
  # end of SVG.defs.element
  attlist.defs &=
    SVG.Core.attrib,
    SVG.Conditional.attrib,
    SVG.Style.attrib,
    SVG.Presentation.attrib,
    SVG.GraphicalEvents.attrib,
    SVG.External.attrib,
    attribute transform { TransformList.datatype }?
  # end of SVG.defs.attlist
  
  # desc: Description Element .........................
  SVG.desc.extra.content = notAllowed
  SVG.desc.content = (text | SVG.desc.extra.content)*
  desc = element ns1:desc { attlist.desc, SVG.desc.content }
  # end of SVG.desc.element
  attlist.desc &= SVG.Core.attrib, SVG.Style.attrib
  # end of SVG.desc.attlist
  
  # title: Title Element ..............................
  SVG.title.extra.content = notAllowed
  SVG.title.content = (text | SVG.title.extra.content)*
  title = element ns1:title { attlist.title, SVG.title.content }
  # end of SVG.title.element
  attlist.title &= SVG.Core.attrib, SVG.Style.attrib
  # end of SVG.title.attlist
  
  # metadata: Metadata Element ........................
  SVG.metadata.extra.content = notAllowed
  SVG.metadata.content = (text | SVG.metadata.extra.content)*
  metadata =
    element ns1:metadata { attlist.metadata, SVG.metadata.content }
  # end of SVG.metadata.element
  attlist.metadata &= SVG.Core.attrib
  # end of SVG.metadata.attlist
  
  # symbol: Symbol Element ............................
  SVG.symbol.extra.content = notAllowed
  SVG.symbol.content =
    (SVG.Description.class
     | SVG.Animation.class
     | SVG.Structure.class
     | SVG.Conditional.class
     | SVG.Image.class
     | SVG.Style.class
     | SVG.Shape.class
     | SVG.Text.class
     | SVG.Marker.class
     | SVG.ColorProfile.class
     | SVG.Gradient.class
     | SVG.Pattern.class
     | SVG.Clip.class
     | SVG.Mask.class
     | SVG.Filter.class
     | SVG.Cursor.class
     | SVG.Hyperlink.class
     | SVG.View.class
     | SVG.Script.class
     | SVG.Font.class
     | SVG.symbol.extra.content)*
  symbol = element ns1:symbol { attlist.symbol, SVG.symbol.content }
  # end of SVG.symbol.element
  attlist.symbol &=
    SVG.Core.attrib,
    SVG.Style.attrib,
    SVG.Presentation.attrib,
    SVG.GraphicalEvents.attrib,
    SVG.External.attrib,
    attribute viewBox { ViewBoxSpec.datatype }?,
    [ a:defaultValue = "xMidYMid meet" ]
    attribute preserveAspectRatio { PreserveAspectRatioSpec.datatype }?
  # end of SVG.symbol.attlist
  
  # use: Use Element ..................................
  SVG.use.extra.content = notAllowed
  SVG.use.content =
    SVG.Description.class*,
    (SVG.Animation.class | SVG.use.extra.content)*
  use = element ns1:use { attlist.use, SVG.use.content }
  # end of SVG.use.element
  attlist.use &=
    SVG.Core.attrib,
    SVG.Conditional.attrib,
    SVG.Style.attrib,
    SVG.Presentation.attrib,
    SVG.GraphicalEvents.attrib,
    SVG.XLinkEmbed.attrib,
    SVG.External.attrib,
    attribute x { Coordinate.datatype }?,
    attribute y { Coordinate.datatype }?,
    attribute width { Length.datatype }?,
    attribute height { Length.datatype }?,
    attribute transform { TransformList.datatype }?
  # end of SVG.use.attlist
  
  # end of svg-structure.mod
  
  # Conditional Processing Module ...............................
  
  # .......................................................................
  
  # SVG 1.1 Conditional Processing Module .................................
  
  # file: svg-conditional.mod
  # 
  # This is SVG, a language for describing two-dimensional graphics in XML.
  # Copyright 2001, 2002 W3C (MIT, INRIA, Keio), All Rights Reserved.
  # Revision: $Id: svg-conditional.mod,v 1.4 2002/11/14 15:11:02 fujisawa Exp $
  # 
  # This DTD module is identified by the PUBLIC and SYSTEM identifiers:
  # 
  #    PUBLIC "-//W3C//ELEMENTS SVG 1.1 Conditional Processing//EN"
  #    SYSTEM "http://www.w3.org/Graphics/SVG/1.1/DTD/svg-conditional.mod"
  # 
  # .......................................................................
  
  # Conditional Processing
  # 
  #    switch
  # 
  # This module declares markup to provide support for conditional processing.
  
  # extension list specification
  
  # feature list specification
  
  # Qualified Names (Default) .........................
  
  # Attribute Collections (Default) ...................
  
  # SVG.Conditional.class .............................
  
  # SVG.Conditional.attrib ............................
  
  # SVG.Presentation.attrib ...........................
  
  # switch: Switch Element ............................
  SVG.switch.extra.content = notAllowed
  SVG.switch.content =
    SVG.Description.class*,
    (svg
     | g
     | use
     | \text
     | SVG.Animation.class
     | SVG.Conditional.class
     | SVG.Image.class
     | SVG.Shape.class
     | SVG.Hyperlink.class
     | SVG.Extensibility.class
     | SVG.switch.extra.content)*
  switch = element ns1:switch { attlist.switch, SVG.switch.content }
  # end of SVG.switch.element
  attlist.switch &=
    SVG.Core.attrib,
    SVG.Conditional.attrib,
    SVG.Style.attrib,
    SVG.Presentation.attrib,
    SVG.GraphicalEvents.attrib,
    SVG.External.attrib,
    attribute transform { TransformList.datatype }?
  # end of SVG.switch.attlist
  
  # end of svg-conditional.mod
  
  # Image Module ................................................
  
  # .......................................................................
  
  # SVG 1.1 Image Module ..................................................
  
  # file: svg-image.mod
  # 
  # This is SVG, a language for describing two-dimensional graphics in XML.
  # Copyright 2001, 2002 W3C (MIT, INRIA, Keio), All Rights Reserved.
  # Revision: $Id: svg-image.mod,v 1.4 2002/11/14 15:11:03 fujisawa Exp $
  # 
  # This DTD module is identified by the PUBLIC and SYSTEM identifiers:
  # 
  #    PUBLIC "-//W3C//ELEMENTS SVG 1.1 Image//EN"
  #    SYSTEM "http://www.w3.org/Graphics/SVG/1.1/DTD/svg-image.mod"
  # 
  # .......................................................................
  
  # Image
  # 
  #    image
  # 
  # This module declares markup to provide support for image.
  
  # Qualified Names (Default) .........................
  
  # Attribute Collections (Default) ...................
  
  # SVG.Image.class ...................................
  
  # image: Image Element ..............................
  SVG.image.extra.content = notAllowed
  SVG.image.content =
    SVG.Description.class*,
    (SVG.Animation.class | SVG.image.extra.content)*
  image = element ns1:image { attlist.image, SVG.image.content }
  # end of SVG.image.element
  attlist.image &=
    SVG.Core.attrib,
    SVG.Conditional.attrib,
    SVG.Style.attrib,
    SVG.Viewport.attrib,
    SVG.Color.attrib,
    SVG.Opacity.attrib,
    SVG.Graphics.attrib,
    SVG.ColorProfile.attrib,
    SVG.Clip.attrib,
    SVG.Mask.attrib,
    SVG.Filter.attrib,
    SVG.GraphicalEvents.attrib,
    SVG.Cursor.attrib,
    SVG.XLinkEmbed.attrib,
    SVG.External.attrib,
    attribute x { Coordinate.datatype }?,
    attribute y { Coordinate.datatype }?,
    attribute width { Length.datatype },
    attribute height { Length.datatype },
    [ a:defaultValue = "xMidYMid meet" ]
    attribute preserveAspectRatio { PreserveAspectRatioSpec.datatype }?,
    attribute transform { TransformList.datatype }?
  # end of SVG.image.attlist
  
  # end of svg-image.mod
  
  # Style Module ................................................
  
  # .......................................................................
  
  # SVG 1.1 Style Module ..................................................
  
  # file: svg-style.mod
  # 
  # This is SVG, a language for describing two-dimensional graphics in XML.
  # Copyright 2001, 2002 W3C (MIT, INRIA, Keio), All Rights Reserved.
  # Revision: $Id: svg-style.mod,v 1.3 2002/10/24 17:40:16 fujisawa Exp $
  # 
  # This DTD module is identified by the PUBLIC and SYSTEM identifiers:
  # 
  #    PUBLIC "-//W3C//ELEMENTS SVG 1.1 Style//EN"
  #    SYSTEM "http://www.w3.org/Graphics/SVG/1.1/DTD/svg-style.mod"
  # 
  # .......................................................................
  
  # Style
  # 
  #    style
  # 
  # This module declares markup to provide support for stylesheet.
  
  # list of classes
  
  # comma-separated list of media descriptors.
  MediaDesc.datatype = string
  # style sheet data
  
  # Qualified Names (Default) .........................
  
  # Attribute Collections (Default) ...................
  
  # SVG.Style.class ...................................
  
  # SVG.Style.attrib ..................................
  
  # style: Style Element ..............................
  SVG.style.extra.content = notAllowed
  SVG.style.content = (text | SVG.style.extra.content)*
  style = element ns1:style { attlist.style, SVG.style.content }
  # end of SVG.style.element
  attlist.style &=
    [ a:defaultValue = "preserve" ] attribute xml:space { "preserve" }?,
    SVG.id.attrib,
    SVG.base.attrib,
    SVG.lang.attrib,
    SVG.Core.extra.attrib,
    attribute type { ContentType.datatype },
    attribute media { MediaDesc.datatype }?,
    attribute title { Text.datatype }?
  # end of SVG.style.attlist
  
  # end of svg-style.mod
  
  # Shape Module ................................................
  
  # .......................................................................
  
  # SVG 1.1 Shape Module ..................................................
  
  # file: svg-shape.mod
  # 
  # This is SVG, a language for describing two-dimensional graphics in XML.
  # Copyright 2001, 2002 W3C (MIT, INRIA, Keio), All Rights Reserved.
  # Revision: $Id: svg-shape.mod,v 1.3 2002/10/24 17:40:16 fujisawa Exp $
  # 
  # This DTD module is identified by the PUBLIC and SYSTEM identifiers:
  # 
  #    PUBLIC "-//W3C//ELEMENTS SVG 1.1 Shape//EN"
  #    SYSTEM "http://www.w3.org/Graphics/SVG/1.1/DTD/svg-shape.mod"
  # 
  # .......................................................................
  
  # Shape
  # 
  #    path, rect, circle, line, ellipse, polyline, polygon
  # 
  # This module declares markup to provide support for graphical shapes.
  
  # a list of points
  Points.datatype = string
  # Qualified Names (Default) .........................
  
  # Attribute Collections (Default) ...................
  
  # SVG.Shape.class ...................................
  
  # path: Path Element ................................
  SVG.path.extra.content = notAllowed
  SVG.path.content =
    SVG.Description.class*,
    (SVG.Animation.class | SVG.path.extra.content)*
  path = element ns1:path { attlist.path, SVG.path.content }
  # end of SVG.path.element
  attlist.path &=
    SVG.Core.attrib,
    SVG.Conditional.attrib,
    SVG.Style.attrib,
    SVG.Paint.attrib,
    SVG.Color.attrib,
    SVG.Opacity.attrib,
    SVG.Graphics.attrib,
    SVG.Marker.attrib,
    SVG.Clip.attrib,
    SVG.Mask.attrib,
    SVG.Filter.attrib,
    SVG.GraphicalEvents.attrib,
    SVG.Cursor.attrib,
    SVG.External.attrib,
    attribute d { PathData.datatype },
    attribute pathLength { Number.datatype }?,
    attribute transform { TransformList.datatype }?
  # end of SVG.path.attlist
  
  # rect: Rectangle Element ...........................
  SVG.rect.extra.content = notAllowed
  SVG.rect.content =
    SVG.Description.class*,
    (SVG.Animation.class | SVG.rect.extra.content)*
  rect = element ns1:rect { attlist.rect, SVG.rect.content }
  # end of SVG.rect.element
  attlist.rect &=
    SVG.Core.attrib,
    SVG.Conditional.attrib,
    SVG.Style.attrib,
    SVG.Paint.attrib,
    SVG.Color.attrib,
    SVG.Opacity.attrib,
    SVG.Graphics.attrib,
    SVG.Clip.attrib,
    SVG.Mask.attrib,
    SVG.Filter.attrib,
    SVG.GraphicalEvents.attrib,
    SVG.Cursor.attrib,
    SVG.External.attrib,
    attribute x { Coordinate.datatype }?,
    attribute y { Coordinate.datatype }?,
    attribute width { Length.datatype },
    attribute height { Length.datatype },
    attribute rx { Length.datatype }?,
    attribute ry { Length.datatype }?,
    attribute transform { TransformList.datatype }?
  # end of SVG.rect.attlist
  
  # circle: Circle Element ............................
  SVG.circle.extra.content = notAllowed
  SVG.circle.content =
    SVG.Description.class*,
    (SVG.Animation.class | SVG.circle.extra.content)*
  circle = element ns1:circle { attlist.circle, SVG.circle.content }
  # end of SVG.circle.element
  attlist.circle &=
    SVG.Core.attrib,
    SVG.Conditional.attrib,
    SVG.Style.attrib,
    SVG.Paint.attrib,
    SVG.Color.attrib,
    SVG.Opacity.attrib,
    SVG.Graphics.attrib,
    SVG.Clip.attrib,
    SVG.Mask.attrib,
    SVG.Filter.attrib,
    SVG.GraphicalEvents.attrib,
    SVG.Cursor.attrib,
    SVG.External.attrib,
    attribute cx { Coordinate.datatype }?,
    attribute cy { Coordinate.datatype }?,
    attribute r { Length.datatype },
    attribute transform { TransformList.datatype }?
  # end of SVG.circle.attlist
  
  # line: Line Element ................................
  SVG.line.extra.content = notAllowed
  SVG.line.content =
    SVG.Description.class*,
    (SVG.Animation.class | SVG.line.extra.content)*
  line = element ns1:line { attlist.line, SVG.line.content }
  # end of SVG.line.element
  attlist.line &=
    SVG.Core.attrib,
    SVG.Conditional.attrib,
    SVG.Style.attrib,
    SVG.Paint.attrib,
    SVG.Color.attrib,
    SVG.Opacity.attrib,
    SVG.Graphics.attrib,
    SVG.Marker.attrib,
    SVG.Clip.attrib,
    SVG.Mask.attrib,
    SVG.Filter.attrib,
    SVG.GraphicalEvents.attrib,
    SVG.Cursor.attrib,
    SVG.External.attrib,
    attribute x1 { Coordinate.datatype }?,
    attribute y1 { Coordinate.datatype }?,
    attribute x2 { Coordinate.datatype }?,
    attribute y2 { Coordinate.datatype }?,
    attribute transform { TransformList.datatype }?
  # end of SVG.line.attlist
  
  # ellipse: Ellipse Element ..........................
  SVG.ellipse.extra.content = notAllowed
  SVG.ellipse.content =
    SVG.Description.class*,
    (SVG.Animation.class | SVG.ellipse.extra.content)*
  ellipse = element ns1:ellipse { attlist.ellipse, SVG.ellipse.content }
  # end of SVG.ellipse.element
  attlist.ellipse &=
    SVG.Core.attrib,
    SVG.Conditional.attrib,
    SVG.Style.attrib,
    SVG.Paint.attrib,
    SVG.Color.attrib,
    SVG.Opacity.attrib,
    SVG.Graphics.attrib,
    SVG.Clip.attrib,
    SVG.Mask.attrib,
    SVG.Filter.attrib,
    SVG.GraphicalEvents.attrib,
    SVG.Cursor.attrib,
    SVG.External.attrib,
    attribute cx { Coordinate.datatype }?,
    attribute cy { Coordinate.datatype }?,
    attribute rx { Length.datatype },
    attribute ry { Length.datatype },
    attribute transform { TransformList.datatype }?
  # end of SVG.ellipse.attlist
  
  # polyline: Polyline Element ........................
  SVG.polyline.extra.content = notAllowed
  SVG.polyline.content =
    SVG.Description.class*,
    (SVG.Animation.class | SVG.polyline.extra.content)*
  polyline =
    element ns1:polyline { attlist.polyline, SVG.polyline.content }
  # end of SVG.polyline.element
  attlist.polyline &=
    SVG.Core.attrib,
    SVG.Conditional.attrib,
    SVG.Style.attrib,
    SVG.Paint.attrib,
    SVG.Color.attrib,
    SVG.Opacity.attrib,
    SVG.Graphics.attrib,
    SVG.Marker.attrib,
    SVG.Clip.attrib,
    SVG.Mask.attrib,
    SVG.Filter.attrib,
    SVG.GraphicalEvents.attrib,
    SVG.Cursor.attrib,
    SVG.External.attrib,
    attribute points { Points.datatype },
    attribute transform { TransformList.datatype }?
  # end of SVG.polyline.attlist
  
  # polygon: Polygon Element ..........................
  SVG.polygon.extra.content = notAllowed
  SVG.polygon.content =
    SVG.Description.class*,
    (SVG.Animation.class | SVG.polygon.extra.content)*
  polygon = element ns1:polygon { attlist.polygon, SVG.polygon.content }
  # end of SVG.polygon.element
  attlist.polygon &=
    SVG.Core.attrib,
    SVG.Conditional.attrib,
    SVG.Style.attrib,
    SVG.Paint.attrib,
    SVG.Color.attrib,
    SVG.Opacity.attrib,
    SVG.Graphics.attrib,
    SVG.Marker.attrib,
    SVG.Clip.attrib,
    SVG.Mask.attrib,
    SVG.Filter.attrib,
    SVG.GraphicalEvents.attrib,
    SVG.Cursor.attrib,
    SVG.External.attrib,
    attribute points { Points.datatype },
    attribute transform { TransformList.datatype }?
  # end of SVG.polygon.attlist
  
  # end of svg-shape.mod
  
  # Text Module .................................................
  
  # .......................................................................
  
  # SVG 1.1 Text Module ...................................................
  
  # file: svg-text.mod
  # 
  # This is SVG, a language for describing two-dimensional graphics in XML.
  # Copyright 2001, 2002 W3C (MIT, INRIA, Keio), All Rights Reserved.
  # Revision: $Id: svg-text.mod,v 1.4 2002/10/24 17:40:16 fujisawa Exp $
  # 
  # This DTD module is identified by the PUBLIC and SYSTEM identifiers:
  # 
  #    PUBLIC "-//W3C//ELEMENTS SVG 1.1 Text//EN"
  #    SYSTEM "http://www.w3.org/Graphics/SVG/1.1/DTD/svg-text.mod"
  # 
  # .......................................................................
  
  # Text
  # 
  #    text, tspan, tref, textPath, altGlyph, altGlyphDef, altGlyphItem,
  #    glyphRef
  # 
  # This module declares markup to provide support for alternate glyph.
  
  # 'baseline-shift' property/attribute value (e.g., 'baseline', 'sub', etc.)
  
  # 'font-family' property/attribute value (i.e., list of fonts)
  
  # 'font-size' property/attribute value
  
  # 'font-size-adjust' property/attribute value
  
  # 'glyph-orientation-horizontal' property/attribute value (e.g., <angle>)
  
  # 'glyph-orientation-vertical' property/attribute value (e.g., 'auto', <angle>)
  
  # 'kerning' property/attribute value (e.g., 'auto', <length>)
  
  # 'letter-spacing' or 'word-spacing' property/attribute value (e.g., 'normal', <length>)
  
  # 'text-decoration' property/attribute value (e.g., 'none', 'underline')
  
  # Qualified Names (Default) .........................
  
  # Attribute Collections (Default) ...................
  
  # SVG.Text.class ....................................
  
  # SVG.TextContent.class .............................
  
  # SVG.Text.attrib ...................................
  
  # SVG.TextContent.attrib ............................
  
  # SVG.Font.attrib ...................................
  
  # text: Text Element ................................
  SVG.text.extra.content = notAllowed
  SVG.text.content =
    (text
     | SVG.Description.class
     | SVG.Animation.class
     | SVG.TextContent.class
     | SVG.Hyperlink.class
     | SVG.text.extra.content)*
  \text = element ns1:text { attlist.text, SVG.text.content }
  # end of SVG.text.element
  attlist.text &=
    SVG.Core.attrib,
    SVG.Conditional.attrib,
    SVG.Style.attrib,
    SVG.Text.attrib,
    SVG.TextContent.attrib,
    SVG.Font.attrib,
    SVG.Paint.attrib,
    SVG.Color.attrib,
    SVG.Opacity.attrib,
    SVG.Graphics.attrib,
    SVG.Clip.attrib,
    SVG.Mask.attrib,
    SVG.Filter.attrib,
    SVG.GraphicalEvents.attrib,
    SVG.Cursor.attrib,
    SVG.External.attrib,
    attribute x { Coordinates.datatype }?,
    attribute y { Coordinates.datatype }?,
    attribute dx { Lengths.datatype }?,
    attribute dy { Lengths.datatype }?,
    attribute rotate { Numbers.datatype }?,
    attribute textLength { Length.datatype }?,
    attribute lengthAdjust { "spacing" | "spacingAndGlyphs" }?,
    attribute transform { TransformList.datatype }?
  # end of SVG.text.attlist
  
  # tspan: Text Span Element ..........................
  SVG.tspan.extra.content = notAllowed
  SVG.tspan.content =
    (text
     | tspan
     | tref
     | altGlyph
     | animate
     | set
     | animateColor
     | SVG.Description.class
     | SVG.Hyperlink.class
     | SVG.tspan.extra.content)*
  tspan = element ns1:tspan { attlist.tspan, SVG.tspan.content }
  # end of SVG.tspan.element
  attlist.tspan &=
    SVG.Core.attrib,
    SVG.Conditional.attrib,
    SVG.Style.attrib,
    SVG.TextContent.attrib,
    SVG.Font.attrib,
    SVG.Paint.attrib,
    SVG.Color.attrib,
    SVG.Opacity.attrib,
    SVG.Graphics.attrib,
    SVG.Clip.attrib,
    SVG.Mask.attrib,
    SVG.Filter.attrib,
    SVG.GraphicalEvents.attrib,
    SVG.Cursor.attrib,
    SVG.External.attrib,
    attribute x { Coordinates.datatype }?,
    attribute y { Coordinates.datatype }?,
    attribute dx { Lengths.datatype }?,
    attribute dy { Lengths.datatype }?,
    attribute rotate { Numbers.datatype }?,
    attribute textLength { Length.datatype }?,
    attribute lengthAdjust { "spacing" | "spacingAndGlyphs" }?
  # end of SVG.tspan.attlist
  
  # tref: Text Reference Element ......................
  SVG.tref.extra.content = notAllowed
  SVG.tref.content =
    (animate
     | set
     | animateColor
     | SVG.Description.class
     | SVG.tref.extra.content)*
  tref = element ns1:tref { attlist.tref, SVG.tref.content }
  # end of SVG.tref.element
  attlist.tref &=
    SVG.Core.attrib,
    SVG.Conditional.attrib,
    SVG.Style.attrib,
    SVG.TextContent.attrib,
    SVG.Font.attrib,
    SVG.Paint.attrib,
    SVG.Color.attrib,
    SVG.Opacity.attrib,
    SVG.Graphics.attrib,
    SVG.Clip.attrib,
    SVG.Mask.attrib,
    SVG.Filter.attrib,
    SVG.GraphicalEvents.attrib,
    SVG.Cursor.attrib,
    SVG.XLinkRequired.attrib,
    SVG.External.attrib,
    attribute x { Coordinates.datatype }?,
    attribute y { Coordinates.datatype }?,
    attribute dx { Lengths.datatype }?,
    attribute dy { Lengths.datatype }?,
    attribute rotate { Numbers.datatype }?,
    attribute textLength { Length.datatype }?,
    attribute lengthAdjust { "spacing" | "spacingAndGlyphs" }?
  # end of SVG.tref.attlist
  
  # textPath: Text Path Element .......................
  SVG.textPath.extra.content = notAllowed
  SVG.textPath.content =
    (text
     | tspan
     | tref
     | altGlyph
     | animate
     | set
     | animateColor
     | SVG.Description.class
     | SVG.Hyperlink.class
     | SVG.textPath.extra.content)*
  textPath =
    element ns1:textPath { attlist.textPath, SVG.textPath.content }
  # end of SVG.textPath.element
  attlist.textPath &=
    SVG.Core.attrib,
    SVG.Conditional.attrib,
    SVG.Style.attrib,
    SVG.TextContent.attrib,
    SVG.Font.attrib,
    SVG.Paint.attrib,
    SVG.Color.attrib,
    SVG.Opacity.attrib,
    SVG.Graphics.attrib,
    SVG.Clip.attrib,
    SVG.Mask.attrib,
    SVG.Filter.attrib,
    SVG.GraphicalEvents.attrib,
    SVG.Cursor.attrib,
    SVG.XLinkRequired.attrib,
    SVG.External.attrib,
    attribute startOffset { Length.datatype }?,
    attribute textLength { Length.datatype }?,
    attribute lengthAdjust { "spacing" | "spacingAndGlyphs" }?,
    attribute method { "align" | "stretch" }?,
    attribute spacing { "auto" | "exact" }?
  # end of SVG.textPath.attlist
  
  # altGlyph: Alternate Glyph Element .................
  SVG.altGlyph.extra.content = notAllowed
  SVG.altGlyph.content = (text | SVG.altGlyph.extra.content)*
  altGlyph =
    element ns1:altGlyph { attlist.altGlyph, SVG.altGlyph.content }
  # end of SVG.altGlyph.element
  attlist.altGlyph &=
    SVG.Core.attrib,
    SVG.Conditional.attrib,
    SVG.Style.attrib,
    SVG.TextContent.attrib,
    SVG.Font.attrib,
    SVG.Paint.attrib,
    SVG.Color.attrib,
    SVG.Opacity.attrib,
    SVG.Graphics.attrib,
    SVG.Clip.attrib,
    SVG.Mask.attrib,
    SVG.Filter.attrib,
    SVG.GraphicalEvents.attrib,
    SVG.Cursor.attrib,
    SVG.XLink.attrib,
    SVG.External.attrib,
    attribute x { Coordinates.datatype }?,
    attribute y { Coordinates.datatype }?,
    attribute dx { Lengths.datatype }?,
    attribute dy { Lengths.datatype }?,
    attribute glyphRef { text }?,
    attribute format { text }?,
    attribute rotate { Numbers.datatype }?
  # end of SVG.altGlyph.attlist
  
  # altGlyphDef: Alternate Glyph Definition Element ...
  SVG.altGlyphDef.extra.content = notAllowed
  SVG.altGlyphDef.content =
    (glyphRef+ | altGlyphItem+) | SVG.altGlyphDef.extra.content
  altGlyphDef =
    element ns1:altGlyphDef {
      attlist.altGlyphDef, SVG.altGlyphDef.content
    }
  # end of SVG.altGlyphDef.element
  attlist.altGlyphDef &= SVG.Core.attrib
  # end of SVG.altGlyphDef.attlist
  
  # altGlyphItem: Alternate Glyph Item Element ........
  SVG.altGlyphItem.extra.content = notAllowed
  SVG.altGlyphItem.content = glyphRef+ | SVG.altGlyphItem.extra.content
  altGlyphItem =
    element ns1:altGlyphItem {
      attlist.altGlyphItem, SVG.altGlyphItem.content
    }
  # end of SVG.altGlyphItem.element
  attlist.altGlyphItem &= SVG.Core.attrib
  # end of SVG.altGlyphItem.attlist
  
  # glyphRef: Glyph Reference Element .................
  SVG.glyphRef.content = empty
  glyphRef =
    element ns1:glyphRef { attlist.glyphRef, SVG.glyphRef.content }
  # end of SVG.glyphRef.element
  attlist.glyphRef &=
    SVG.Core.attrib,
    SVG.Style.attrib,
    SVG.Font.attrib,
    SVG.XLink.attrib,
    attribute x { Number.datatype }?,
    attribute y { Number.datatype }?,
    attribute dx { Number.datatype }?,
    attribute dy { Number.datatype }?,
    attribute glyphRef { text }?,
    attribute format { text }?
  # end of SVG.glyphRef.attlist
  
  # end of svg-text.mod
  
  # Marker Module ...............................................
  
  # .......................................................................
  
  # SVG 1.1 Marker Module .................................................
  
  # file: svg-marker.mod
  # 
  # This is SVG, a language for describing two-dimensional graphics in XML.
  # Copyright 2001, 2002 W3C (MIT, INRIA, Keio), All Rights Reserved.
  # Revision: $Id: svg-marker.mod,v 1.4 2002/11/14 15:11:03 fujisawa Exp $
  # 
  # This DTD module is identified by the PUBLIC and SYSTEM identifiers:
  # 
  #    PUBLIC "-//W3C//ELEMENTS SVG 1.1 Marker//EN"
  #    SYSTEM "http://www.w3.org/Graphics/SVG/1.1/DTD/svg-marker.mod"
  # 
  # .......................................................................
  
  # Marker
  # 
  #    marker
  # 
  # This module declares markup to provide support for marker.
  
  # 'marker' property/attribute value (e.g., 'none', <uri>)
  
  # Qualified Names (Default) .........................
  
  # Attribute Collections (Default) ...................
  
  # SVG.Marker.class ..................................
  
  # SVG.Marker.attrib .................................
  
  # SVG.Presentation.attrib ...........................
  
  # marker: Marker Element ............................
  SVG.marker.extra.content = notAllowed
  SVG.marker.content =
    (SVG.Description.class
     | SVG.Animation.class
     | SVG.Structure.class
     | SVG.Conditional.class
     | SVG.Image.class
     | SVG.Style.class
     | SVG.Shape.class
     | SVG.Text.class
     | SVG.Marker.class
     | SVG.ColorProfile.class
     | SVG.Gradient.class
     | SVG.Pattern.class
     | SVG.Clip.class
     | SVG.Mask.class
     | SVG.Filter.class
     | SVG.Cursor.class
     | SVG.Hyperlink.class
     | SVG.View.class
     | SVG.Script.class
     | SVG.Font.class
     | SVG.marker.extra.content)*
  marker = element ns1:marker { attlist.marker, SVG.marker.content }
  # end of SVG.marker.element
  attlist.marker &=
    SVG.Core.attrib,
    SVG.Style.attrib,
    SVG.Presentation.attrib,
    SVG.External.attrib,
    attribute refX { Coordinate.datatype }?,
    attribute refY { Coordinate.datatype }?,
    attribute markerUnits { "strokeWidth" | "userSpaceOnUse" }?,
    attribute markerWidth { Length.datatype }?,
    attribute markerHeight { Length.datatype }?,
    attribute orient { text }?,
    attribute viewBox { ViewBoxSpec.datatype }?,
    [ a:defaultValue = "xMidYMid meet" ]
    attribute preserveAspectRatio { PreserveAspectRatioSpec.datatype }?
  # end of SVG.marker.attlist
  
  # end of svg-marker.mod
  
  # Color Profile Module ........................................
  
  # .......................................................................
  
  # SVG 1.1 Color Profile Module ..........................................
  
  # file: svg-profile.mod
  # 
  # This is SVG, a language for describing two-dimensional graphics in XML.
  # Copyright 2001, 2002 W3C (MIT, INRIA, Keio), All Rights Reserved.
  # Revision: $Id: svg-profile.mod,v 1.3 2002/11/14 15:11:03 fujisawa Exp $
  # 
  # This DTD module is identified by the PUBLIC and SYSTEM identifiers:
  # 
  #    PUBLIC "-//W3C//ELEMENTS SVG 1.1 Color Profile//EN"
  #    SYSTEM "http://www.w3.org/Graphics/SVG/1.1/DTD/svg-profile.mod"
  # 
  # .......................................................................
  
  # Color Profile
  # 
  #    color-profile
  # 
  # This module declares markup to provide support for color profile.
  
  # Qualified Names (Default) .........................
  
  # Attribute Collections (Default) ...................
  
  # SVG.ColorProfile.class ............................
  
  # SVG.ColorProfile.attrib ...........................
  
  # color-profile: Color Profile Element ..............
  SVG.color-profile.extra.content = notAllowed
  SVG.color-profile.content =
    (SVG.Description.class | SVG.color-profile.extra.content)*
  color-profile =
    element ns1:color-profile {
      attlist.color-profile, SVG.color-profile.content
    }
  # end of SVG.color-profile.element
  attlist.color-profile &=
    SVG.Core.attrib,
    SVG.XLink.attrib,
    attribute local { text }?,
    attribute name { text },
    [ a:defaultValue = "auto" ]
    attribute rendering-intent {
      "auto"
      | "perceptual"
      | "relative-colorimetric"
      | "saturation"
      | "absolute-colorimetric"
    }?
  # end of SVG.color-profile.attlist
  
  # end of svg-profile.mod
  
  # Gradient Module .............................................
  
  # .......................................................................
  
  # SVG 1.1 Gradient Module ...............................................
  
  # file: svg-gradient.mod
  # 
  # This is SVG, a language for describing two-dimensional graphics in XML.
  # Copyright 2001, 2002 W3C (MIT, INRIA, Keio), All Rights Reserved.
  # Revision: $Id: svg-gradient.mod,v 1.3 2002/10/24 17:40:15 fujisawa Exp $
  # 
  # This DTD module is identified by the PUBLIC and SYSTEM identifiers:
  # 
  #    PUBLIC "-//W3C//ELEMENTS SVG 1.1 Gradient//EN"
  #    SYSTEM "http://www.w3.org/Graphics/SVG/1.1/DTD/svg-gradient.mod"
  # 
  # .......................................................................
  
  # Gradient
  # 
  #    linearGradient, radialGradient, stop
  # 
  # This module declares markup to provide support for gradient fill.
  
  # a <number> or a <percentage>
  
  # Qualified Names (Default) .........................
  
  # Attribute Collections (Default) ...................
  
  # SVG.Gradient.class ................................
  
  # SVG.Gradient.attrib ...............................
  
  # linearGradient: Linear Gradient Element ...........
  SVG.linearGradient.extra.content = notAllowed
  SVG.linearGradient.content =
    SVG.Description.class*,
    (stop
     | animate
     | set
     | animateTransform
     | SVG.linearGradient.extra.content)*
  linearGradient =
    element ns1:linearGradient {
      attlist.linearGradient, SVG.linearGradient.content
    }
  # end of SVG.linearGradient.element
  attlist.linearGradient &=
    SVG.Core.attrib,
    SVG.Style.attrib,
    SVG.Color.attrib,
    SVG.Gradient.attrib,
    SVG.XLink.attrib,
    SVG.External.attrib,
    attribute x1 { Coordinate.datatype }?,
    attribute y1 { Coordinate.datatype }?,
    attribute x2 { Coordinate.datatype }?,
    attribute y2 { Coordinate.datatype }?,
    attribute gradientUnits { "userSpaceOnUse" | "objectBoundingBox" }?,
    attribute gradientTransform { TransformList.datatype }?,
    attribute spreadMethod { "pad" | "reflect" | "repeat" }?
  # end of SVG.linearGradient.attlist
  
  # radialGradient: Radial Gradient Element ...........
  SVG.radialGradient.extra.content = notAllowed
  SVG.radialGradient.content =
    SVG.Description.class*,
    (stop
     | animate
     | set
     | animateTransform
     | SVG.radialGradient.extra.content)*
  radialGradient =
    element ns1:radialGradient {
      attlist.radialGradient, SVG.radialGradient.content
    }
  # end of SVG.radialGradient.element
  attlist.radialGradient &=
    SVG.Core.attrib,
    SVG.Style.attrib,
    SVG.Color.attrib,
    SVG.Gradient.attrib,
    SVG.XLink.attrib,
    SVG.External.attrib,
    attribute cx { Coordinate.datatype }?,
    attribute cy { Coordinate.datatype }?,
    attribute r { Length.datatype }?,
    attribute fx { Coordinate.datatype }?,
    attribute fy { Coordinate.datatype }?,
    attribute gradientUnits { "userSpaceOnUse" | "objectBoundingBox" }?,
    attribute gradientTransform { TransformList.datatype }?,
    attribute spreadMethod { "pad" | "reflect" | "repeat" }?
  # end of SVG.radialGradient.attlist
  
  # stop: Stop Element ................................
  SVG.stop.extra.content = notAllowed
  SVG.stop.content =
    (animate | set | animateColor | SVG.stop.extra.content)*
  stop = element ns1:stop { attlist.stop, SVG.stop.content }
  # end of SVG.stop.element
  attlist.stop &=
    SVG.Core.attrib,
    SVG.Style.attrib,
    SVG.Color.attrib,
    SVG.Gradient.attrib,
    attribute offset { NumberOrPercentage.datatype }
  # end of SVG.stop.attlist
  
  # end of svg-gradient.mod
  
  # Pattern Module ..............................................
  
  # .......................................................................
  
  # SVG 1.1 Pattern Module ................................................
  
  # file: svg-pattern.mod
  # 
  # This is SVG, a language for describing two-dimensional graphics in XML.
  # Copyright 2001, 2002 W3C (MIT, INRIA, Keio), All Rights Reserved.
  # Revision: $Id: svg-pattern.mod,v 1.4 2002/11/14 15:11:03 fujisawa Exp $
  # 
  # This DTD module is identified by the PUBLIC and SYSTEM identifiers:
  # 
  #    PUBLIC "-//W3C//ELEMENTS SVG 1.1 Pattern//EN"
  #    SYSTEM "http://www.w3.org/Graphics/SVG/1.1/DTD/svg-pattern.mod"
  # 
  # .......................................................................
  
  # Pattern
  # 
  #    pattern
  # 
  # This module declares markup to provide support for pattern fill.
  
  # Qualified Names (Default) .........................
  
  # Attribute Collections (Default) ...................
  
  # SVG.Pattern.class .................................
  
  # SVG.Presentation.attrib ...........................
  
  # pattern: Pattern Element ..........................
  SVG.pattern.extra.content = notAllowed
  SVG.pattern.content =
    (SVG.Description.class
     | SVG.Animation.class
     | SVG.Structure.class
     | SVG.Conditional.class
     | SVG.Image.class
     | SVG.Style.class
     | SVG.Shape.class
     | SVG.Text.class
     | SVG.Marker.class
     | SVG.ColorProfile.class
     | SVG.Gradient.class
     | SVG.Pattern.class
     | SVG.Clip.class
     | SVG.Mask.class
     | SVG.Filter.class
     | SVG.Cursor.class
     | SVG.Hyperlink.class
     | SVG.View.class
     | SVG.Script.class
     | SVG.Font.class
     | SVG.pattern.extra.content)*
  svgpattern =
    element ns1:pattern { attlist.pattern, SVG.pattern.content }
  # end of SVG.pattern.element
  attlist.pattern &=
    SVG.Core.attrib,
    SVG.Conditional.attrib,
    SVG.Style.attrib,
    SVG.Presentation.attrib,
    SVG.XLink.attrib,
    SVG.External.attrib,
    attribute x { Coordinate.datatype }?,
    attribute y { Coordinate.datatype }?,
    attribute width { Length.datatype }?,
    attribute height { Length.datatype }?,
    attribute patternUnits { "userSpaceOnUse" | "objectBoundingBox" }?,
    attribute patternContentUnits {
      "userSpaceOnUse" | "objectBoundingBox"
    }?,
    attribute patternTransform { TransformList.datatype }?,
    attribute viewBox { ViewBoxSpec.datatype }?,
    [ a:defaultValue = "xMidYMid meet" ]
    attribute preserveAspectRatio { PreserveAspectRatioSpec.datatype }?
  # end of SVG.pattern.attlist
  
  # end of svg-pattern.mod
  
  # Clip Module .................................................
  
  # .......................................................................
  
  # SVG 1.1 Clip Module ...................................................
  
  # file: svg-clip.mod
  # 
  # This is SVG, a language for describing two-dimensional graphics in XML.
  # Copyright 2001, 2002 W3C (MIT, INRIA, Keio), All Rights Reserved.
  # Revision: $Id: svg-clip.mod,v 1.3 2002/10/24 17:40:15 fujisawa Exp $
  # 
  # This DTD module is identified by the PUBLIC and SYSTEM identifiers:
  # 
  #    PUBLIC "-//W3C//ELEMENTS SVG 1.1 Clip//EN"
  #    SYSTEM "http://www.w3.org/Graphics/SVG/1.1/DTD/svg-clip.mod"
  # 
  # .......................................................................
  
  # Clip
  # 
  #    clipPath
  # 
  # This module declares markup to provide support for clipping.
  
  # 'clip-path' property/attribute value (e.g., 'none', <uri>)
  
  # Qualified Names (Default) .........................
  
  # Attribute Collections (Default) ...................
  
  # SVG.Clip.class ....................................
  
  # SVG.Clip.attrib ...................................
  
  # clipPath: Clip Path Element .......................
  SVG.clipPath.extra.content = notAllowed
  SVG.clipPath.content =
    SVG.Description.class*,
    (SVG.Animation.class
     | SVG.Use.class
     | SVG.Shape.class
     | SVG.Text.class
     | SVG.clipPath.extra.content)*
  clipPath =
    element ns1:clipPath { attlist.clipPath, SVG.clipPath.content }
  # end of SVG.clipPath.element
  attlist.clipPath &=
    SVG.Core.attrib,
    SVG.Conditional.attrib,
    SVG.Style.attrib,
    SVG.Text.attrib,
    SVG.TextContent.attrib,
    SVG.Font.attrib,
    SVG.Paint.attrib,
    SVG.Color.attrib,
    SVG.Opacity.attrib,
    SVG.Graphics.attrib,
    SVG.Clip.attrib,
    SVG.Mask.attrib,
    SVG.Filter.attrib,
    SVG.Cursor.attrib,
    SVG.External.attrib,
    attribute transform { TransformList.datatype }?,
    attribute clipPathUnits { "userSpaceOnUse" | "objectBoundingBox" }?
  # end of SVG.clipPath.attlist
  
  # end of svg-clip.mod
  
  # Mask Module .................................................
  
  # .......................................................................
  
  # SVG 1.1 Mask Module ...................................................
  
  # file: svg-mask.mod
  # 
  # This is SVG, a language for describing two-dimensional graphics in XML.
  # Copyright 2001, 2002 W3C (MIT, INRIA, Keio), All Rights Reserved.
  # Revision: $Id: svg-mask.mod,v 1.4 2002/11/14 15:11:03 fujisawa Exp $
  # 
  # This DTD module is identified by the PUBLIC and SYSTEM identifiers:
  # 
  #    PUBLIC "-//W3C//ELEMENTS SVG 1.1 Mask//EN"
  #    SYSTEM "http://www.w3.org/Graphics/SVG/1.1/DTD/svg-mask.mod"
  # 
  # .......................................................................
  
  # Mask
  # 
  #    mask
  # 
  # This module declares markup to provide support for masking.
  
  # 'mask' property/attribute value (e.g., 'none', <uri>)
  
  # Qualified Names (Default) .........................
  
  # Attribute Collections (Default) ...................
  
  # SVG.Mask.class ....................................
  
  # SVG.Mask.attrib ...................................
  
  # SVG.Presentation.attrib ...........................
  
  # mask: Mask Element ................................
  SVG.mask.extra.content = notAllowed
  SVG.mask.content =
    (SVG.Description.class
     | SVG.Animation.class
     | SVG.Structure.class
     | SVG.Conditional.class
     | SVG.Image.class
     | SVG.Style.class
     | SVG.Shape.class
     | SVG.Text.class
     | SVG.Marker.class
     | SVG.ColorProfile.class
     | SVG.Gradient.class
     | SVG.Pattern.class
     | SVG.Clip.class
     | SVG.Mask.class
     | SVG.Filter.class
     | SVG.Cursor.class
     | SVG.Hyperlink.class
     | SVG.View.class
     | SVG.Script.class
     | SVG.Font.class
     | SVG.mask.extra.content)*
  mask = element ns1:mask { attlist.mask, SVG.mask.content }
  # end of SVG.mask.element
  attlist.mask &=
    SVG.Core.attrib,
    SVG.Conditional.attrib,
    SVG.Style.attrib,
    SVG.Presentation.attrib,
    SVG.External.attrib,
    attribute x { Coordinate.datatype }?,
    attribute y { Coordinate.datatype }?,
    attribute width { Length.datatype }?,
    attribute height { Length.datatype }?,
    attribute maskUnits { "userSpaceOnUse" | "objectBoundingBox" }?,
    attribute maskContentUnits {
      "userSpaceOnUse" | "objectBoundingBox"
    }?
  # end of SVG.mask.attlist
  
  # end of svg-mask.mod
  
  # Filter Module ...............................................
  
  # .......................................................................
  
  # SVG 1.1 Filter Module .................................................
  
  # file: svg-filter.mod
  # 
  # This is SVG, a language for describing two-dimensional graphics in XML.
  # Copyright 2001, 2002 W3C (MIT, INRIA, Keio), All Rights Reserved.
  # Revision: $Id: svg-filter.mod,v 1.4 2002/11/14 15:11:02 fujisawa Exp $
  # 
  # This DTD module is identified by the PUBLIC and SYSTEM identifiers:
  # 
  #    PUBLIC "-//W3C//ELEMENTS SVG 1.1 Filter//EN"
  #    SYSTEM "http://www.w3.org/Graphics/SVG/1.1/DTD/svg-filter.mod"
  # 
  # .......................................................................
  
  # Filter
  # 
  #    filter, feBlend, feColorMatrix, feComponentTransfer, feComposite,
  #    feConvolveMatrix, feDiffuseLighting, feDisplacementMap, feFlood,
  #    feGaussianBlur, feImage, feMerge, feMergeNode, feMorphology, feOffset,
  #    feSpecularLighting, feTile, feTurbulence, feDistantLight, fePointLight,
  #    feSpotLight, feFuncR, feFuncG, feFuncB, feFuncA
  # 
  # This module declares markup to provide support for filter effect.
  
  # 'filter' property/attribute value (e.g., 'none', <uri>)
  
  # list of <number>s, but at least one and at most two
  
  # Qualified Names (Default) .........................
  
  # Attribute Collections (Default) ...................
  
  # SVG.Filter.class ..................................
  
  # SVG.FilterPrimitive.class .........................
  
  # SVG.Filter.attrib .................................
  
  # SVG.FilterColor.attrib ............................
  
  # SVG.FilterPrimitive.attrib ........................
  SVG.FilterPrimitive.extra.attrib = empty
  SVG.FilterPrimitive.attrib =
    attribute x { Coordinate.datatype }?,
    attribute y { Coordinate.datatype }?,
    attribute width { Length.datatype }?,
    attribute height { Length.datatype }?,
    attribute result { text }?,
    SVG.FilterPrimitive.extra.attrib
  # SVG.FilterPrimitiveWithIn.attrib ..................
  SVG.FilterPrimitiveWithIn.extra.attrib = empty
  SVG.FilterPrimitiveWithIn.attrib =
    SVG.FilterPrimitive.attrib,
    attribute in { text }?,
    SVG.FilterPrimitiveWithIn.extra.attrib
  # SVG.Presentation.attrib ...........................
  
  # filter: Filter Element ............................
  SVG.filter.extra.content = notAllowed
  SVG.filter.content =
    SVG.Description.class*,
    (animate
     | set
     | SVG.FilterPrimitive.class
     | SVG.filter.extra.content)*
  filter = element ns1:filter { attlist.filter, SVG.filter.content }
  # end of SVG.filter.element
  attlist.filter &=
    SVG.Core.attrib,
    SVG.Style.attrib,
    SVG.Presentation.attrib,
    SVG.XLink.attrib,
    SVG.External.attrib,
    attribute x { Coordinate.datatype }?,
    attribute y { Coordinate.datatype }?,
    attribute width { Length.datatype }?,
    attribute height { Length.datatype }?,
    attribute filterRes { NumberOptionalNumber.datatype }?,
    attribute filterUnits { "userSpaceOnUse" | "objectBoundingBox" }?,
    attribute primitiveUnits { "userSpaceOnUse" | "objectBoundingBox" }?
  # end of SVG.filter.attlist
  
  # feBlend: Filter Effect Blend Element ..............
  SVG.feBlend.extra.content = notAllowed
  SVG.feBlend.content = (animate | set | SVG.feBlend.extra.content)*
  feBlend = element ns1:feBlend { attlist.feBlend, SVG.feBlend.content }
  # end of SVG.feBlend.element
  attlist.feBlend &=
    SVG.Core.attrib,
    SVG.FilterColor.attrib,
    SVG.FilterPrimitiveWithIn.attrib,
    attribute in2 { text },
    [ a:defaultValue = "normal" ]
    attribute mode {
      "normal" | "multiply" | "screen" | "darken" | "lighten"
    }?
  # end of SVG.feBlend.attlist
  
  # feColorMatrix: Filter Effect Color Matrix Element .
  SVG.feColorMatrix.extra.content = notAllowed
  SVG.feColorMatrix.content =
    (animate | set | SVG.feColorMatrix.extra.content)*
  feColorMatrix =
    element ns1:feColorMatrix {
      attlist.feColorMatrix, SVG.feColorMatrix.content
    }
  # end of SVG.feColorMatrix.element
  attlist.feColorMatrix &=
    SVG.Core.attrib,
    SVG.FilterColor.attrib,
    SVG.FilterPrimitiveWithIn.attrib,
    [ a:defaultValue = "matrix" ]
    attribute type {
      "matrix" | "saturate" | "hueRotate" | "luminanceToAlpha"
    }?,
    attribute values { text }?
  # end of SVG.feColorMatrix.attlist
  
  # feComponentTransfer: Filter Effect Component Transfer Element
  SVG.feComponentTransfer.extra.content = empty
  SVG.feComponentTransfer.content =
    feFuncR?,
    feFuncG?,
    feFuncB?,
    feFuncA?,
    SVG.feComponentTransfer.extra.content
  feComponentTransfer =
    element ns1:feComponentTransfer {
      attlist.feComponentTransfer, SVG.feComponentTransfer.content
    }
  # end of SVG.feComponentTransfer.element
  attlist.feComponentTransfer &=
    SVG.Core.attrib,
    SVG.FilterColor.attrib,
    SVG.FilterPrimitiveWithIn.attrib
  # end of SVG.feComponentTransfer.attlist
  
  # feComposite: Filter Effect Composite Element ......
  SVG.feComposite.extra.content = notAllowed
  SVG.feComposite.content =
    (animate | set | SVG.feComposite.extra.content)*
  feComposite =
    element ns1:feComposite {
      attlist.feComposite, SVG.feComposite.content
    }
  # end of SVG.feComposite.element
  attlist.feComposite &=
    SVG.Core.attrib,
    SVG.FilterColor.attrib,
    SVG.FilterPrimitiveWithIn.attrib,
    attribute in2 { text },
    [ a:defaultValue = "over" ]
    attribute operator {
      "over" | "in" | "out" | "atop" | "xor" | "arithmetic"
    }?,
    attribute k1 { Number.datatype }?,
    attribute k2 { Number.datatype }?,
    attribute k3 { Number.datatype }?,
    attribute k4 { Number.datatype }?
  # end of SVG.feComposite.attlist
  
  # feConvolveMatrix: Filter Effect Convolve Matrix Element
  SVG.feConvolveMatrix.extra.content = notAllowed
  SVG.feConvolveMatrix.content =
    (animate | set | SVG.feConvolveMatrix.extra.content)*
  feConvolveMatrix =
    element ns1:feConvolveMatrix {
      attlist.feConvolveMatrix, SVG.feConvolveMatrix.content
    }
  # end of SVG.feConvolveMatrix.element
  attlist.feConvolveMatrix &=
    SVG.Core.attrib,
    SVG.FilterColor.attrib,
    SVG.FilterPrimitiveWithIn.attrib,
    attribute order { NumberOptionalNumber.datatype },
    attribute kernelMatrix { text },
    attribute divisor { Number.datatype }?,
    attribute bias { Number.datatype }?,
    attribute targetX { Integer.datatype }?,
    attribute targetY { Integer.datatype }?,
    [ a:defaultValue = "duplicate" ]
    attribute edgeMode { "duplicate" | "wrap" | "none" }?,
    attribute kernelUnitLength { NumberOptionalNumber.datatype }?,
    attribute preserveAlpha { Boolean.datatype }?
  # end of SVG.feConvolveMatrix.attlist
  
  # feDiffuseLighting: Filter Effect Diffuse Lighting Element
  SVG.feDiffuseLighting.extra.content = notAllowed
  SVG.feDiffuseLighting.content =
    (feDistantLight | fePointLight | feSpotLight),
    (animate
     | set
     | animateColor
     | SVG.feDiffuseLighting.extra.content)*
  feDiffuseLighting =
    element ns1:feDiffuseLighting {
      attlist.feDiffuseLighting, SVG.feDiffuseLighting.content
    }
  # end of SVG.feDiffuseLighting.element
  attlist.feDiffuseLighting &=
    SVG.Core.attrib,
    SVG.Style.attrib,
    SVG.Color.attrib,
    SVG.FilterColor.attrib,
    SVG.FilterPrimitiveWithIn.attrib,
    attribute lighting-color { SVGColor.datatype }?,
    attribute surfaceScale { Number.datatype }?,
    attribute diffuseConstant { Number.datatype }?,
    attribute kernelUnitLength { NumberOptionalNumber.datatype }?
  # end of SVG.feDiffuseLighting.attlist
  
  # feDisplacementMap: Filter Effect Displacement Map Element
  SVG.feDisplacementMap.extra.content = notAllowed
  SVG.feDisplacementMap.content =
    (animate | set | SVG.feDisplacementMap.extra.content)*
  feDisplacementMap =
    element ns1:feDisplacementMap {
      attlist.feDisplacementMap, SVG.feDisplacementMap.content
    }
  # end of SVG.feDisplacementMap.element
  attlist.feDisplacementMap &=
    SVG.Core.attrib,
    SVG.FilterColor.attrib,
    SVG.FilterPrimitiveWithIn.attrib,
    attribute in2 { text },
    attribute scale { Number.datatype }?,
    [ a:defaultValue = "A" ]
    attribute xChannelSelector { "R" | "G" | "B" | "A" }?,
    [ a:defaultValue = "A" ]
    attribute yChannelSelector { "R" | "G" | "B" | "A" }?
  # end of SVG.feDisplacementMap.attlist
  
  # feFlood: Filter Effect Flood Element ..............
  SVG.feFlood.extra.content = notAllowed
  SVG.feFlood.content =
    (animate | set | animateColor | SVG.feFlood.extra.content)*
  feFlood = element ns1:feFlood { attlist.feFlood, SVG.feFlood.content }
  # end of SVG.feFlood.element
  attlist.feFlood &=
    SVG.Core.attrib,
    SVG.Style.attrib,
    SVG.Color.attrib,
    SVG.FilterColor.attrib,
    SVG.FilterPrimitiveWithIn.attrib,
    attribute flood-color { SVGColor.datatype }?,
    attribute flood-opacity { OpacityValue.datatype }?
  # end of SVG.feFlood.attlist
  
  # feGaussianBlur: Filter Effect Gaussian Blur Element
  SVG.feGaussianBlur.extra.content = notAllowed
  SVG.feGaussianBlur.content =
    (animate | set | SVG.feGaussianBlur.extra.content)*
  feGaussianBlur =
    element ns1:feGaussianBlur {
      attlist.feGaussianBlur, SVG.feGaussianBlur.content
    }
  # end of SVG.feGaussianBlur.element
  attlist.feGaussianBlur &=
    SVG.Core.attrib,
    SVG.FilterColor.attrib,
    SVG.FilterPrimitiveWithIn.attrib,
    attribute stdDeviation { NumberOptionalNumber.datatype }?
  # end of SVG.feGaussianBlur.attlist
  
  # feImage: Filter Effect Image Element ..............
  SVG.feImage.extra.content = notAllowed
  SVG.feImage.content =
    (animate | set | animateTransform | SVG.feImage.extra.content)*
  feImage = element ns1:feImage { attlist.feImage, SVG.feImage.content }
  # end of SVG.feImage.element
  attlist.feImage &=
    SVG.Core.attrib,
    SVG.Style.attrib,
    SVG.Presentation.attrib,
    SVG.FilterPrimitive.attrib,
    SVG.XLinkEmbed.attrib,
    SVG.External.attrib,
    [ a:defaultValue = "xMidYMid meet" ]
    attribute preserveAspectRatio { PreserveAspectRatioSpec.datatype }?
  # end of SVG.feImage.attlist
  
  # feMerge: Filter Effect Merge Element ..............
  SVG.feMerge.extra.content = notAllowed
  SVG.feMerge.content = (feMergeNode | SVG.feMerge.extra.content)*
  feMerge = element ns1:feMerge { attlist.feMerge, SVG.feMerge.content }
  # end of SVG.feMerge.element
  attlist.feMerge &=
    SVG.Core.attrib, SVG.FilterColor.attrib, SVG.FilterPrimitive.attrib
  # end of SVG.feMerge.attlist
  
  # feMergeNode: Filter Effect Merge Node Element .....
  SVG.feMergeNode.extra.content = notAllowed
  SVG.feMergeNode.content =
    (animate | set | SVG.feMergeNode.extra.content)*
  feMergeNode =
    element ns1:feMergeNode {
      attlist.feMergeNode, SVG.feMergeNode.content
    }
  # end of SVG.feMergeNode.element
  attlist.feMergeNode &=
    SVG.Core.attrib,
    attribute in { text }?
  # end of SVG.feMergeNode.attlist
  
  # feMorphology: Filter Effect Morphology Element ....
  SVG.feMorphology.extra.content = notAllowed
  SVG.feMorphology.content =
    (animate | set | SVG.feMorphology.extra.content)*
  feMorphology =
    element ns1:feMorphology {
      attlist.feMorphology, SVG.feMorphology.content
    }
  # end of SVG.feMorphology.element
  attlist.feMorphology &=
    SVG.Core.attrib,
    SVG.FilterColor.attrib,
    SVG.FilterPrimitiveWithIn.attrib,
    [ a:defaultValue = "erode" ]
    attribute operator { "erode" | "dilate" }?,
    attribute radius { NumberOptionalNumber.datatype }?
  # end of SVG.feMorphology.attlist
  
  # feOffset: Filter Effect Offset Element ............
  SVG.feOffset.extra.content = notAllowed
  SVG.feOffset.content = (animate | set | SVG.feOffset.extra.content)*
  feOffset =
    element ns1:feOffset { attlist.feOffset, SVG.feOffset.content }
  # end of SVG.feOffset.element
  attlist.feOffset &=
    SVG.Core.attrib,
    SVG.FilterColor.attrib,
    SVG.FilterPrimitiveWithIn.attrib,
    attribute dx { Number.datatype }?,
    attribute dy { Number.datatype }?
  # end of SVG.feOffset.attlist
  
  # feSpecularLighting: Filter Effect Specular Lighting Element
  SVG.feSpecularLighting.extra.content = notAllowed
  SVG.feSpecularLighting.content =
    (feDistantLight | fePointLight | feSpotLight),
    (animate
     | set
     | animateColor
     | SVG.feSpecularLighting.extra.content)*
  feSpecularLighting =
    element ns1:feSpecularLighting {
      attlist.feSpecularLighting, SVG.feSpecularLighting.content
    }
  # end of SVG.feSpecularLighting.element
  attlist.feSpecularLighting &=
    SVG.Core.attrib,
    SVG.Style.attrib,
    SVG.Color.attrib,
    SVG.FilterColor.attrib,
    SVG.FilterPrimitiveWithIn.attrib,
    attribute lighting-color { SVGColor.datatype }?,
    attribute surfaceScale { Number.datatype }?,
    attribute specularConstant { Number.datatype }?,
    attribute specularExponent { Number.datatype }?,
    attribute kernelUnitLength { NumberOptionalNumber.datatype }?
  # end of SVG.feSpecularLighting.attlist
  
  # feTile: Filter Effect Tile Element ................
  SVG.feTile.extra.content = notAllowed
  SVG.feTile.content = (animate | set | SVG.feTile.extra.content)*
  feTile = element ns1:feTile { attlist.feTile, SVG.feTile.content }
  # end of SVG.feTile.element
  attlist.feTile &=
    SVG.Core.attrib,
    SVG.FilterColor.attrib,
    SVG.FilterPrimitiveWithIn.attrib
  # end of SVG.feTile.attlist
  
  # feTurbulence: Filter Effect Turbulence Element ....
  SVG.feTurbulence.extra.content = notAllowed
  SVG.feTurbulence.content =
    (animate | set | SVG.feTurbulence.extra.content)*
  feTurbulence =
    element ns1:feTurbulence {
      attlist.feTurbulence, SVG.feTurbulence.content
    }
  # end of SVG.feTurbulence.element
  attlist.feTurbulence &=
    SVG.Core.attrib,
    SVG.FilterColor.attrib,
    SVG.FilterPrimitive.attrib,
    attribute baseFrequency { NumberOptionalNumber.datatype }?,
    attribute numOctaves { Integer.datatype }?,
    attribute seed { Number.datatype }?,
    [ a:defaultValue = "noStitch" ]
    attribute stitchTiles { "stitch" | "noStitch" }?,
    [ a:defaultValue = "turbulence" ]
    attribute type { "fractalNoise" | "turbulence" }?
  # end of SVG.feTurbulence.attlist
  
  # feDistantLight: Filter Effect Distant Light Element
  SVG.feDistantLight.extra.content = notAllowed
  SVG.feDistantLight.content =
    (animate | set | SVG.feDistantLight.extra.content)*
  feDistantLight =
    element ns1:feDistantLight {
      attlist.feDistantLight, SVG.feDistantLight.content
    }
  # end of SVG.feDistantLight.element
  attlist.feDistantLight &=
    SVG.Core.attrib,
    attribute azimuth { Number.datatype }?,
    attribute elevation { Number.datatype }?
  # end of SVG.feDistantLight.attlist
  
  # fePointLight: Filter Effect Point Light Element ...
  SVG.fePointLight.extra.content = notAllowed
  SVG.fePointLight.content =
    (animate | set | SVG.fePointLight.extra.content)*
  fePointLight =
    element ns1:fePointLight {
      attlist.fePointLight, SVG.fePointLight.content
    }
  # end of SVG.fePointLight.element
  attlist.fePointLight &=
    SVG.Core.attrib,
    attribute x { Number.datatype }?,
    attribute y { Number.datatype }?,
    attribute z { Number.datatype }?
  # end of SVG.fePointLight.attlist
  
  # feSpotLight: Filter Effect Spot Light Element .....
  SVG.feSpotLight.extra.content = notAllowed
  SVG.feSpotLight.content =
    (animate | set | SVG.feSpotLight.extra.content)*
  feSpotLight =
    element ns1:feSpotLight {
      attlist.feSpotLight, SVG.feSpotLight.content
    }
  # end of SVG.feSpotLight.element
  attlist.feSpotLight &=
    SVG.Core.attrib,
    attribute x { Number.datatype }?,
    attribute y { Number.datatype }?,
    attribute z { Number.datatype }?,
    attribute pointsAtX { Number.datatype }?,
    attribute pointsAtY { Number.datatype }?,
    attribute pointsAtZ { Number.datatype }?,
    attribute specularExponent { Number.datatype }?,
    attribute limitingConeAngle { Number.datatype }?
  # end of SVG.feSpotLight.attlist
  
  # feFuncR: Filter Effect Function Red Element .......
  SVG.feFuncR.extra.content = notAllowed
  SVG.feFuncR.content = (animate | set | SVG.feFuncR.extra.content)*
  feFuncR = element ns1:feFuncR { attlist.feFuncR, SVG.feFuncR.content }
  # end of SVG.feFuncR.element
  attlist.feFuncR &=
    SVG.Core.attrib,
    attribute type {
      "identity" | "table" | "discrete" | "linear" | "gamma"
    },
    attribute tableValues { text }?,
    attribute slope { Number.datatype }?,
    attribute intercept { Number.datatype }?,
    attribute amplitude { Number.datatype }?,
    attribute exponent { Number.datatype }?,
    attribute offset { Number.datatype }?
  # end of SVG.feFuncR.attlist
  
  # feFuncG: Filter Effect Function Green Element .....
  SVG.feFuncG.extra.content = notAllowed
  SVG.feFuncG.content = (animate | set | SVG.feFuncG.extra.content)*
  feFuncG = element ns1:feFuncG { attlist.feFuncG, SVG.feFuncG.content }
  # end of SVG.feFuncG.element
  attlist.feFuncG &=
    SVG.Core.attrib,
    attribute type {
      "identity" | "table" | "discrete" | "linear" | "gamma"
    },
    attribute tableValues { text }?,
    attribute slope { Number.datatype }?,
    attribute intercept { Number.datatype }?,
    attribute amplitude { Number.datatype }?,
    attribute exponent { Number.datatype }?,
    attribute offset { Number.datatype }?
  # end of SVG.feFuncG.attlist
  
  # feFuncB: Filter Effect Function Blue Element ......
  SVG.feFuncB.extra.content = notAllowed
  SVG.feFuncB.content = (animate | set | SVG.feFuncB.extra.content)*
  feFuncB = element ns1:feFuncB { attlist.feFuncB, SVG.feFuncB.content }
  # end of SVG.feFuncB.element
  attlist.feFuncB &=
    SVG.Core.attrib,
    attribute type {
      "identity" | "table" | "discrete" | "linear" | "gamma"
    },
    attribute tableValues { text }?,
    attribute slope { Number.datatype }?,
    attribute intercept { Number.datatype }?,
    attribute amplitude { Number.datatype }?,
    attribute exponent { Number.datatype }?,
    attribute offset { Number.datatype }?
  # end of SVG.feFuncB.attlist
  
  # feFuncA: Filter Effect Function Alpha Element .....
  SVG.feFuncA.extra.content = notAllowed
  SVG.feFuncA.content = (animate | set | SVG.feFuncA.extra.content)*
  feFuncA = element ns1:feFuncA { attlist.feFuncA, SVG.feFuncA.content }
  # end of SVG.feFuncA.element
  attlist.feFuncA &=
    SVG.Core.attrib,
    attribute type {
      "identity" | "table" | "discrete" | "linear" | "gamma"
    },
    attribute tableValues { text }?,
    attribute slope { Number.datatype }?,
    attribute intercept { Number.datatype }?,
    attribute amplitude { Number.datatype }?,
    attribute exponent { Number.datatype }?,
    attribute offset { Number.datatype }?
  # end of SVG.feFuncA.attlist
  
  # end of svg-filter.mod
  
  # Cursor Module ...............................................
  
  # .......................................................................
  
  # SVG 1.1 Cursor Module .................................................
  
  # file: svg-cursor.mod
  # 
  # This is SVG, a language for describing two-dimensional graphics in XML.
  # Copyright 2001, 2002 W3C (MIT, INRIA, Keio), All Rights Reserved.
  # Revision: $Id: svg-cursor.mod,v 1.3 2002/10/24 17:40:15 fujisawa Exp $
  # 
  # This DTD module is identified by the PUBLIC and SYSTEM identifiers:
  # 
  #    PUBLIC "-//W3C//ELEMENTS SVG 1.1 Cursor//EN"
  #    SYSTEM "http://www.w3.org/Graphics/SVG/1.1/DTD/svg-cursor.mod"
  # 
  # .......................................................................
  
  # Cursor
  # 
  #    cursor
  # 
  # This module declares markup to provide support for cursor.
  
  # 'cursor' property/attribute value (e.g., 'crosshair', <uri>)
  
  # Qualified Names (Default) .........................
  
  # Attribute Collections (Default) ...................
  
  # SVG.Cursor.class ..................................
  
  # SVG.Cursor.attrib .................................
  
  # cursor: Cursor Element ............................
  SVG.cursor.extra.content = notAllowed
  SVG.cursor.content =
    (SVG.Description.class | SVG.cursor.extra.content)*
  cursor = element ns1:cursor { attlist.cursor, SVG.cursor.content }
  # end of SVG.cursor.element
  attlist.cursor &=
    SVG.Core.attrib,
    SVG.Conditional.attrib,
    SVG.XLinkRequired.attrib,
    SVG.External.attrib,
    attribute x { Coordinate.datatype }?,
    attribute y { Coordinate.datatype }?
  # end of SVG.cursor.attlist
  
  # end of svg-cursor.mod
  
  # Hyperlinking Module .........................................
  
  # .......................................................................
  
  # SVG 1.1 Hyperlinking Module ...........................................
  
  # file: svg-hyperlink.mod
  # 
  # This is SVG, a language for describing two-dimensional graphics in XML.
  # Copyright 2001, 2002 W3C (MIT, INRIA, Keio), All Rights Reserved.
  # Revision: $Id: svg-hyperlink.mod,v 1.4 2002/11/14 15:11:02 fujisawa Exp $
  # 
  # This DTD module is identified by the PUBLIC and SYSTEM identifiers:
  # 
  #    PUBLIC "-//W3C//ELEMENTS SVG 1.1 Hyperlinking//EN"
  #    SYSTEM "http://www.w3.org/Graphics/SVG/1.1/DTD/svg-hyperlink.mod"
  # 
  # .......................................................................
  
  # Hyperlinking
  # 
  #    a
  # 
  # This module declares markup to provide support for hyper linking.
  
  # link to this target
  LinkTarget.datatype = xsd:NMTOKEN
  # Qualified Names (Default) .........................
  
  # Attribute Collections (Default) ...................
  
  # SVG.Hyperlink.class ...............................
  
  # SVG.Presentation.attrib ...........................
  
  # a: Anchor Element .................................
  SVG.a.extra.content = notAllowed
  SVG.a.content =
    (text
     | SVG.Description.class
     | SVG.Animation.class
     | SVG.Structure.class
     | SVG.Conditional.class
     | SVG.Image.class
     | SVG.Style.class
     | SVG.Shape.class
     | SVG.Text.class
     | SVG.Marker.class
     | SVG.ColorProfile.class
     | SVG.Gradient.class
     | SVG.Pattern.class
     | SVG.Clip.class
     | SVG.Mask.class
     | SVG.Filter.class
     | SVG.Cursor.class
     | SVG.Hyperlink.class
     | SVG.View.class
     | SVG.Script.class
     | SVG.Font.class
     | SVG.a.extra.content)*
  a = element ns1:a { attlist.a, SVG.a.content }
  # end of SVG.a.element
  attlist.a &=
    SVG.Core.attrib,
    SVG.Conditional.attrib,
    SVG.Style.attrib,
    SVG.Presentation.attrib,
    SVG.GraphicalEvents.attrib,
    SVG.XLinkReplace.attrib,
    SVG.External.attrib,
    attribute transform { TransformList.datatype }?,
    attribute target { LinkTarget.datatype }?
  # end of SVG.a.attlist
  
  # end of svg-hyperlink.mod
  
  # View Module .................................................
  
  # .......................................................................
  
  # SVG 1.1 View Module ...................................................
  
  # file: svg-view.mod
  # 
  # This is SVG, a language for describing two-dimensional graphics in XML.
  # Copyright 2001, 2002 W3C (MIT, INRIA, Keio), All Rights Reserved.
  # Revision: $Id: svg-view.mod,v 1.3 2002/10/24 17:40:16 fujisawa Exp $
  # 
  # This DTD module is identified by the PUBLIC and SYSTEM identifiers:
  # 
  #    PUBLIC "-//W3C//ELEMENTS SVG 1.1 View//EN"
  #    SYSTEM "http://www.w3.org/Graphics/SVG/1.1/DTD/svg-view.mod"
  # 
  # .......................................................................
  
  # View
  # 
  #    view
  # 
  # This module declares markup to provide support for view.
  
  # Qualified Names (Default) .........................
  
  # Attribute Collections (Default) ...................
  
  # SVG.View.class ....................................
  
  # view: View Element ................................
  SVG.view.extra.content = notAllowed
  SVG.view.content = (SVG.Description.class | SVG.view.extra.content)*
  view = element ns1:view { attlist.view, SVG.view.content }
  # end of SVG.view.element
  attlist.view &=
    SVG.Core.attrib,
    SVG.External.attrib,
    attribute viewBox { ViewBoxSpec.datatype }?,
    [ a:defaultValue = "xMidYMid meet" ]
    attribute preserveAspectRatio { PreserveAspectRatioSpec.datatype }?,
    [ a:defaultValue = "magnify" ]
    attribute zoomAndPan { "disable" | "magnify" }?,
    attribute viewTarget { text }?
  # end of SVG.view.attlist
  
  # end of svg-view.mod
  
  # Scripting Module ............................................
  
  # .......................................................................
  
  # SVG 1.1 Scripting Module ..............................................
  
  # file: svg-script.mod
  # 
  # This is SVG, a language for describing two-dimensional graphics in XML.
  # Copyright 2001, 2002 W3C (MIT, INRIA, Keio), All Rights Reserved.
  # Revision: $Id: svg-script.mod,v 1.3 2002/10/24 17:40:16 fujisawa Exp $
  # 
  # This DTD module is identified by the PUBLIC and SYSTEM identifiers:
  # 
  #    PUBLIC "-//W3C//ELEMENTS SVG 1.1 Scripting//EN"
  #    SYSTEM "http://www.w3.org/Graphics/SVG/1.1/DTD/svg-script.mod"
  # 
  # .......................................................................
  
  # Scripting
  # 
  #    script
  # 
  # This module declares markup to provide support for scripting.
  
  # Qualified Names (Default) .........................
  
  # Attribute Collections (Default) ...................
  
  # SVG.Script.class ..................................
  
  # script: Script Element ............................
  SVG.script.extra.content = notAllowed
  SVG.script.content = (text | SVG.script.extra.content)*
  script = element ns1:script { attlist.script, SVG.script.content }
  # end of SVG.script.element
  attlist.script &=
    SVG.Core.attrib,
    SVG.XLink.attrib,
    SVG.External.attrib,
    attribute type { ContentType.datatype }
  # end of SVG.script.attlist
  
  # end of svg-script.mod
  
  # Animation Module ............................................
  
  # .......................................................................
  
  # SVG 1.1 Animation Module ..............................................
  
  # file: svg-animation.mod
  # 
  # This is SVG, a language for describing two-dimensional graphics in XML.
  # Copyright 2001, 2002 W3C (MIT, INRIA, Keio), All Rights Reserved.
  # Revision: $Id: svg-animation.mod,v 1.3 2002/10/24 17:40:14 fujisawa Exp $
  # 
  # This DTD module is identified by the PUBLIC and SYSTEM identifiers:
  # 
  #    PUBLIC "-//W3C//ELEMENTS SVG 1.1 Animation//EN"
  #    SYSTEM "http://www.w3.org/Graphics/SVG/1.1/DTD/svg-animation.mod"
  # 
  # .......................................................................
  
  # Animation
  # 
  #    animate, set, animateMotion, animateColor, animateTransform, mpath
  # 
  # This module declares markup to provide support for animation.
  
  # Qualified Names (Default) .........................
  
  # Attribute Collections (Default) ...................
  
  # SVG.Animation.class ...............................
  
  # SVG.Animation.attrib ..............................
  SVG.Animation.extra.attrib = empty
  SVG.Animation.attrib = SVG.XLink.attrib, SVG.Animation.extra.attrib
  # SVG.AnimationAttribute.attrib .....................
  SVG.AnimationAttribute.extra.attrib = empty
  SVG.AnimationAttribute.attrib =
    attribute attributeName { text },
    attribute attributeType { text }?,
    SVG.AnimationAttribute.extra.attrib
  # SVG.AnimationTiming.attrib ........................
  SVG.AnimationTiming.extra.attrib = empty
  SVG.AnimationTiming.attrib =
    attribute begin { text }?,
    attribute dur { text }?,
    attribute end { text }?,
    attribute min { text }?,
    attribute max { text }?,
    [ a:defaultValue = "always" ]
    attribute restart { "always" | "never" | "whenNotActive" }?,
    attribute repeatCount { text }?,
    attribute repeatDur { text }?,
    [ a:defaultValue = "remove" ]
    attribute fill { "remove" | "freeze" }?,
    SVG.AnimationTiming.extra.attrib
  # SVG.AnimationValue.attrib .........................
  SVG.AnimationValue.extra.attrib = empty
  SVG.AnimationValue.attrib =
    [ a:defaultValue = "linear" ]
    attribute calcMode { "discrete" | "linear" | "paced" | "spline" }?,
    attribute values { text }?,
    attribute keyTimes { text }?,
    attribute keySplines { text }?,
    attribute from { text }?,
    attribute to { text }?,
    attribute by { text }?,
    SVG.AnimationValue.extra.attrib
  # SVG.AnimationAddtion.attrib .......................
  SVG.AnimationAddtion.extra.attrib = empty
  SVG.AnimationAddtion.attrib =
    [ a:defaultValue = "replace" ]
    attribute additive { "replace" | "sum" }?,
    [ a:defaultValue = "none" ]
    attribute accumulate { "none" | "sum" }?,
    SVG.AnimationAddtion.extra.attrib
  # animate: Animate Element ..........................
  SVG.animate.extra.content = notAllowed
  SVG.animate.content =
    (SVG.Description.class | SVG.animate.extra.content)*
  animate = element ns1:animate { attlist.animate, SVG.animate.content }
  # end of SVG.animate.element
  attlist.animate &=
    SVG.Core.attrib,
    SVG.Conditional.attrib,
    SVG.AnimationEvents.attrib,
    SVG.External.attrib,
    SVG.Animation.attrib,
    SVG.AnimationAttribute.attrib,
    SVG.AnimationTiming.attrib,
    SVG.AnimationValue.attrib,
    SVG.AnimationAddtion.attrib
  # end of SVG.animate.attlist
  
  # set: Set Element ..................................
  SVG.set.extra.content = notAllowed
  SVG.set.content = (SVG.Description.class | SVG.set.extra.content)*
  set = element ns1:set { attlist.set, SVG.set.content }
  # end of SVG.set.element
  attlist.set &=
    SVG.Core.attrib,
    SVG.Conditional.attrib,
    SVG.AnimationEvents.attrib,
    SVG.External.attrib,
    SVG.Animation.attrib,
    SVG.AnimationAttribute.attrib,
    SVG.AnimationTiming.attrib,
    attribute to { text }?
  # end of SVG.set.attlist
  
  # animateMotion: Animate Motion Element .............
  SVG.animateMotion.extra.content = empty
  SVG.animateMotion.content =
    SVG.Description.class*, mpath?, SVG.animateMotion.extra.content
  animateMotion =
    element ns1:animateMotion {
      attlist.animateMotion, SVG.animateMotion.content
    }
  # end of SVG.animateMotion.element
  attlist.animateMotion &=
    SVG.Core.attrib,
    SVG.Conditional.attrib,
    SVG.AnimationEvents.attrib,
    SVG.External.attrib,
    SVG.Animation.attrib,
    SVG.AnimationTiming.attrib,
    SVG.AnimationAddtion.attrib,
    [ a:defaultValue = "paced" ]
    attribute calcMode { "discrete" | "linear" | "paced" | "spline" }?,
    attribute values { text }?,
    attribute keyTimes { text }?,
    attribute keySplines { text }?,
    attribute from { text }?,
    attribute to { text }?,
    attribute by { text }?,
    attribute path { text }?,
    attribute keyPoints { text }?,
    attribute rotate { text }?,
    attribute origin { text }?
  # end of SVG.animateMotion.attlist
  
  # animateColor: Animate Color Element ...............
  SVG.animateColor.extra.content = notAllowed
  SVG.animateColor.content =
    (SVG.Description.class | SVG.animateColor.extra.content)*
  animateColor =
    element ns1:animateColor {
      attlist.animateColor, SVG.animateColor.content
    }
  # end of SVG.animateColor.element
  attlist.animateColor &=
    SVG.Core.attrib,
    SVG.Conditional.attrib,
    SVG.AnimationEvents.attrib,
    SVG.External.attrib,
    SVG.Animation.attrib,
    SVG.AnimationAttribute.attrib,
    SVG.AnimationTiming.attrib,
    SVG.AnimationValue.attrib,
    SVG.AnimationAddtion.attrib
  # end of SVG.animateColor.attlist
  
  # animateTransform: Animate Transform Element .......
  SVG.animateTransform.extra.content = notAllowed
  SVG.animateTransform.content =
    (SVG.Description.class | SVG.animateTransform.extra.content)*
  animateTransform =
    element ns1:animateTransform {
      attlist.animateTransform, SVG.animateTransform.content
    }
  # end of SVG.animateTransform.element
  attlist.animateTransform &=
    SVG.Core.attrib,
    SVG.Conditional.attrib,
    SVG.AnimationEvents.attrib,
    SVG.External.attrib,
    SVG.Animation.attrib,
    SVG.AnimationAttribute.attrib,
    SVG.AnimationTiming.attrib,
    SVG.AnimationValue.attrib,
    SVG.AnimationAddtion.attrib,
    [ a:defaultValue = "translate" ]
    attribute type {
      "translate" | "scale" | "rotate" | "skewX" | "skewY"
    }?
  # end of SVG.animateTransform.attlist
  
  # mpath: Motion Path Element ........................
  SVG.mpath.extra.content = notAllowed
  SVG.mpath.content = (SVG.Description.class | SVG.mpath.extra.content)*
  mpath = element ns1:mpath { attlist.mpath, SVG.mpath.content }
  # end of SVG.mpath.element
  attlist.mpath &=
    SVG.Core.attrib, SVG.XLinkRequired.attrib, SVG.External.attrib
  # end of SVG.mpath.attlist
  
  # end of svg-animation.mod
  
  # Font Module .................................................
  
  # .......................................................................
  
  # SVG 1.1 Font Module ...................................................
  
  # file: svg-font.mod
  # 
  # This is SVG, a language for describing two-dimensional graphics in XML.
  # Copyright 2001, 2002 W3C (MIT, INRIA, Keio), All Rights Reserved.
  # Revision: $Id: svg-font.mod,v 1.4 2002/11/14 15:11:02 fujisawa Exp $
  # 
  # This DTD module is identified by the PUBLIC and SYSTEM identifiers:
  # 
  #    PUBLIC "-//W3C//ELEMENTS SVG 1.1 Font//EN"
  #    SYSTEM "http://www.w3.org/Graphics/SVG/1.1/DTD/svg-font.mod"
  # 
  # .......................................................................
  
  # Font
  # 
  #    font, font-face, glyph, missing-glyph, hkern, vkern, font-face-src,
  #    font-face-uri, font-face-format, font-face-name, definition-src
  # 
  # This module declares markup to provide support for template.
  
  # Qualified Names (Default) .........................
  
  # Attribute Collections (Default) ...................
  
  # SVG.Font.class ....................................
  
  # SVG.Presentation.attrib ...........................
  
  # font: Font Element ................................
  SVG.font.extra.content = notAllowed
  SVG.font.content =
    SVG.Description.class*,
    font-face,
    missing-glyph,
    (glyph | hkern | vkern | SVG.font.extra.content)*
  font = element ns1:font { attlist.font, SVG.font.content }
  # end of SVG.font.element
  attlist.font &=
    SVG.Core.attrib,
    SVG.Style.attrib,
    SVG.Presentation.attrib,
    SVG.External.attrib,
    attribute horiz-origin-x { Number.datatype }?,
    attribute horiz-origin-y { Number.datatype }?,
    attribute horiz-adv-x { Number.datatype },
    attribute vert-origin-x { Number.datatype }?,
    attribute vert-origin-y { Number.datatype }?,
    attribute vert-adv-y { Number.datatype }?
  # end of SVG.font.attlist
  
  # font-face: Font Face Element ......................
  SVG.font-face.extra.content = empty
  SVG.font-face.content =
    SVG.Description.class*,
    font-face-src?,
    definition-src?,
    SVG.font-face.extra.content
  font-face =
    element ns1:font-face { attlist.font-face, SVG.font-face.content }
  # end of SVG.font-face.element
  attlist.font-face &=
    SVG.Core.attrib,
    attribute font-family { text }?,
    attribute font-style { text }?,
    attribute font-variant { text }?,
    attribute font-weight { text }?,
    attribute font-stretch { text }?,
    attribute font-size { text }?,
    attribute unicode-range { text }?,
    attribute units-per-em { Number.datatype }?,
    attribute panose-1 { text }?,
    attribute stemv { Number.datatype }?,
    attribute stemh { Number.datatype }?,
    attribute slope { Number.datatype }?,
    attribute cap-height { Number.datatype }?,
    attribute x-height { Number.datatype }?,
    attribute accent-height { Number.datatype }?,
    attribute ascent { Number.datatype }?,
    attribute descent { Number.datatype }?,
    attribute widths { text }?,
    attribute bbox { text }?,
    attribute ideographic { Number.datatype }?,
    attribute alphabetic { Number.datatype }?,
    attribute mathematical { Number.datatype }?,
    attribute hanging { Number.datatype }?,
    attribute v-ideographic { Number.datatype }?,
    attribute v-alphabetic { Number.datatype }?,
    attribute v-mathematical { Number.datatype }?,
    attribute v-hanging { Number.datatype }?,
    attribute underline-position { Number.datatype }?,
    attribute underline-thickness { Number.datatype }?,
    attribute strikethrough-position { Number.datatype }?,
    attribute strikethrough-thickness { Number.datatype }?,
    attribute overline-position { Number.datatype }?,
    attribute overline-thickness { Number.datatype }?
  # end of SVG.font-face.attlist
  
  # glyph: Glyph Element ..............................
  SVG.glyph.extra.content = notAllowed
  SVG.glyph.content =
    (SVG.Description.class
     | SVG.Animation.class
     | SVG.Structure.class
     | SVG.Conditional.class
     | SVG.Image.class
     | SVG.Style.class
     | SVG.Shape.class
     | SVG.Text.class
     | SVG.Marker.class
     | SVG.ColorProfile.class
     | SVG.Gradient.class
     | SVG.Pattern.class
     | SVG.Clip.class
     | SVG.Mask.class
     | SVG.Filter.class
     | SVG.Cursor.class
     | SVG.Hyperlink.class
     | SVG.View.class
     | SVG.Script.class
     | SVG.Font.class
     | SVG.glyph.extra.content)*
  glyph = element ns1:glyph { attlist.glyph, SVG.glyph.content }
  # end of SVG.glyph.element
  attlist.glyph &=
    SVG.Core.attrib,
    SVG.Style.attrib,
    SVG.Presentation.attrib,
    attribute unicode { text }?,
    attribute glyph-name { text }?,
    attribute d { PathData.datatype }?,
    attribute orientation { text }?,
    attribute arabic-form { text }?,
    attribute lang { LanguageCodes.datatype }?,
    attribute horiz-adv-x { Number.datatype }?,
    attribute vert-origin-x { Number.datatype }?,
    attribute vert-origin-y { Number.datatype }?,
    attribute vert-adv-y { Number.datatype }?
  # end of SVG.glyph.attlist
  
  # missing-glyph: Missing Glyph Element ..............
  SVG.missing-glyph.extra.content = notAllowed
  SVG.missing-glyph.content =
    (SVG.Description.class
     | SVG.Animation.class
     | SVG.Structure.class
     | SVG.Conditional.class
     | SVG.Image.class
     | SVG.Style.class
     | SVG.Shape.class
     | SVG.Text.class
     | SVG.Marker.class
     | SVG.ColorProfile.class
     | SVG.Gradient.class
     | SVG.Pattern.class
     | SVG.Clip.class
     | SVG.Mask.class
     | SVG.Filter.class
     | SVG.Cursor.class
     | SVG.Hyperlink.class
     | SVG.View.class
     | SVG.Script.class
     | SVG.Font.class
     | SVG.missing-glyph.extra.content)*
  missing-glyph =
    element ns1:missing-glyph {
      attlist.missing-glyph, SVG.missing-glyph.content
    }
  # end of SVG.missing-glyph.element
  attlist.missing-glyph &=
    SVG.Core.attrib,
    SVG.Style.attrib,
    SVG.Presentation.attrib,
    attribute d { PathData.datatype }?,
    attribute horiz-adv-x { Number.datatype }?,
    attribute vert-origin-x { Number.datatype }?,
    attribute vert-origin-y { Number.datatype }?,
    attribute vert-adv-y { Number.datatype }?
  # end of SVG.missing-glyph.attlist
  
  # hkern: Horizontal Kerning Element .................
  SVG.hkern.content = empty
  hkern = element ns1:hkern { attlist.hkern, SVG.hkern.content }
  # end of SVG.hkern.element
  attlist.hkern &=
    SVG.Core.attrib,
    attribute u1 { text }?,
    attribute g1 { text }?,
    attribute u2 { text }?,
    attribute g2 { text }?,
    attribute k { Number.datatype }
  # end of SVG.hkern.attlist
  
  # vkern: Vertical Kerning Element ...................
  SVG.vkern.content = empty
  vkern = element ns1:vkern { attlist.vkern, SVG.vkern.content }
  # end of SVG.vkern.element
  attlist.vkern &=
    SVG.Core.attrib,
    attribute u1 { text }?,
    attribute g1 { text }?,
    attribute u2 { text }?,
    attribute g2 { text }?,
    attribute k { Number.datatype }
  # end of SVG.vkern.attlist
  
  # font-face-src: Font Face Source Element ...........
  SVG.font-face-src.extra.content = notAllowed
  SVG.font-face-src.content =
    (font-face-uri | font-face-name | SVG.font-face-src.extra.content)+
  font-face-src =
    element ns1:font-face-src {
      attlist.font-face-src, SVG.font-face-src.content
    }
  # end of SVG.font-face-src.element
  attlist.font-face-src &= SVG.Core.attrib
  # end of SVG.font-face-src.attlist
  
  # font-face-uri: Font Face URI Element ..............
  SVG.font-face-uri.extra.content = notAllowed
  SVG.font-face-uri.content =
    (font-face-format | SVG.font-face-uri.extra.content)*
  font-face-uri =
    element ns1:font-face-uri {
      attlist.font-face-uri, SVG.font-face-uri.content
    }
  # end of SVG.font-face-uri.element
  attlist.font-face-uri &= SVG.Core.attrib, SVG.XLinkRequired.attrib
  # end of SVG.font-face-uri.attlist
  
  # font-face-format: Font Face Format Element ........
  SVG.font-face-format.content = empty
  font-face-format =
    element ns1:font-face-format {
      attlist.font-face-format, SVG.font-face-format.content
    }
  # end of SVG.font-face-format.element
  attlist.font-face-format &=
    SVG.Core.attrib,
    attribute string { text }?
  # end of SVG.font-face-format.attlist
  
  # font-face-name: Font Face Name Element ............
  SVG.font-face-name.content = empty
  font-face-name =
    element ns1:font-face-name {
      attlist.font-face-name, SVG.font-face-name.content
    }
  # end of SVG.font-face-name.element
  attlist.font-face-name &=
    SVG.Core.attrib,
    attribute name { text }?
  # end of SVG.font-face-name.attlist
  
  # definition-src: Definition Source Element .........
  SVG.definition-src.content = empty
  definition-src =
    element ns1:definition-src {
      attlist.definition-src, SVG.definition-src.content
    }
  # end of SVG.definition-src.element
  attlist.definition-src &= SVG.Core.attrib, SVG.XLinkRequired.attrib
  # end of SVG.definition-src.attlist
  
  # end of svg-font.mod
  
  # Extensibility Module ........................................
  
  # .......................................................................
  
  # SVG 1.1 Extensibility Module ..........................................
  
  # file: svg-extensibility.mod
  # 
  # This is SVG, a language for describing two-dimensional graphics in XML.
  # Copyright 2001, 2002 W3C (MIT, INRIA, Keio), All Rights Reserved.
  # Revision: $Id: svg-extensibility.mod,v 1.4 2002/11/14 15:11:02 fujisawa Exp $
  # 
  # This DTD module is identified by the PUBLIC and SYSTEM identifiers:
  # 
  #    PUBLIC "-//W3C//ELEMENTS SVG 1.1 Extensibility//EN"
  #    SYSTEM "http://www.w3.org/Graphics/SVG/1.1/DTD/svg-extensibility.mod"
  # 
  # .......................................................................
  
  # Extensibility
  # 
  #    foreignObject
  # 
  # This module declares markup to provide support for extensibility.
  
  # Qualified Names (Default) .........................
  
  # Attribute Collections (Default) ...................
  
  # SVG.Extensibility.class ...........................
  
  # SVG.Presentation.attrib ...........................
  
  # foreignObject: Foreign Object Element .............
  SVG.foreignObject.extra.content = notAllowed
  SVG.foreignObject.content = (text | SVG.foreignObject.extra.content)*
  foreignObject =
    element ns1:foreignObject {
      attlist.foreignObject, SVG.foreignObject.content
    }
  # end of SVG.foreignObject.element
  attlist.foreignObject &=
    SVG.Core.attrib,
    SVG.Conditional.attrib,
    SVG.Style.attrib,
    SVG.Presentation.attrib,
    SVG.GraphicalEvents.attrib,
    SVG.External.attrib,
    attribute x { Coordinate.datatype }?,
    attribute y { Coordinate.datatype }?,
    attribute width { Length.datatype },
    attribute height { Length.datatype },
    attribute transform { TransformList.datatype }?
  tei_model.graphicLike |= svg
}
tei_data.certainty = "high" | "medium" | "low" | "unknown"
tei_data.probability =
  xsd:double { minInclusive = "0" maxInclusive = "1" }
tei_data.numeric = xsd:double | xsd:decimal
tei_data.count = xsd:nonNegativeInteger
tei_data.temporal =
  xsd:date
  | xsd:gYear
  | xsd:gMonth
  | xsd:gDay
  | xsd:gYearMonth
  | xsd:gMonthDay
  | xsd:time
  | xsd:dateTime
  | xsd:token {
      pattern =
        "(-?[0-9]{4}-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])T)?([01][0-9]|2[0-3])(:[0-5][0-9])?(Z|[+\-]((0[0-9]|1[0-3]):[0-5][0-9]|14:00))?"
    }
tei_data.duration = xsd:duration
tei_data.truthValue = xsd:boolean
tei_data.xTruthValue = xsd:boolean | "unknown" | "inapplicable"
tei_data.language = xsd:language
tei_data.sex = "0" | "1" | "2" | "9"
tei_data.namespace = xsd:anyURI
tei_data.outputMeasurement =
  xsd:token {
    pattern =
      "[\-+]?\d+(\.\d+)?(%|cm|mm|in|pt|pc|px|em|ex|gd|rem|vw|vh|vm)"
  }
tei_data.pattern = xsd:token
tei_data.pointer = xsd:anyURI
tei_data.code = xsd:anyURI
tei_data.enumerated = xsd:token
tei_data.key = xsd:string
tei_data.word = xsd:token { pattern = "(\p{L}|\p{N}|\p{P}|\p{S})+" }
tei_data.name = xsd:Name
tei_macro.component = tei_model.common
tei_macro.componentSeq = (tei_macro.component | tei_model.global)*
tei_macro.paraContent =
  (text
   | tei_model.gLike
   | tei_model.phrase
   | tei_model.inter
   | tei_model.global)*
tei_macro.phraseSeq =
  (text | tei_model.gLike | tei_model.phrase | tei_model.global)*
tei_macro.specialPara =
  (text
   | tei_model.gLike
   | tei_model.phrase
   | tei_model.inter
   | tei_model.divPart
   | tei_model.global)*
tei_macro.xtext = (text | tei_model.gLike)*
tei_macro.fileDescPart =
  tei_titleStmt,
  tei_editionStmt?,
  tei_extent?,
  tei_publicationStmt,
  tei_seriesStmt?,
  tei_notesStmt?
tei_macro.glossSeq = tei_altIdent?, tei_equiv*, tei_gloss*, tei_desc*
tei_att.ascribed.attributes = att.ascribed.attribute.who, empty
att.ascribed.attribute.who =
  
  ## indicates the person, or group of
  ##	people, to whom the element content is ascribed.
  attribute who {
    list { tei_data.pointer+ }
  }?
tei_att.authorialIntervention.attributes =
  att.authorialIntervention.attribute.hand,
  att.authorialIntervention.attribute.status,
  att.authorialIntervention.attribute.type,
  empty
att.authorialIntervention.attribute.hand =
  
  ## signifies the hand of the agent which made the addition or
  ##       performed the deletion.
  attribute hand { tei_data.pointer }?
att.authorialIntervention.attribute.status =
  
  ## may be used to indicate faulty deletions, e.g. strikeouts
  ##       which include too much or too little text, or erroneous
  ##       additions, e.g., an insertion which duplicates some of the text
  ##       already present.
  ## Sample values include: 1] duplicate (all of the text indicated as an addition duplicates
  ##	  some text that is in the original, whether the duplication
  ##	  is word-for-word or less exact.); 2] duplicate-partial (part of the text indicated as an addition duplicates
  ##	  some text that is in the original); 3] excessStart (some text at the beginning of the deletion is marked
  ##           as deleted even though it clearly should not be
  ##           deleted.); 4] excessEnd (some text at the end of the deletion is marked as
  ##           deleted even though it clearly should not be
  ##           deleted.); 5] shortStart (some text at the beginning of the deletion is not
  ##           marked as deleted even though it clearly should be.); 6] shortEnd (some text at the end of the deletion is not marked as
  ##           deleted even though it clearly should be.); 7] unremarkable (the deletion is not faulty.)
  [ a1:defaultValue = "unremarkable" ]
  attribute status { tei_data.enumerated }?
att.authorialIntervention.attribute.type =
  
  ## classifies the type of addition or deletion using any convenient typology.
  attribute type { tei_data.enumerated }?
tei_att.datable.attributes =
  att.datable.attribute.notBefore,
  att.datable.attribute.notAfter,
  att.datable.attribute.from,
  att.datable.attribute.to,
  empty
att.datable.attribute.notBefore =
  
  ## specifies the earliest possible date for the event in
  ##	standard form, e.g. yyyy-mm-dd.
  attribute notBefore { tei_data.temporal }?
att.datable.attribute.notAfter =
  
  ## specifies the latest possible date for the event in
  ##	standard form, e.g. yyyy-mm-dd.
  attribute notAfter { tei_data.temporal }?
att.datable.attribute.from =
  
  ## indicates the starting point of the period in standard form.
  attribute from { tei_data.temporal }?
att.datable.attribute.to =
  
  ## indicates the ending point of the period in standard form.
  attribute to { tei_data.temporal }?
tei_att.datePart.attributes =
  att.datePart.attribute.value, att.datePart.attribute.dur, empty
att.datePart.attribute.value =
  
  ## supplies the value of a date or time in a standard form.
  attribute value { tei_data.temporal }?
att.datePart.attribute.dur =
  
  ## (duration) indicates the length of this element in time.
  attribute dur { xsd:duration }?
tei_att.declarable.attributes = att.declarable.attribute.default, empty
att.declarable.attribute.default =
  
  ## indicates whether or not this element is selected by default when
  ## its parent is selected.
  [ a1:defaultValue = "false" ]
  attribute default {
    
    ## (This element is selected if its parent is selected) 
    "true"
    | 
      ## (This element can only be selected explicitly, unless it is the
      ## only one of its kind, in which case it is selected if its parent is selected.) 
      "false"
  }?
tei_att.declaring.attributes = att.declaring.attribute.decls, empty
att.declaring.attribute.decls =
  
  ## identifies one or more declarable elements within the
  ## header, which are understood to apply to the element bearing this
  ## attribute and its content.
  attribute decls {
    list { tei_data.pointer+ }
  }?
tei_att.divLike.attributes =
  att.divLike.attribute.type,
  att.divLike.attribute.org,
  att.divLike.attribute.sample,
  att.divLike.attribute.part,
  empty
att.divLike.attribute.type =
  
  ## specifies a name conventionally used for this level of
  ##		subdivision, e.g. act, volume, book,
  ##		section, canto, etc.
  attribute type { tei_data.enumerated }?
att.divLike.attribute.org =
  
  ## specifies how the content of the division is organized.
  [ a1:defaultValue = "uniform" ]
  attribute org {
    
    ## (composite content: i.e. no claim is made about the
    ##		  sequence in which the immediate contents of this division
    ##		  are to be processed, or their inter-relationships.) 
    "composite"
    | 
      ## (uniform content: i.e. the immediate contents of this
      ##		  element are regarded as forming a logical unit, to be
      ##		  processed in sequence.) 
      "uniform"
  }?
att.divLike.attribute.sample =
  
  ## indicates whether this division is a sample of the
  ##		original source and if so, from which part.
  [ a1:defaultValue = "complete" ]
  attribute sample {
    
    ## (division lacks material present at end in source.) 
    "initial"
    | 
      ## (division lacks material at start and end.) 
      "medial"
    | 
      ## (division lacks material at start.) 
      "final"
    | 
      ## (position of sampled material within original unknown.) 
      "unknown"
    | 
      ## (division is not a sample.) 
      "complete"
  }?
att.divLike.attribute.part =
  
  ## specifies whether or not the division is fragmented by
  ##		some other structural element, for example a speech which is
  ##		divided between two or more verse stanzas.
  [ a1:defaultValue = "N" ]
  attribute part {
    
    ## (the division is incomplete in some respect) 
    "Y"
    | 
      ## (either the division is complete, or no claim is made as to its completeness.) 
      "N"
    | 
      ## (the initial part of an incomplete division) 
      "I"
    | 
      ## (a medial part of an incomplete division) 
      "M"
    | 
      ## (the final part of an incomplete division) 
      "F"
  }?
tei_att.interpLike.attributes =
  att.interpLike.attribute.resp,
  att.interpLike.attribute.type,
  att.interpLike.attribute.inst,
  empty
att.interpLike.attribute.resp =
  
  ## indicates who is responsible for the interpretation.
  attribute resp { tei_data.pointer }?
att.interpLike.attribute.type =
  
  ## indicates what kind of phenomenon is being noted in the passage.
  ## Sample values include: 1] image (identifies an image in the passage.
  ##    ); 2] character (identifies a character associated with the passage.
  ##    ); 3] theme (identifies a theme in the passage.
  ##    ); 4] allusion (identifies an allusion to another text.
  ##    )
  attribute type { tei_data.enumerated }?
att.interpLike.attribute.inst =
  
  ## points to instances of the analysis or interpretation represented
  ## by the current element.
  attribute inst {
    list { tei_data.pointer+ }
  }?
tei_att.editLike.attributes =
  att.editLike.attribute.cert,
  att.editLike.attribute.resp,
  att.editLike.attribute.evidence,
  empty
att.editLike.attribute.cert =
  
  ## signifies the degree of certainty associated with the
  ##	intervention or interpretation.
  attribute cert { tei_data.enumerated }?
att.editLike.attribute.resp =
  
  ## indicates the agency responsible for the
  ##	intervention or interpretation, for example an editor or transcriber.
  attribute resp { tei_data.pointer }?
att.editLike.attribute.evidence =
  
  ## indicates the nature of the evidence supporting the reliability or
  ##   accuracy of the intervention or interpretation.
  ## Sample values include: 1] internal (there is internal evidence to support the intervention.); 2] external (there is external evidence to support the intervention.); 3] conjecture (the intervention or interpretation has been made by
  ##	  the editor, cataloguer, or scholar on the basis of their expertise.)
  attribute evidence { tei_data.enumerated }?
tei_att.global.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  empty
att.global.attribute.xmlspace =
  
  ## signals an intention that white space should be 
  ##       preserved by applications
  attribute xml:space {
    
    ##
    "default"
    | 
      ##
      "preserve"
  }?
att.global.attribute.xmlid =
  
  ## provides a unique identifier for the element bearing the
  ##       attribute.
  attribute xml:id { xsd:ID }?
att.global.attribute.n =
  
  ## gives a number (or other label) for an element, which is
  ##       not necessarily unique within the document.
  attribute n {
    list { tei_data.word+ }
  }?
att.global.attribute.xmllang =
  
  ## indicates the language of the element content using the
  ##       codes from RFC
  ##       3066
  attribute xml:lang { tei_data.language }?
att.global.attribute.rend =
  
  ## indicates how the element in question was rendered or
  ##	presented in the source text.
  attribute rend {
    list { tei_data.word+ }
  }?
att.global.attribute.xmlbase =
  
  ## provides a base URI reference with which applications can
  ##       resolve relative URI references into absolute URI
  ##       references.
  attribute xml:base { tei_data.pointer }?
tei_att.measured.attributes =
  att.measured.attribute.unit, att.measured.attribute.scope, empty
att.measured.attribute.unit =
  
  ## names the units used for the measurement.
  ## Suggested values include: 1] cm (centimetres); 2] mm (millimetres); 3] in (inches)
  attribute unit { tei_data.enumerated }?
att.measured.attribute.scope =
  
  ## specifies the applicability of this measurement, where
  ##    more than one object is being measured.
  ## Sample values include: 1] all (measurement applies to all instances.); 2] most (measurement applies to most of the instances inspected.); 3] range (measurement applies to only the specified range of instances.)
  attribute scope { tei_data.enumerated }?
tei_att.measurement.attributes =
  att.measurement.attribute.unit,
  att.measurement.attribute.quantity,
  att.measurement.attribute.commodity,
  empty
att.measurement.attribute.unit =
  
  ## indicates the units used for the measurement, usually
  ##       using the standard symbol for the desired units.
  ## Suggested values include: 1] m (metre); 2] kg (kilogram); 3] s (second); 4] Hz (hertz); 5] Pa (pascal); 6] Ω (ohm); 7] L (litre); 8] t (tonne); 9] ha (hectare); 10] Å (ångström); 11] mL (millilitre); 12] cm (centimetre); 13] dB (decibel); 14] kbit (kilobit); 15] Kibit (kibibit); 16] kB (kilobyte); 17] KiB (kibibyte); 18] MB (megabyte); 19] MiB (mebibyte)
  attribute unit { tei_data.enumerated }?
att.measurement.attribute.quantity =
  
  ## specifies the number of the specified units that
  ##       comprise the measurement
  attribute quantity { tei_data.numeric }?
att.measurement.attribute.commodity =
  
  ## indicates the substance that is being measured
  attribute commodity {
    list { tei_data.word+ }
  }?
tei_att.naming.attributes = att.naming.attribute.key, empty
att.naming.attribute.key =
  
  ## provides a means of locating a full definition for the
  ##       entity being named such as a database record key or a
  ##       URI.
  attribute key { tei_data.key }?
tei_att.placement.attributes = att.placement.attribute.place, empty
att.placement.attribute.place =
  
  ## 
  ## Suggested values include: 1] infralinear (below the line); 2] margin-bot (in bottom margin); 3] margin-left (in left margin); 4] margin-right (in right margin); 5] margin-top (in top margin); 6] opposite (on opposite page); 7] overleaf (on the other side of the leaf); 8] supralinear (above the line); 9] verso (on verso of sheet); 10] app (note appears in the apparatus at the foot of the page.); 11] end (note appears at end of chapter or volume.); 12] foot (note appears at foot of page.); 13] inline (note appears as a marked paragraph in the body of the text.); 14] interlinear (note appears between lines of the text; a less precise form of either infralinear or supralinear.); 15] inline (addition is made in a space left in the witness by an earlier scribe.); 16] mixed (one or more of the other values)
  attribute place { tei_data.enumerated }?
tei_att.segLike.attributes =
  att.segLike.attribute.type,
  att.segLike.attribute.function,
  att.segLike.attribute.part,
  empty
att.segLike.attribute.type =
  
  ## characterizes the type of segment.
  attribute type { tei_data.enumerated }?
att.segLike.attribute.function =
  
  ## characterizes the function of the segment.
  attribute function { tei_data.enumerated }?
att.segLike.attribute.part =
  
  ## specifies whether or not the segment is fragmented by some other
  ## structural element, for example a clause which is divided between two
  ## or more sentences.
  [ a1:defaultValue = "N" ]
  attribute part {
    
    ## (the segment is incomplete in some respect) 
    "Y"
    | 
      ## (either the segment is complete, or no claim is made as to
      ## its completeness) 
      "N"
    | 
      ## (the initial part of an incomplete segment) 
      "I"
    | 
      ## (a medial part of an incomplete segment) 
      "M"
    | 
      ## (the final part of an incomplete segment) 
      "F"
  }?
tei_att.spanning.attributes = att.spanning.attribute.spanTo, empty
att.spanning.attribute.spanTo =
  
  ## indicates the end of a span initiated by the element
  ##	bearing this attribute.
  attribute spanTo { tei_data.pointer }?
tei_att.tableDecoration.attributes =
  att.tableDecoration.attribute.role,
  att.tableDecoration.attribute.rows,
  att.tableDecoration.attribute.cols,
  empty
att.tableDecoration.attribute.role =
  
  ## indicates the kind of information held in this cell or
  ## in each cell of this row.
  ## Suggested values include: 1] label (labelling or descriptive information only.); 2] data (data values.)
  [ a1:defaultValue = "data" ] attribute role { tei_data.enumerated }?
att.tableDecoration.attribute.rows =
  
  ## indicates the number of rows occupied by this cell or row.
  [ a1:defaultValue = "1" ] attribute rows { tei_data.count }?
att.tableDecoration.attribute.cols =
  
  ## indicates the number of columns occupied by this cell or
  ##	row.
  [ a1:defaultValue = "1" ] attribute cols { tei_data.count }?
tei_att.timed.attributes =
  att.timed.attribute.start,
  att.timed.attribute.end,
  att.timed.attribute.dur,
  empty
att.timed.attribute.start =
  
  ## indicates the location within a temporal alignment
  ##       at which this element begins.
  attribute start { tei_data.pointer }?
att.timed.attribute.end =
  
  ## indicates the location within a temporal alignment at which
  ##    this element ends.
  attribute end { tei_data.pointer }?
att.timed.attribute.dur =
  
  ## (duration) indicates the length of this element in time
  attribute dur { xsd:duration }?
tei_att.translatable.attributes =
  att.translatable.attribute.version, empty
att.translatable.attribute.version =
  
  ## specifies the version name or number of the source from
  ##	which the translated version was derived
  attribute version { tei_data.word }?
tei_att.typed.attributes =
  att.typed.attribute.type, att.typed.attribute.subtype, empty
att.typed.attribute.type =
  
  ## characterizes the element in some sense, using any convenient
  ##  classification scheme or typology.
  attribute type { tei_data.word }?
att.typed.attribute.subtype =
  
  ## provides a sub-categorization of the element, if needed
  attribute subtype { tei_data.word }?
tei_model.nameLike.agent = tei_name
tei_model.nameLike.agent_sequence = tei_name
tei_model.nameLike.agent_sequenceOptional = tei_name?
tei_model.nameLike.agent_sequenceOptionalRepeatable = tei_name*
tei_model.nameLike.agent_sequenceRepeatable = tei_name+
tei_model.segLike = notAllowed
tei_model.segLike_sequence = empty
tei_model.segLike_sequenceOptional = empty
tei_model.segLike_sequenceOptionalRepeatable = empty
tei_model.segLike_sequenceRepeatable = notAllowed
tei_model.hiLike =
  tei_foreign
  | tei_emph
  | tei_hi
  | tei_distinct
  | tei_mentioned
  | tei_soCalled
  | tei_gloss
  | tei_term
  | tei_title
tei_model.hiLike_sequence =
  tei_foreign,
  tei_emph,
  tei_hi,
  tei_distinct,
  tei_mentioned,
  tei_soCalled,
  tei_gloss,
  tei_term,
  tei_title
tei_model.hiLike_sequenceOptional =
  tei_foreign?,
  tei_emph?,
  tei_hi?,
  tei_distinct?,
  tei_mentioned?,
  tei_soCalled?,
  tei_gloss?,
  tei_term?,
  tei_title?
tei_model.hiLike_sequenceOptionalRepeatable =
  tei_foreign*,
  tei_emph*,
  tei_hi*,
  tei_distinct*,
  tei_mentioned*,
  tei_soCalled*,
  tei_gloss*,
  tei_term*,
  tei_title*
tei_model.hiLike_sequenceRepeatable =
  tei_foreign+,
  tei_emph+,
  tei_hi+,
  tei_distinct+,
  tei_mentioned+,
  tei_soCalled+,
  tei_gloss+,
  tei_term+,
  tei_title+
tei_model.dateLike = tei_date | tei_time
tei_model.dateLike_sequence = tei_date, tei_time
tei_model.dateLike_sequenceOptional = tei_date?, tei_time?
tei_model.dateLike_sequenceOptionalRepeatable = tei_date*, tei_time*
tei_model.dateLike_sequenceRepeatable = tei_date+, tei_time+
tei_model.measureLike = tei_num | tei_measure
tei_model.measureLike_sequence = tei_num, tei_measure
tei_model.measureLike_sequenceOptional = tei_num?, tei_measure?
tei_model.measureLike_sequenceOptionalRepeatable =
  tei_num*, tei_measure*
tei_model.measureLike_sequenceRepeatable = tei_num+, tei_measure+
tei_model.graphicLike = tei_graphic | tei_binaryObject | tei_formula
tei_model.graphicLike_sequence =
  tei_graphic, tei_binaryObject, tei_formula
tei_model.graphicLike_sequenceOptional =
  tei_graphic?, tei_binaryObject?, tei_formula?
tei_model.graphicLike_sequenceOptionalRepeatable =
  tei_graphic*, tei_binaryObject*, tei_formula*
tei_model.graphicLike_sequenceRepeatable =
  tei_graphic+, tei_binaryObject+, tei_formula+
tei_model.pPart.msdesc = notAllowed
tei_model.pPart.msdesc_sequence = empty
tei_model.pPart.msdesc_sequenceOptional = empty
tei_model.pPart.msdesc_sequenceOptionalRepeatable = empty
tei_model.pPart.msdesc_sequenceRepeatable = notAllowed
tei_model.pPart.edit =
  tei_sic
  | tei_corr
  | tei_choice
  | tei_reg
  | tei_orig
  | tei_add
  | tei_del
  | tei_unclear
  | tei_abbr
  | tei_expan
tei_model.pPart.edit_sequence =
  tei_sic,
  tei_corr,
  tei_choice,
  tei_reg,
  tei_orig,
  tei_add,
  tei_del,
  tei_unclear,
  tei_abbr,
  tei_expan
tei_model.pPart.edit_sequenceOptional =
  tei_sic?,
  tei_corr?,
  tei_choice?,
  tei_reg?,
  tei_orig?,
  tei_add?,
  tei_del?,
  tei_unclear?,
  tei_abbr?,
  tei_expan?
tei_model.pPart.edit_sequenceOptionalRepeatable =
  tei_sic*,
  tei_corr*,
  tei_choice*,
  tei_reg*,
  tei_orig*,
  tei_add*,
  tei_del*,
  tei_unclear*,
  tei_abbr*,
  tei_expan*
tei_model.pPart.edit_sequenceRepeatable =
  tei_sic+,
  tei_corr+,
  tei_choice+,
  tei_reg+,
  tei_orig+,
  tei_add+,
  tei_del+,
  tei_unclear+,
  tei_abbr+,
  tei_expan+
tei_model.ptrLike = tei_ptr | tei_ref
tei_model.ptrLike_sequence = tei_ptr, tei_ref
tei_model.ptrLike_sequenceOptional = tei_ptr?, tei_ref?
tei_model.ptrLike_sequenceOptionalRepeatable = tei_ptr*, tei_ref*
tei_model.ptrLike_sequenceRepeatable = tei_ptr+, tei_ref+
tei_model.lPart = notAllowed
tei_model.lPart_sequence = empty
tei_model.lPart_sequenceOptional = empty
tei_model.lPart_sequenceOptionalRepeatable = empty
tei_model.lPart_sequenceRepeatable = notAllowed
tei_model.global.meta = tei_index
tei_model.global.meta_sequence = tei_index
tei_model.global.meta_sequenceOptional = tei_index?
tei_model.global.meta_sequenceOptionalRepeatable = tei_index*
tei_model.global.meta_sequenceRepeatable = tei_index+
tei_model.milestoneLike = tei_milestone | tei_pb | tei_lb | tei_cb
tei_model.milestoneLike_sequence = tei_milestone, tei_pb, tei_lb, tei_cb
tei_model.milestoneLike_sequenceOptional =
  tei_milestone?, tei_pb?, tei_lb?, tei_cb?
tei_model.milestoneLike_sequenceOptionalRepeatable =
  tei_milestone*, tei_pb*, tei_lb*, tei_cb*
tei_model.milestoneLike_sequenceRepeatable =
  tei_milestone+, tei_pb+, tei_lb+, tei_cb+
tei_model.gLike = notAllowed
tei_model.gLike_sequence = empty
tei_model.gLike_sequenceOptional = empty
tei_model.gLike_sequenceOptionalRepeatable = empty
tei_model.gLike_sequenceRepeatable = notAllowed
tei_model.oddDecl = notAllowed
tei_model.oddDecl_sequence = empty
tei_model.oddDecl_sequenceOptional = empty
tei_model.oddDecl_sequenceOptionalRepeatable = empty
tei_model.oddDecl_sequenceRepeatable = notAllowed
tei_model.oddRef = notAllowed
tei_model.oddRef_sequence = empty
tei_model.oddRef_sequenceOptional = empty
tei_model.oddRef_sequenceOptionalRepeatable = empty
tei_model.oddRef_sequenceRepeatable = notAllowed
tei_model.oddPhr = notAllowed
tei_model.oddPhr_sequence = empty
tei_model.oddPhr_sequenceOptional = empty
tei_model.oddPhr_sequenceOptionalRepeatable = empty
tei_model.oddPhr_sequenceRepeatable = notAllowed
tei_model.qLike = tei_q | tei_quote | tei_cit
tei_model.qLike_sequence = tei_q, tei_quote, tei_cit
tei_model.qLike_sequenceOptional = tei_q?, tei_quote?, tei_cit?
tei_model.qLike_sequenceOptionalRepeatable =
  tei_q*, tei_quote*, tei_cit*
tei_model.qLike_sequenceRepeatable = tei_q+, tei_quote+, tei_cit+
tei_model.biblLike =
  tei_bibl | tei_biblItem | tei_biblStruct | tei_biblFull
tei_model.biblLike_sequence =
  tei_bibl, tei_biblItem, tei_biblStruct, tei_biblFull
tei_model.biblLike_sequenceOptional =
  tei_bibl?, tei_biblItem?, tei_biblStruct?, tei_biblFull?
tei_model.biblLike_sequenceOptionalRepeatable =
  tei_bibl*, tei_biblItem*, tei_biblStruct*, tei_biblFull*
tei_model.biblLike_sequenceRepeatable =
  tei_bibl+, tei_biblItem+, tei_biblStruct+, tei_biblFull+
tei_model.listLike = tei_list | tei_listBibl
tei_model.listLike_sequence = tei_list, tei_listBibl
tei_model.listLike_sequenceOptional = tei_list?, tei_listBibl?
tei_model.listLike_sequenceOptionalRepeatable = tei_list*, tei_listBibl*
tei_model.listLike_sequenceRepeatable = tei_list+, tei_listBibl+
tei_model.noteLike = tei_note
tei_model.noteLike_sequence = tei_note
tei_model.noteLike_sequenceOptional = tei_note?
tei_model.noteLike_sequenceOptionalRepeatable = tei_note*
tei_model.noteLike_sequenceRepeatable = tei_note+
tei_model.stageLike = tei_stage
tei_model.stageLike_sequence = tei_stage
tei_model.stageLike_sequenceOptional = tei_stage?
tei_model.stageLike_sequenceOptionalRepeatable = tei_stage*
tei_model.stageLike_sequenceRepeatable = tei_stage+
tei_model.complexVal = notAllowed
tei_model.complexVal_sequence = empty
tei_model.complexVal_sequenceOptional = empty
tei_model.complexVal_sequenceOptionalRepeatable = empty
tei_model.complexVal_sequenceRepeatable = notAllowed
tei_model.singleVal = notAllowed
tei_model.singleVal_sequence = empty
tei_model.singleVal_sequenceOptional = empty
tei_model.singleVal_sequenceOptionalRepeatable = empty
tei_model.singleVal_sequenceRepeatable = notAllowed
tei_model.entryParts.top = notAllowed
tei_model.entryParts.top_sequence = empty
tei_model.entryParts.top_sequenceOptional = empty
tei_model.entryParts.top_sequenceOptionalRepeatable = empty
tei_model.entryParts.top_sequenceRepeatable = notAllowed
tei_model.global.edit = tei_gap
tei_model.global.edit_sequence = tei_gap
tei_model.global.edit_sequenceOptional = tei_gap?
tei_model.global.edit_sequenceOptionalRepeatable = tei_gap*
tei_model.global.edit_sequenceRepeatable = tei_gap+
tei_model.divPart = tei_p | tei_l | tei_lg | tei_sp
tei_model.divPart_sequence = tei_p, tei_l, tei_lg, tei_sp
tei_model.divPart_sequenceOptional = tei_p?, tei_l?, tei_lg?, tei_sp?
tei_model.divPart_sequenceOptionalRepeatable =
  tei_p*, tei_l*, tei_lg*, tei_sp*
tei_model.divPart_sequenceRepeatable = tei_p+, tei_l+, tei_lg+, tei_sp+
tei_model.blockLike = notAllowed
tei_model.blockLike_sequence = empty
tei_model.blockLike_sequenceOptional = empty
tei_model.blockLike_sequenceOptionalRepeatable = empty
tei_model.blockLike_sequenceRepeatable = notAllowed
tei_model.pLike = tei_p
tei_model.pLike_sequence = tei_p
tei_model.pLike_sequenceOptional = tei_p?
tei_model.pLike_sequenceOptionalRepeatable = tei_p*
tei_model.pLike_sequenceRepeatable = tei_p+
tei_model.persTraitLike = notAllowed
tei_model.persTraitLike_sequence = empty
tei_model.persTraitLike_sequenceOptional = empty
tei_model.persTraitLike_sequenceOptionalRepeatable = empty
tei_model.persTraitLike_sequenceRepeatable = notAllowed
tei_model.persStateLike = notAllowed
tei_model.persStateLike_sequence = empty
tei_model.persStateLike_sequenceOptional = empty
tei_model.persStateLike_sequenceOptionalRepeatable = empty
tei_model.persStateLike_sequenceRepeatable = notAllowed
tei_model.persEventLike = notAllowed
tei_model.persEventLike_sequence = empty
tei_model.persEventLike_sequenceOptional = empty
tei_model.persEventLike_sequenceOptionalRepeatable = empty
tei_model.persEventLike_sequenceRepeatable = notAllowed
tei_model.assertLike =
  tei_model.persTraitLike
  | tei_model.persStateLike
  | tei_model.persEventLike
tei_model.assertLike_sequence =
  tei_model.persTraitLike,
  tei_model.persStateLike,
  tei_model.persEventLike
tei_model.assertLike_sequenceOptional =
  tei_model.persTraitLike?,
  tei_model.persStateLike?,
  tei_model.persEventLike?
tei_model.assertLike_sequenceOptionalRepeatable =
  tei_model.persTraitLike*,
  tei_model.persStateLike*,
  tei_model.persEventLike*
tei_model.assertLike_sequenceRepeatable =
  tei_model.persTraitLike+,
  tei_model.persStateLike+,
  tei_model.persEventLike+
tei_model.personLike = notAllowed
tei_model.personLike_sequence = empty
tei_model.personLike_sequenceOptional = empty
tei_model.personLike_sequenceOptionalRepeatable = empty
tei_model.personLike_sequenceRepeatable = notAllowed
tei_model.personPart = tei_model.assertLike | tei_bibl
tei_model.personPart_sequence = tei_model.assertLike, tei_bibl
tei_model.personPart_sequenceOptional = tei_model.assertLike?, tei_bibl?
tei_model.personPart_sequenceOptionalRepeatable =
  tei_model.assertLike*, tei_bibl*
tei_model.personPart_sequenceRepeatable =
  tei_model.assertLike+, tei_bibl+
tei_model.publicationStmtPart =
  tei_address
  | tei_date
  | tei_publisher
  | tei_pubPlace
  | tei_distributor
  | tei_authority
  | tei_idno
  | tei_availability
tei_model.publicationStmtPart_sequence =
  tei_address,
  tei_date,
  tei_publisher,
  tei_pubPlace,
  tei_distributor,
  tei_authority,
  tei_idno,
  tei_availability
tei_model.publicationStmtPart_sequenceOptional =
  tei_address?,
  tei_date?,
  tei_publisher?,
  tei_pubPlace?,
  tei_distributor?,
  tei_authority?,
  tei_idno?,
  tei_availability?
tei_model.publicationStmtPart_sequenceOptionalRepeatable =
  tei_address*,
  tei_date*,
  tei_publisher*,
  tei_pubPlace*,
  tei_distributor*,
  tei_authority*,
  tei_idno*,
  tei_availability*
tei_model.publicationStmtPart_sequenceRepeatable =
  tei_address+,
  tei_date+,
  tei_publisher+,
  tei_pubPlace+,
  tei_distributor+,
  tei_authority+,
  tei_idno+,
  tei_availability+
tei_model.glossLike = tei_altIdent | tei_desc | tei_equiv | tei_gloss
tei_model.glossLike_sequence =
  tei_altIdent, tei_desc, tei_equiv, tei_gloss
tei_model.glossLike_sequenceOptional =
  tei_altIdent?, tei_desc?, tei_equiv?, tei_gloss?
tei_model.glossLike_sequenceOptionalRepeatable =
  tei_altIdent*, tei_desc*, tei_equiv*, tei_gloss*
tei_model.glossLike_sequenceRepeatable =
  tei_altIdent+, tei_desc+, tei_equiv+, tei_gloss+
tei_model.quoteLike = tei_quote
tei_model.quoteLike_sequence = tei_quote
tei_model.quoteLike_sequenceOptional = tei_quote?
tei_model.quoteLike_sequenceOptionalRepeatable = tei_quote*
tei_model.quoteLike_sequenceRepeatable = tei_quote+
tei_model.respLike = tei_author | tei_editor | tei_respStmt
tei_model.respLike_sequence = tei_author, tei_editor, tei_respStmt
tei_model.respLike_sequenceOptional =
  tei_author?, tei_editor?, tei_respStmt?
tei_model.respLike_sequenceOptionalRepeatable =
  tei_author*, tei_editor*, tei_respStmt*
tei_model.respLike_sequenceRepeatable =
  tei_author+, tei_editor+, tei_respStmt+
tei_model.divWrapper.bottom = tei_trailer | tei_closer | tei_signed
tei_model.divWrapper.bottom_sequence =
  tei_trailer, tei_closer, tei_signed
tei_model.divWrapper.bottom_sequenceOptional =
  tei_trailer?, tei_closer?, tei_signed?
tei_model.divWrapper.bottom_sequenceOptionalRepeatable =
  tei_trailer*, tei_closer*, tei_signed*
tei_model.divWrapper.bottom_sequenceRepeatable =
  tei_trailer+, tei_closer+, tei_signed+
tei_model.divWrapper =
  tei_head
  | tei_byline
  | tei_dateline
  | tei_argument
  | tei_epigraph
  | tei_opener
  | tei_salute
  | tei_docAuthor
  | tei_docDate
tei_model.divWrapper_sequence =
  tei_head,
  tei_byline,
  tei_dateline,
  tei_argument,
  tei_epigraph,
  tei_opener,
  tei_salute,
  tei_docAuthor,
  tei_docDate
tei_model.divWrapper_sequenceOptional =
  tei_head?,
  tei_byline?,
  tei_dateline?,
  tei_argument?,
  tei_epigraph?,
  tei_opener?,
  tei_salute?,
  tei_docAuthor?,
  tei_docDate?
tei_model.divWrapper_sequenceOptionalRepeatable =
  tei_head*,
  tei_byline*,
  tei_dateline*,
  tei_argument*,
  tei_epigraph*,
  tei_opener*,
  tei_salute*,
  tei_docAuthor*,
  tei_docDate*
tei_model.divWrapper_sequenceRepeatable =
  tei_head+,
  tei_byline+,
  tei_dateline+,
  tei_argument+,
  tei_epigraph+,
  tei_opener+,
  tei_salute+,
  tei_docAuthor+,
  tei_docDate+
tei_model.frontPart.drama = notAllowed
tei_model.frontPart.drama_sequence = empty
tei_model.frontPart.drama_sequenceOptional = empty
tei_model.frontPart.drama_sequenceOptionalRepeatable = empty
tei_model.frontPart.drama_sequenceRepeatable = notAllowed
tei_model.pLike.front =
  tei_head
  | tei_byline
  | tei_argument
  | tei_epigraph
  | tei_docTitle
  | tei_titlePart
  | tei_docAuthor
  | tei_docEdition
  | tei_docImprint
  | tei_docDate
tei_model.pLike.front_sequence =
  tei_head,
  tei_byline,
  tei_argument,
  tei_epigraph,
  tei_docTitle,
  tei_titlePart,
  tei_docAuthor,
  tei_docEdition,
  tei_docImprint,
  tei_docDate
tei_model.pLike.front_sequenceOptional =
  tei_head?,
  tei_byline?,
  tei_argument?,
  tei_epigraph?,
  tei_docTitle?,
  tei_titlePart?,
  tei_docAuthor?,
  tei_docEdition?,
  tei_docImprint?,
  tei_docDate?
tei_model.pLike.front_sequenceOptionalRepeatable =
  tei_head*,
  tei_byline*,
  tei_argument*,
  tei_epigraph*,
  tei_docTitle*,
  tei_titlePart*,
  tei_docAuthor*,
  tei_docEdition*,
  tei_docImprint*,
  tei_docDate*
tei_model.pLike.front_sequenceRepeatable =
  tei_head+,
  tei_byline+,
  tei_argument+,
  tei_epigraph+,
  tei_docTitle+,
  tei_titlePart+,
  tei_docAuthor+,
  tei_docEdition+,
  tei_docImprint+,
  tei_docDate+
tei_model.titlepagePart =
  tei_graphic
  | tei_binaryObject
  | tei_byline
  | tei_epigraph
  | tei_docTitle
  | tei_titlePart
  | tei_docAuthor
  | tei_imprimatur
  | tei_docEdition
  | tei_docImprint
  | tei_docDate
  | tei_figure
tei_model.titlepagePart_sequence =
  tei_graphic,
  tei_binaryObject,
  tei_byline,
  tei_epigraph,
  tei_docTitle,
  tei_titlePart,
  tei_docAuthor,
  tei_imprimatur,
  tei_docEdition,
  tei_docImprint,
  tei_docDate,
  tei_figure
tei_model.titlepagePart_sequenceOptional =
  tei_graphic?,
  tei_binaryObject?,
  tei_byline?,
  tei_epigraph?,
  tei_docTitle?,
  tei_titlePart?,
  tei_docAuthor?,
  tei_imprimatur?,
  tei_docEdition?,
  tei_docImprint?,
  tei_docDate?,
  tei_figure?
tei_model.titlepagePart_sequenceOptionalRepeatable =
  tei_graphic*,
  tei_binaryObject*,
  tei_byline*,
  tei_epigraph*,
  tei_docTitle*,
  tei_titlePart*,
  tei_docAuthor*,
  tei_imprimatur*,
  tei_docEdition*,
  tei_docImprint*,
  tei_docDate*,
  tei_figure*
tei_model.titlepagePart_sequenceRepeatable =
  tei_graphic+,
  tei_binaryObject+,
  tei_byline+,
  tei_epigraph+,
  tei_docTitle+,
  tei_titlePart+,
  tei_docAuthor+,
  tei_imprimatur+,
  tei_docEdition+,
  tei_docImprint+,
  tei_docDate+,
  tei_figure+
tei_model.msItemPart =
  tei_model.quoteLike
  | tei_model.respLike
  | tei_bibl
  | tei_listBibl
  | tei_title
tei_model.msItemPart_sequence =
  tei_model.quoteLike,
  tei_model.respLike,
  tei_bibl,
  tei_listBibl,
  tei_title
tei_model.msItemPart_sequenceOptional =
  tei_model.quoteLike?,
  tei_model.respLike?,
  tei_bibl?,
  tei_listBibl?,
  tei_title?
tei_model.msItemPart_sequenceOptionalRepeatable =
  tei_model.quoteLike*,
  tei_model.respLike*,
  tei_bibl*,
  tei_listBibl*,
  tei_title*
tei_model.msItemPart_sequenceRepeatable =
  tei_model.quoteLike+,
  tei_model.respLike+,
  tei_bibl+,
  tei_listBibl+,
  tei_title+
tei_model.choicePart =
  tei_sic
  | tei_corr
  | tei_reg
  | tei_orig
  | tei_unclear
  | tei_abbr
  | tei_expan
tei_model.choicePart_sequence =
  tei_sic, tei_corr, tei_reg, tei_orig, tei_unclear, tei_abbr, tei_expan
tei_model.choicePart_sequenceOptional =
  tei_sic?,
  tei_corr?,
  tei_reg?,
  tei_orig?,
  tei_unclear?,
  tei_abbr?,
  tei_expan?
tei_model.choicePart_sequenceOptionalRepeatable =
  tei_sic*,
  tei_corr*,
  tei_reg*,
  tei_orig*,
  tei_unclear*,
  tei_abbr*,
  tei_expan*
tei_model.choicePart_sequenceRepeatable =
  tei_sic+,
  tei_corr+,
  tei_reg+,
  tei_orig+,
  tei_unclear+,
  tei_abbr+,
  tei_expan+
tei_model.lLike = tei_l
tei_model.lLike_sequence = tei_l
tei_model.lLike_sequenceOptional = tei_l?
tei_model.lLike_sequenceOptionalRepeatable = tei_l*
tei_model.lLike_sequenceRepeatable = tei_l+
tei_model.recordingPart =
  tei_model.dateLike | tei_respStmt | tei_equipment | tei_broadcast
tei_model.recordingPart_sequence =
  tei_model.dateLike, tei_respStmt, tei_equipment, tei_broadcast
tei_model.recordingPart_sequenceOptional =
  tei_model.dateLike?, tei_respStmt?, tei_equipment?, tei_broadcast?
tei_model.recordingPart_sequenceOptionalRepeatable =
  tei_model.dateLike*, tei_respStmt*, tei_equipment*, tei_broadcast*
tei_model.recordingPart_sequenceRepeatable =
  tei_model.dateLike+, tei_respStmt+, tei_equipment+, tei_broadcast+
tei_model.imprintPart = tei_publisher | tei_biblScope | tei_pubPlace
tei_model.imprintPart_sequence =
  tei_publisher, tei_biblScope, tei_pubPlace
tei_model.imprintPart_sequenceOptional =
  tei_publisher?, tei_biblScope?, tei_pubPlace?
tei_model.imprintPart_sequenceOptionalRepeatable =
  tei_publisher*, tei_biblScope*, tei_pubPlace*
tei_model.imprintPart_sequenceRepeatable =
  tei_publisher+, tei_biblScope+, tei_pubPlace+
tei_model.catDescPart = notAllowed
tei_model.catDescPart_sequence = empty
tei_model.catDescPart_sequenceOptional = empty
tei_model.catDescPart_sequenceOptionalRepeatable = empty
tei_model.catDescPart_sequenceRepeatable = notAllowed
tei_model.settingPart = notAllowed
tei_model.settingPart_sequence = empty
tei_model.settingPart_sequenceOptional = empty
tei_model.settingPart_sequenceOptionalRepeatable = empty
tei_model.settingPart_sequenceRepeatable = notAllowed
tei_model.textDescPart_sequence = empty
tei_model.castItemPart = notAllowed
tei_model.castItemPart_sequence = empty
tei_model.castItemPart_sequenceOptional = empty
tei_model.castItemPart_sequenceOptionalRepeatable = empty
tei_model.castItemPart_sequenceRepeatable = notAllowed
tei_model.physDescPart_sequenceOptional = empty
tei_model.addressLike = tei_email | tei_address
tei_model.addressLike_sequence = tei_email, tei_address
tei_model.addressLike_sequenceOptional = tei_email?, tei_address?
tei_model.addressLike_sequenceOptionalRepeatable =
  tei_email*, tei_address*
tei_model.addressLike_sequenceRepeatable = tei_email+, tei_address+
tei_model.nameLike = tei_model.nameLike.agent | tei_rs
tei_model.nameLike_sequence = tei_model.nameLike.agent, tei_rs
tei_model.nameLike_sequenceOptional = tei_model.nameLike.agent?, tei_rs?
tei_model.nameLike_sequenceOptionalRepeatable =
  tei_model.nameLike.agent*, tei_rs*
tei_model.nameLike_sequenceRepeatable =
  tei_model.nameLike.agent+, tei_rs+
tei_model.global =
  tei_model.global.meta
  | tei_model.milestoneLike
  | tei_model.noteLike
  | tei_model.global.edit
tei_model.global_sequence =
  tei_model.global.meta,
  tei_model.milestoneLike,
  tei_model.noteLike,
  tei_model.global.edit
tei_model.global_sequenceOptional =
  tei_model.global.meta?,
  tei_model.milestoneLike?,
  tei_model.noteLike?,
  tei_model.global.edit?
tei_model.global_sequenceOptionalRepeatable =
  tei_model.global.meta*,
  tei_model.milestoneLike*,
  tei_model.noteLike*,
  tei_model.global.edit*
tei_model.global_sequenceRepeatable =
  tei_model.global.meta+,
  tei_model.milestoneLike+,
  tei_model.noteLike+,
  tei_model.global.edit+
tei_model.featureVal = tei_model.complexVal | tei_model.singleVal
tei_model.featureVal_sequence =
  tei_model.complexVal, tei_model.singleVal
tei_model.featureVal_sequenceOptional =
  tei_model.complexVal?, tei_model.singleVal?
tei_model.featureVal_sequenceOptionalRepeatable =
  tei_model.complexVal*, tei_model.singleVal*
tei_model.featureVal_sequenceRepeatable =
  tei_model.complexVal+, tei_model.singleVal+
tei_model.common =
  tei_model.oddDecl
  | tei_model.oddRef
  | tei_model.qLike
  | tei_model.biblLike
  | tei_model.listLike
  | tei_model.divPart
  | tei_label
  | tei_table
  | tei_figure
tei_model.common_sequence =
  tei_model.oddDecl,
  tei_model.oddRef,
  tei_model.qLike,
  tei_model.biblLike,
  tei_model.listLike,
  tei_model.divPart,
  tei_label,
  tei_table,
  tei_figure
tei_model.common_sequenceOptional =
  tei_model.oddDecl?,
  tei_model.oddRef?,
  tei_model.qLike?,
  tei_model.biblLike?,
  tei_model.listLike?,
  tei_model.divPart?,
  tei_label?,
  tei_table?,
  tei_figure?
tei_model.common_sequenceOptionalRepeatable =
  tei_model.oddDecl*,
  tei_model.oddRef*,
  tei_model.qLike*,
  tei_model.biblLike*,
  tei_model.listLike*,
  tei_model.divPart*,
  tei_label*,
  tei_table*,
  tei_figure*
tei_model.common_sequenceRepeatable =
  tei_model.oddDecl+,
  tei_model.oddRef+,
  tei_model.qLike+,
  tei_model.biblLike+,
  tei_model.listLike+,
  tei_model.divPart+,
  tei_label+,
  tei_table+,
  tei_figure+
tei_model.biblPart =
  tei_model.respLike
  | tei_model.imprintPart
  | tei_series
  | tei_edition
  | tei_extent
  | tei_distributor
  | tei_idno
tei_model.biblPart_sequence =
  tei_model.respLike,
  tei_model.imprintPart,
  tei_series,
  tei_edition,
  tei_extent,
  tei_distributor,
  tei_idno
tei_model.biblPart_sequenceOptional =
  tei_model.respLike?,
  tei_model.imprintPart?,
  tei_series?,
  tei_edition?,
  tei_extent?,
  tei_distributor?,
  tei_idno?
tei_model.biblPart_sequenceOptionalRepeatable =
  tei_model.respLike*,
  tei_model.imprintPart*,
  tei_series*,
  tei_edition*,
  tei_extent*,
  tei_distributor*,
  tei_idno*
tei_model.biblPart_sequenceRepeatable =
  tei_model.respLike+,
  tei_model.imprintPart+,
  tei_series+,
  tei_edition+,
  tei_extent+,
  tei_distributor+,
  tei_idno+
tei_model.datePart = notAllowed
tei_model.datePart_sequence = empty
tei_model.datePart_sequenceOptional = empty
tei_model.datePart_sequenceOptionalRepeatable = empty
tei_model.datePart_sequenceRepeatable = notAllowed
tei_model.frontPart =
  tei_model.frontPart.drama | tei_divGen | tei_titlePage
tei_model.frontPart_sequence =
  tei_model.frontPart.drama, tei_divGen, tei_titlePage
tei_model.frontPart_sequenceOptional =
  tei_model.frontPart.drama?, tei_divGen?, tei_titlePage?
tei_model.frontPart_sequenceOptionalRepeatable =
  tei_model.frontPart.drama*, tei_divGen*, tei_titlePage*
tei_model.frontPart_sequenceRepeatable =
  tei_model.frontPart.drama+, tei_divGen+, tei_titlePage+
tei_model.addrPart =
  tei_model.nameLike
  | tei_addrLine
  | tei_street
  | tei_postCode
  | tei_postBox
tei_model.addrPart_sequence =
  tei_model.nameLike,
  tei_addrLine,
  tei_street,
  tei_postCode,
  tei_postBox
tei_model.addrPart_sequenceOptional =
  tei_model.nameLike?,
  tei_addrLine?,
  tei_street?,
  tei_postCode?,
  tei_postBox?
tei_model.addrPart_sequenceOptionalRepeatable =
  tei_model.nameLike*,
  tei_addrLine*,
  tei_street*,
  tei_postCode*,
  tei_postBox*
tei_model.addrPart_sequenceRepeatable =
  tei_model.nameLike+,
  tei_addrLine+,
  tei_street+,
  tei_postCode+,
  tei_postBox+
tei_model.pPart.data =
  tei_model.dateLike
  | tei_model.measureLike
  | tei_model.addressLike
  | tei_model.nameLike
tei_model.pPart.data_sequence =
  tei_model.dateLike,
  tei_model.measureLike,
  tei_model.addressLike,
  tei_model.nameLike
tei_model.pPart.data_sequenceOptional =
  tei_model.dateLike?,
  tei_model.measureLike?,
  tei_model.addressLike?,
  tei_model.nameLike?
tei_model.pPart.data_sequenceOptionalRepeatable =
  tei_model.dateLike*,
  tei_model.measureLike*,
  tei_model.addressLike*,
  tei_model.nameLike*
tei_model.pPart.data_sequenceRepeatable =
  tei_model.dateLike+,
  tei_model.measureLike+,
  tei_model.addressLike+,
  tei_model.nameLike+
tei_model.inter =
  tei_model.oddDecl
  | tei_model.oddRef
  | tei_model.qLike
  | tei_model.biblLike
  | tei_model.listLike
  | tei_model.stageLike
  | tei_label
  | tei_text
  | tei_table
  | tei_figure
tei_model.inter_sequence =
  tei_model.oddDecl,
  tei_model.oddRef,
  tei_model.qLike,
  tei_model.biblLike,
  tei_model.listLike,
  tei_model.stageLike,
  tei_label,
  tei_text,
  tei_table,
  tei_figure
tei_model.inter_sequenceOptional =
  tei_model.oddDecl?,
  tei_model.oddRef?,
  tei_model.qLike?,
  tei_model.biblLike?,
  tei_model.listLike?,
  tei_model.stageLike?,
  tei_label?,
  tei_text?,
  tei_table?,
  tei_figure?
tei_model.inter_sequenceOptionalRepeatable =
  tei_model.oddDecl*,
  tei_model.oddRef*,
  tei_model.qLike*,
  tei_model.biblLike*,
  tei_model.listLike*,
  tei_model.stageLike*,
  tei_label*,
  tei_text*,
  tei_table*,
  tei_figure*
tei_model.inter_sequenceRepeatable =
  tei_model.oddDecl+,
  tei_model.oddRef+,
  tei_model.qLike+,
  tei_model.biblLike+,
  tei_model.listLike+,
  tei_model.stageLike+,
  tei_label+,
  tei_text+,
  tei_table+,
  tei_figure+
tei_model.phrase =
  tei_model.segLike
  | tei_model.hiLike
  | tei_model.graphicLike
  | tei_model.pPart.msdesc
  | tei_model.pPart.edit
  | tei_model.ptrLike
  | tei_model.lPart
  | tei_model.oddPhr
  | tei_model.pPart.data
tei_model.phrase_sequence =
  tei_model.segLike,
  tei_model.hiLike,
  tei_model.graphicLike,
  tei_model.pPart.msdesc,
  tei_model.pPart.edit,
  tei_model.ptrLike,
  tei_model.lPart,
  tei_model.oddPhr,
  tei_model.pPart.data
tei_model.phrase_sequenceOptional =
  tei_model.segLike?,
  tei_model.hiLike?,
  tei_model.graphicLike?,
  tei_model.pPart.msdesc?,
  tei_model.pPart.edit?,
  tei_model.ptrLike?,
  tei_model.lPart?,
  tei_model.oddPhr?,
  tei_model.pPart.data?
tei_model.phrase_sequenceOptionalRepeatable =
  tei_model.segLike*,
  tei_model.hiLike*,
  tei_model.graphicLike*,
  tei_model.pPart.msdesc*,
  tei_model.pPart.edit*,
  tei_model.ptrLike*,
  tei_model.lPart*,
  tei_model.oddPhr*,
  tei_model.pPart.data*
tei_model.phrase_sequenceRepeatable =
  tei_model.segLike+,
  tei_model.hiLike+,
  tei_model.graphicLike+,
  tei_model.pPart.msdesc+,
  tei_model.pPart.edit+,
  tei_model.ptrLike+,
  tei_model.lPart+,
  tei_model.oddPhr+,
  tei_model.pPart.data+
tei_model.divLike = tei_div
tei_model.divLike_sequence = tei_div
tei_model.divLike_sequenceOptional = tei_div?
tei_model.divLike_sequenceOptionalRepeatable = tei_div*
tei_model.divLike_sequenceRepeatable = tei_div+
tei_model.divGenLike = tei_divGen
tei_model.divGenLike_sequence = tei_divGen
tei_model.divGenLike_sequenceOptional = tei_divGen?
tei_model.divGenLike_sequenceOptionalRepeatable = tei_divGen*
tei_model.divGenLike_sequenceRepeatable = tei_divGen+
tei_model.div1Like = tei_div1
tei_model.div1Like_sequence = tei_div1
tei_model.div1Like_sequenceOptional = tei_div1?
tei_model.div1Like_sequenceOptionalRepeatable = tei_div1*
tei_model.div1Like_sequenceRepeatable = tei_div1+
tei_model.div2Like = tei_div2
tei_model.div2Like_sequence = tei_div2
tei_model.div2Like_sequenceOptional = tei_div2?
tei_model.div2Like_sequenceOptionalRepeatable = tei_div2*
tei_model.div2Like_sequenceRepeatable = tei_div2+
tei_model.div3Like = tei_div3
tei_model.div3Like_sequence = tei_div3
tei_model.div3Like_sequenceOptional = tei_div3?
tei_model.div3Like_sequenceOptionalRepeatable = tei_div3*
tei_model.div3Like_sequenceRepeatable = tei_div3+
tei_model.div4Like = tei_div4
tei_model.div4Like_sequence = tei_div4
tei_model.div4Like_sequenceOptional = tei_div4?
tei_model.div4Like_sequenceOptionalRepeatable = tei_div4*
tei_model.div4Like_sequenceRepeatable = tei_div4+
tei_model.div5Like = tei_div5
tei_model.div5Like_sequence = tei_div5
tei_model.div5Like_sequenceOptional = tei_div5?
tei_model.div5Like_sequenceOptionalRepeatable = tei_div5*
tei_model.div5Like_sequenceRepeatable = tei_div5+
tei_model.div6Like = tei_div6
tei_model.div6Like_sequence = tei_div6
tei_model.div6Like_sequenceOptional = tei_div6?
tei_model.div6Like_sequenceOptionalRepeatable = tei_div6*
tei_model.div6Like_sequenceRepeatable = tei_div6+
tei_model.div7Like = tei_div7
tei_model.div7Like_sequence = tei_div7
tei_model.div7Like_sequenceOptional = tei_div7?
tei_model.div7Like_sequenceOptionalRepeatable = tei_div7*
tei_model.div7Like_sequenceRepeatable = tei_div7+
tei_model.placeNamePart = notAllowed
tei_model.placeNamePart_sequence = empty
tei_model.placeNamePart_sequenceOptional = empty
tei_model.placeNamePart_sequenceOptionalRepeatable = empty
tei_model.placeNamePart_sequenceRepeatable = notAllowed
tei_p =
  
  ## (paragraph) marks paragraphs in prose.
  element p { tei_p.content, tei_p.attributes }
tei_p.content = tei_macro.paraContent
tei_p.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  empty
tei_foreign =
  
  ## (foreign) identifies a word or phrase as belonging to some language other
  ## than that of the surrounding text. 
  element foreign { tei_foreign.content, tei_foreign.attributes }
tei_foreign.content = tei_macro.phraseSeq
tei_foreign.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  empty
tei_emph =
  
  ## (emphasized) marks words or phrases which are stressed or emphasized for
  ## linguistic or rhetorical effect.
  element emph { tei_emph.content, tei_emph.attributes }
tei_emph.content = tei_macro.paraContent
tei_emph.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  empty
tei_hi =
  
  ## (highlighted) marks a word or phrase as graphically distinct from the
  ## surrounding text, for reasons concerning which no claim is
  ## made. 
  element hi { tei_hi.content, tei_hi.attributes }
tei_hi.content = tei_macro.paraContent
tei_hi.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  empty
tei_distinct =
  
  ## (distinct) identifies any word or phrase which is regarded as linguistically
  ## distinct, for example as archaic, technical, dialectal, non-preferred,
  ## etc., or as forming part of a sublanguage. 
  element distinct { tei_distinct.content, tei_distinct.attributes }
tei_distinct.content = tei_macro.phraseSeq
tei_distinct.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  
  ## specifies the sublanguage or register to which the word or phrase
  ## is being assigned
  attribute type { tei_data.enumerated }?,
  
  ## specifies how the phrase is distinct diachronically
  attribute time { tei_data.code }?,
  
  ## specifies how the phrase is distinct diatopically
  attribute space { tei_data.code }?,
  
  ## specifies how the phrase is distinct diastatically
  attribute social { tei_data.code }?,
  empty
tei_q =
  
  ## (quoted speech, thought, or writing) contains material which is
  ## marked as (ostensibly) quoted from elsewhere; in narrative, this element is used to mark direct or
  ## indirect speech; in dictionaries, it ay be used to mark
  ## real or contrived examples of usage; in manuscript descriptions or
  ## other metadata, to mark extracts quoted from the source being documented.
  element q { tei_q.content, tei_q.attributes }
tei_q.content = tei_macro.specialPara
tei_q.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  att.ascribed.attribute.who,
  
  ## may be used to indicate whether the quoted matter is spoken
  ## or thought, or to characterize it more finely.
  ## Sample values include: 1] spoken (representation of direct speech, usually
  ## marked by quotation marks.); 2] thought (representation of thought, e.g. internal monologue.); 3] written (quotation from a written source.)
  attribute type { tei_data.enumerated }?,
  
  ## may be used to indicate whether the quoted matter is regarded
  ## as direct or indirect speech.
  [ a1:defaultValue = "unknown" ]
  attribute direct {
    
    ## (speech or thought is represented directly.) 
    "true"
    | 
      ## (speech or thought is represented indirectly,
      ## e.g. by use of a marked verbal aspect.) 
      "false"
    | 
      ## (no claim is made.) 
      "unknown"
  }?,
  empty
tei_quote =
  
  ## (quotation) contains a phrase or passage attributed by the narrator or
  ##   author to some agency external to the text.
  element quote { tei_quote.content, tei_quote.attributes }
tei_quote.content = tei_macro.specialPara
tei_quote.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  empty
tei_cit =
  
  ## A quotation from some other document, together with a
  ##   bibliographic reference to its source.
  element cit { tei_cit.content, tei_cit.attributes }
tei_cit.content =
  (tei_model.quoteLike
   | tei_model.biblLike
   | tei_model.ptrLike
   | tei_model.global)+
tei_cit.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  empty
tei_mentioned =
  
  ## marks words or phrases mentioned, not used.
  element mentioned { tei_mentioned.content, tei_mentioned.attributes }
tei_mentioned.content = tei_macro.phraseSeq
tei_mentioned.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  empty
tei_soCalled =
  
  ## (so called) contains a word or phrase for which the author or narrator
  ## indicates a disclaiming of responsibility, for example by the use
  ## of scare quotes or italics.
  element soCalled { tei_soCalled.content, tei_soCalled.attributes }
tei_soCalled.content = tei_macro.phraseSeq
tei_soCalled.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  empty
tei_altIdent =
  
  ## supplies the recommended XML name for an element, class,
  ##   attribute, etc. in some language.
  element altIdent { tei_altIdent.content, tei_altIdent.attributes }
tei_altIdent.content = tei_macro.xtext
tei_altIdent.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  att.typed.attribute.type,
  att.typed.attribute.subtype,
  empty
tei_desc =
  
  ## (description) contains a brief description of the purpose and application for
  ## an element, attribute, or attribute value.
  element desc { tei_desc.content, tei_desc.attributes }
tei_desc.content = tei_macro.paraContent
tei_desc.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  att.translatable.attribute.version,
  empty
tei_equiv =
  
  ## specifies a component which is considered equivalent to the
  ##   parent element, either by co-reference, or by external link.
  element equiv { tei_equiv.content, tei_equiv.attributes }
tei_equiv.content = empty
tei_equiv.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  
  ## names the underlying concept of which the parent is a
  ##   representation
  attribute name { tei_data.name }?,
  
  ## references the underlying concept of which the parent is a
  ##   representation by means of some external identifier
  attribute uri { tei_data.pointer }?,
  
  ## references an external script which contains a method to
  ## transform instances of this element to canonical TEI
  ##	
  attribute filter { xsd:anyURI }?,
  
  ## MIME type of external filter script
  attribute mimeType { tei_data.word }?,
  empty
tei_gloss =
  
  ## identifies a phrase or word used to provide a gloss or
  ##   definition for some other word or phrase.
  element gloss { tei_gloss.content, tei_gloss.attributes }
tei_gloss.content = tei_macro.phraseSeq
tei_gloss.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  att.declaring.attribute.decls,
  att.translatable.attribute.version,
  (
   ## identifies the associated term element by an
   ##       absolute or relative URI reference
   attribute target { tei_data.pointer }
   | 
     ## identifies the associated term element using a canonical
     ##       reference from a scheme defined in a refsDecl element
     ##       in the TEI header
     attribute cRef { tei_data.pointer })?,
  empty
tei_term =
  
  ## contains a single-word, multi-word, or symbolic designation
  ##   which is regarded as a technical term.
  element term { tei_term.content, tei_term.attributes }
tei_term.content = tei_macro.phraseSeq
tei_term.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  att.declaring.attribute.decls,
  att.typed.attribute.type,
  att.typed.attribute.subtype,
  
  ## supplies the sort key for this term in an index.
  attribute sortKey { tei_data.word }?,
  (
   ## identifies the associated gloss element by an
   ##	absolute or relative URI reference
   attribute target { tei_data.pointer }
   | 
     ## identifies the associated gloss element using a
     ##	canonical reference from a scheme defined in a
     ##	refsDecl element in the TEI header
     attribute cRef { tei_data.pointer })?,
  empty
tei_sic =
  
  ## contains text reproduced although apparently incorrect or inaccurate.
  element sic { tei_sic.content, tei_sic.attributes }
tei_sic.content = tei_macro.paraContent
tei_sic.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  empty
tei_corr =
  
  ## (correction) contains the correct form of a passage apparently erroneous in the copy text.
  element corr { tei_corr.content, tei_corr.attributes }
tei_corr.content = tei_macro.paraContent
tei_corr.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  att.editLike.attribute.cert,
  att.editLike.attribute.resp,
  att.editLike.attribute.evidence,
  empty
tei_choice =
  
  ## groups a number of alternative encodings for the same point in
  ##   a text.
  element choice { tei_choice.content, tei_choice.attributes }
tei_choice.content = (tei_model.choicePart | tei_choice)*
tei_choice.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  empty
tei_reg =
  
  ## (regularization) contains a reading which has been regularized or normalized
  ## in some sense.
  element reg { tei_reg.content, tei_reg.attributes }
tei_reg.content = tei_macro.paraContent
tei_reg.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  att.editLike.attribute.cert,
  att.editLike.attribute.resp,
  att.editLike.attribute.evidence,
  empty
tei_orig =
  
  ## (original form) contains  a reading which is marked as following  the original,
  ## rather than being normalized or corrected.
  element orig { tei_orig.content, tei_orig.attributes }
tei_orig.content = tei_macro.paraContent
tei_orig.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  empty
tei_gap =
  
  ## (omitted material) indicates a point where material has been omitted in a
  ## transcription, whether for editorial reasons described in the TEI
  ## header, as part of sampling practice, or because the material is
  ## illegible or inaudible.
  element gap { tei_gap.content, tei_gap.attributes }
tei_gap.content = tei_macro.glossSeq
tei_gap.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  att.editLike.attribute.cert,
  att.editLike.attribute.resp,
  att.editLike.attribute.evidence,
  
  ## gives the reason for omission.  Sample values include
  ## sampling, illegible, inaudible,
  ## irrelevant, cancelled, cancelled and illegible.
  attribute reason {
    list { tei_data.word+ }
  }?,
  
  ## in the case of text omitted from the transcription because of
  ## deliberate deletion by an identifiable hand, signifies the hand which
  ## made the deletion.
  attribute hand { tei_data.pointer }?,
  
  ## In the case of text omitted because of damage, categorizes the cause of the damage, if it can be identified.
  ## Sample values include: 1] rubbing (damage results from rubbing of the
  ##   leaf edges); 2] mildew (damage results from mildew on the leaf surface); 3] smoke (damage results from smoke)
  attribute agent { tei_data.enumerated }?,
  
  ## indicates approximately how much text has been omitted from the
  ## transcription, in letters, minims, inches, or any appropriate unit,
  ## either because of editorial policy or because a deletion, damage, or
  ## other cause has rendered transcription impossible.
  attribute extent {
    list { tei_data.word+ }
  }?,
  empty
tei_add =
  
  ## (addition) contains letters, words, or phrases inserted in the text by an
  ## author, scribe, annotator, or corrector.
  element add { tei_add.content, tei_add.attributes }
tei_add.content = tei_macro.paraContent
tei_add.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  att.authorialIntervention.attribute.hand,
  att.authorialIntervention.attribute.status,
  att.authorialIntervention.attribute.type,
  att.editLike.attribute.cert,
  att.editLike.attribute.resp,
  att.editLike.attribute.evidence,
  att.placement.attribute.place,
  empty
tei_del =
  
  ## (deletion) contains a letter, word or passage deleted, marked as deleted,
  ## or otherwise indicated as superfluous or spurious in the copy text by an
  ## author, scribe, annotator, or corrector.
  element del { tei_del.content, tei_del.attributes }
tei_del.content = tei_macro.paraContent
tei_del.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  att.editLike.attribute.cert,
  att.editLike.attribute.resp,
  att.editLike.attribute.evidence,
  att.authorialIntervention.attribute.hand,
  att.authorialIntervention.attribute.status,
  att.authorialIntervention.attribute.type,
  empty
tei_unclear =
  
  ## contains a word, phrase, or passage which cannot be transcribed
  ## with certainty because it is illegible or inaudible in the source.
  element unclear { tei_unclear.content, tei_unclear.attributes }
tei_unclear.content = tei_macro.paraContent
tei_unclear.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  att.editLike.attribute.cert,
  att.editLike.attribute.resp,
  att.editLike.attribute.evidence,
  
  ## indicates why the material is hard to transcribe.
  attribute reason {
    list { tei_data.word+ }
  }?,
  
  ## Where the difficulty in transcription arises from action
  ## (partial deletion, etc.) assignable to an identifiable hand, signifies
  ## the hand responsible for the action.
  attribute hand { tei_data.pointer }?,
  
  ## Where the difficulty in transcription arises from
  ##  damage, categorizes the cause of the damage, if it can be identified.
  ## Sample values include: 1] rubbing (damage results from rubbing of the
  ##   leaf edges); 2] mildew (damage results from mildew on the leaf surface); 3] smoke (damage results from smoke)
  attribute agent { tei_data.enumerated }?,
  empty
tei_name =
  
  ## (name, proper noun) contains a proper noun or noun phrase.
  element name { tei_name.content, tei_name.attributes }
tei_name.content = tei_macro.phraseSeq
tei_name.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  att.naming.attribute.key,
  
  ## indicates the type of the object which is being named by the
  ##       phrase.
  attribute type { tei_data.enumerated }?,
  empty
tei_rs =
  
  ## (referencing string) contains a general purpose name or referring string.
  element rs { tei_rs.content, tei_rs.attributes }
tei_rs.content = tei_macro.phraseSeq
tei_rs.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  att.naming.attribute.key,
  
  ## indicates more specifically the object referred to by the
  ##       referencing string. Values might include person,
  ##       place, ship, element etc.
  attribute type { tei_data.enumerated }?,
  empty
tei_email =
  
  ## contains an e-mail address identifying a location to which
  ## e-mail messages can be delivered.
  ##		
  element email { tei_email.content, tei_email.attributes }
tei_email.content = tei_macro.phraseSeq
tei_email.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  empty
tei_address =
  
  ## contains a postal  address, for example of a
  ## publisher, an organization, or an individual.
  element address { tei_address.content, tei_address.attributes }
tei_address.content =
  tei_model.global*, (tei_model.addrPart, tei_model.global*)+
tei_address.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  empty
tei_addrLine =
  
  ## contains one line of a postal address.
  element addrLine { tei_addrLine.content, tei_addrLine.attributes }
tei_addrLine.content = tei_macro.phraseSeq
tei_addrLine.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  empty
tei_street =
  
  ## (street) a full street address including any name or number identifying a
  ## building as well as the name of the street or route on which it is
  ## located.
  element street { tei_street.content, tei_street.attributes }
tei_street.content = tei_macro.phraseSeq
tei_street.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  empty
tei_postCode =
  
  ## (postCode) contains a numerical or alphanumeric code used as part of a
  ## postal address to simplify sorting or delivery of mail. 
  element postCode { tei_postCode.content, tei_postCode.attributes }
tei_postCode.content = text
tei_postCode.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  empty
tei_postBox =
  
  ## (postBox) contains a number or other identifier for some postal delivery
  ## point other than a street address. 
  element postBox { tei_postBox.content, tei_postBox.attributes }
tei_postBox.content = text
tei_postBox.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  empty
tei_num =
  
  ## (number) contains a number, written in any form.
  element num { tei_num.content, tei_num.attributes }
tei_num.content = tei_macro.phraseSeq
tei_num.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  
  ## indicates the type of numeric value.
  ## Suggested values include: 1] cardinal (absolute number, e.g. 21, 21.5); 2] ordinal (ordinal number, e.g. 21st); 3] fraction (fraction, e.g. one half or three-quarters); 4] percentage (a percentage)
  attribute type { tei_data.enumerated }?,
  
  ## supplies the value of the number in standard form.
  attribute value { tei_data.numeric }?,
  empty
tei_measure =
  
  ## contains a word or phrase referring to some quantity of
  ## an object or commodity, usually comprising a number, a unit, and a
  ## commodity name.
  element measure { tei_measure.content, tei_measure.attributes }
tei_measure.content = tei_macro.phraseSeq
tei_measure.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  att.measurement.attribute.unit,
  att.measurement.attribute.quantity,
  att.measurement.attribute.commodity,
  
  ## specifies the type of measurement in any convenient typology.
  attribute type { tei_data.enumerated }?,
  empty
tei_date =
  
  ## contains a date in any format.
  element date { tei_date.content, tei_date.attributes }
tei_date.content =
  (text
   | tei_model.gLike
   | tei_model.datePart
   | tei_model.phrase
   | tei_model.global)*
tei_date.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  att.datePart.attribute.value,
  att.datePart.attribute.dur,
  att.editLike.attribute.cert,
  att.editLike.attribute.resp,
  att.editLike.attribute.evidence,
  att.datable.attribute.notBefore,
  att.datable.attribute.notAfter,
  att.datable.attribute.from,
  att.datable.attribute.to,
  att.typed.attribute.type,
  att.typed.attribute.subtype,
  
  ## indicates the system or calendar to which the date belongs.
  ## Suggested values include: 1] Gregorian; 2] Julian; 3] Islamic; 4] Hebrew; 5] Revolutionary; 6] Iranian; 7] Coptic; 8] Chinese
  attribute calendar { tei_data.enumerated }?,
  
  ## indicates the degree of precision associated with the date.
  attribute precision { tei_data.certainty }?,
  empty
tei_time =
  
  ## contains a phrase defining a time of day in any format.
  element time { tei_time.content, tei_time.attributes }
tei_time.content =
  (text
   | tei_model.gLike
   | tei_model.datePart
   | tei_model.phrase
   | tei_model.global)*
tei_time.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  att.datePart.attribute.value,
  att.datePart.attribute.dur,
  att.editLike.attribute.cert,
  att.editLike.attribute.resp,
  att.editLike.attribute.evidence,
  att.datable.attribute.notBefore,
  att.datable.attribute.notAfter,
  att.datable.attribute.from,
  att.datable.attribute.to,
  att.typed.attribute.type,
  att.typed.attribute.subtype,
  empty
tei_abbr =
  
  ## (abbreviation) contains an abbreviation of any sort.
  element abbr { tei_abbr.content, tei_abbr.attributes }
tei_abbr.content = tei_macro.phraseSeq
tei_abbr.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  
  ## allows the encoder to classify the abbreviation according to
  ## some convenient typology.
  ## Sample values include: 1] suspension (the abbreviation provides the first
  ##        letter(s) of the word or phrase, omitting the remainder.); 2] contraction (the abbreviation omits some letter(s) in the middle.); 3] brevigraph (the abbreviation comprises a special symbol or mark.); 4] superscription (the abbreviation includes writing above the line.); 5] acronym (the abbreviation comprises the initial letters of
  ##	  the words of a phrase.); 6] title (the abbreviation is for a title of address (Dr, Ms, Mr, …)); 7] organization (the abbreviation is for the name of an organization.); 8] geographic (the abbreviation is for a geographic name.)
  attribute type { tei_data.enumerated }?,
  empty
tei_expan =
  
  ## (expansion) contains the expansion of an abbreviation.
  element expan { tei_expan.content, tei_expan.attributes }
tei_expan.content = tei_macro.phraseSeq
tei_expan.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  att.editLike.attribute.cert,
  att.editLike.attribute.resp,
  att.editLike.attribute.evidence,
  empty
tei_ptr =
  
  ## defines a pointer to another location.
  element ptr { tei_ptr.content, tei_ptr.attributes }
tei_ptr.content = empty
tei_ptr.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  att.declaring.attribute.decls,
  (
   ## specifies the destination of the pointer by supplying one or
   ##       more URI References
   attribute target {
     list { tei_data.pointer+ }
   }
   | 
     ## specifies the destination of the pointer by supplying a
     ##       canonical reference from a scheme defined in a refsDecl
     ##       element in the TEI header
     attribute cRef {
       list { tei_data.word+ }
     })?,
  empty
tei_ref =
  
  ## defines a reference to another location, possibly
  ##   modified by additional text or comment.
  element ref { tei_ref.content, tei_ref.attributes }
tei_ref.content = tei_macro.paraContent
tei_ref.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  att.declaring.attribute.decls,
  (
   ## specifies the destination of the reference by supplying one
   ##     or more URI References
   attribute target {
     list { tei_data.pointer+ }
   }
   | 
     ## specifies the destination of the reference by supplying a
     ##       canonical reference from a scheme defined in a refsDecl
     ##       element in the TEI header
     attribute cRef {
       list { tei_data.word+ }
     })?,
  empty
tei_list =
  
  ## contains any sequence of items organized as a list.
  element list { tei_list.content, tei_list.attributes }
tei_list.content =
  (tei_model.divWrapper | tei_model.global)*,
  ((tei_item, tei_model.global*)+
   | (tei_headLabel?,
      tei_headItem?,
      (tei_label, tei_model.global*, tei_item, tei_model.global*)+)),
  (tei_model.divWrapper.bottom, tei_model.global*)*
tei_list.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  
  ## describes the form of the list.
  ## Suggested values include: 1] ordered (list items are numbered or lettered.
  ##     ); 2] bulleted (list items are marked with a
  ## bullet or other typographic device.
  ##     ); 3] simple (list items are not numbered or bulleted.
  ##     ); 4] gloss (each list item glosses some term or
  ## concept, which is given by a label element preceding
  ## the list item.)
  [ a1:defaultValue = "simple" ]
  attribute type { tei_data.enumerated }?,
  empty
tei_item =
  
  ## contains one
  ## component of a list.
  element item { tei_item.content, tei_item.attributes }
tei_item.content = tei_macro.specialPara
tei_item.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  empty
tei_label =
  
  ## contains the label associated with an item in a list; in
  ## glossaries, marks the term being defined.
  element label { tei_label.content, tei_label.attributes }
tei_label.content = tei_macro.phraseSeq
tei_label.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  empty
tei_head =
  
  ## (heading) contains any type of heading, for example the title of a section,
  ## or the heading of a list, glossary, manuscript description, etc.
  element head { tei_head.content, tei_head.attributes }
tei_head.content = tei_macro.paraContent
tei_head.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  
  ## categorizes the heading in any way meaningful 
  ##          to the encoder. 
  attribute type { tei_data.enumerated }?,
  empty
tei_headLabel =
  
  ## (heading for list labels) contains the heading for the label or term column in a
  ## glossary list or similar structured list.
  element headLabel { tei_headLabel.content, tei_headLabel.attributes }
tei_headLabel.content = tei_macro.phraseSeq
tei_headLabel.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  empty
tei_headItem =
  
  ## (heading for list items) contains the heading for the item or gloss column in a
  ## glossary list or similar structured list.
  element headItem { tei_headItem.content, tei_headItem.attributes }
tei_headItem.content = tei_macro.phraseSeq
tei_headItem.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  empty
tei_note =
  
  ## contains a note or annotation.
  element note { tei_note.content, tei_note.attributes }
tei_note.content = tei_macro.specialPara
tei_note.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  att.placement.attribute.place,
  
  ## describes the type of note.
  attribute type { tei_data.enumerated }?,
  
  ## indicates who is responsible for the annotation: author,
  ##	editor, translator, etc.
  attribute resp { tei_data.pointer }?,
  
  ## indicates whether the copy text shows the exact place of reference
  ## for the note.
  [ a1:defaultValue = "true" ]
  attribute anchored {
    
    ## (copy text indicates the place of attachment for the note.
    ##     ) 
    "true"
    | 
      ## (copy text indicates no place of attachment for the note.) 
      "false"
  }?,
  
  ## indicates the point (or points) of attachment for a note, or the beginning of
  ## the span to which the note is attached.
  attribute target {
    list { tei_data.pointer+ }
  }?,
  
  ## points to the end of the span to which the note is attached, if
  ## the note is not embedded in the text at that point.
  attribute targetEnd {
    list { tei_data.pointer+ }
  }?,
  empty
tei_index =
  
  ## (index entry) marks a location to be indexed for whatever purpose.
  element index { tei_index.content, tei_index.attributes }
tei_index.content = (tei_term, tei_index?)*
tei_index.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  att.spanning.attribute.spanTo,
  
  ## supplies a name to specify which index (of several) the index entry belongs to.
  attribute indexName { tei_data.name }?,
  empty
tei_divGen =
  
  ## (automatically generated text division) indicates the location at which a textual division generated
  ## automatically by a text-processing application is to appear.
  element divGen { tei_divGen.content, tei_divGen.attributes }
tei_divGen.content = tei_model.divWrapper*
tei_divGen.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  
  ## specifies what type of generated text division (e.g. index,
  ## table of contents, etc.) is to appear.
  ## Sample values include: 1] index (an index is to be generated and inserted at this point.); 2] toc (a table of contents); 3] figlist (a list of figures); 4] tablist (a list of tables)
  attribute type { tei_data.enumerated }?,
  empty
tei_graphic =
  
  ## indicates the location of an inline graphic, illustration, or figure.
  element graphic { tei_graphic.content, tei_graphic.attributes }
tei_graphic.content = empty
tei_graphic.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  
  ## The display width of the image
  attribute width { tei_data.outputMeasurement }?,
  
  ## The display height of the image
  attribute height { tei_data.outputMeasurement }?,
  
  ## A scale factor to be applied to the image to make it the desired display size
  attribute scale { tei_data.numeric }?,
  
  ## The target URL
  attribute url { tei_data.pointer }?,
  
  ## The MIME type
  attribute mimeType { tei_data.word }?,
  empty
tei_binaryObject =
  
  ## provides encoded binary data representing an inline graphic or other object.
  element binaryObject {
    tei_binaryObject.content, tei_binaryObject.attributes
  }
tei_binaryObject.content = text
tei_binaryObject.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  
  ## The display width of the object
  attribute width { tei_data.outputMeasurement }?,
  
  ## The display height of the object
  attribute height { tei_data.outputMeasurement }?,
  
  ## A scale factor to be applied to the object to make it the desired display size
  attribute scale { tei_data.numeric }?,
  
  ## The MIME type
  attribute mimeType { tei_data.word }?,
  
  ## The encoding used to encode the binary data. If not
  ##       specified, this is assumed to be Base64
  attribute encoding {
    list { tei_data.word+ }
  }?,
  empty
tei_milestone =
  
  ## marks a boundary point separating  any kind of section of a text, as indicated by
  ## changes in a standard reference system, where the section is not
  ## represented by a structural element.
  element milestone { tei_milestone.content, tei_milestone.attributes }
tei_milestone.content = empty
tei_milestone.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  
  ## indicates the edition or version to which the milestone applies.
  attribute ed { tei_data.code }?,
  
  ## provides a conventional name for the kind of section changing at this milestone.
  ## Suggested values include: 1] page (physical page breaks (synonymous with the pb
  ##	  element).); 2] column (column breaks.); 3] line (line breaks (synonymous with the lb element).); 4] book (any units termed book, liber, etc.); 5] poem (individual poems in a collection.); 6] canto (cantos or other major sections of a poem.); 7] stanza (stanzas within a poem, book, or canto.); 8] act (acts within a play.); 9] scene (scenes within a play or act.); 10] section (sections of any kind.); 11] absent (passages not present in the reference edition.)
  attribute unit { tei_data.enumerated },
  empty
tei_pb =
  
  ## (page break) marks the boundary between one page of a text and the next
  ## in a standard reference system.
  element pb { tei_pb.content, tei_pb.attributes }
tei_pb.content = empty
tei_pb.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  
  ## indicates the edition or version in which the page break is located
  ## at this point
  attribute ed { tei_data.code }?,
  empty
tei_lb =
  
  ## (line break) marks the start of a new (typographic) line in some
  ## edition or version of a text.
  element lb { tei_lb.content, tei_lb.attributes }
tei_lb.content = empty
tei_lb.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  
  ## indicates the edition or version in which the line break is located
  ## at this point
  attribute ed { tei_data.code }?,
  empty
tei_cb =
  
  ## (column break) marks the boundary between one column of a text and the next
  ## in a standard reference system.
  element cb { tei_cb.content, tei_cb.attributes }
tei_cb.content = empty
tei_cb.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  
  ## indicates the edition or version in which the column break is located
  ## at this point
  attribute ed { tei_data.code }?,
  empty
tei_bibl =
  
  ## (bibliographic citation) contains a loosely-structured bibliographic citation of which
  ## the sub-components may or may not be explicitly tagged. 
  element bibl { tei_bibl.content, tei_bibl.attributes }
tei_bibl.content =
  (text
   | tei_model.gLike
   | tei_model.hiLike
   | tei_model.pPart.data
   | tei_model.pPart.edit
   | tei_model.segLike
   | tei_model.ptrLike
   | tei_model.biblPart
   | tei_model.global)*
tei_bibl.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  att.declarable.attribute.default,
  empty
tei_biblItem =
  
  ## (bibliographic citation) contains a bibliographic citation in which only bibliographic
  ##   subelements appear.
  element biblItem { tei_biblItem.content, tei_biblItem.attributes }
tei_biblItem.content =
  (tei_title
   | tei_biblItem
   | tei_imprint
   | tei_model.nameLike
   | tei_model.biblPart
   | tei_model.dateLike)+
tei_biblItem.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  att.declarable.attribute.default,
  att.typed.attribute.type,
  att.typed.attribute.subtype,
  
  ## indicates the physical form of the object of this bibliographic entry.
  ## Sample values include: 1] book.hardcover (); 2] book.paperback (); 3] video.VHS (); 4] video.DVD (); 5] audio.casette (); 6] audio.CD ()
  attribute form { tei_data.word }?,
  
  ## indicates the publication status of the object of this bibliographic entry.
  ## Sample values include: 1] manuscript (the item is a manuscript); 2] forthcoming (the item is being published, but has not been released yet); 3] inPrint (the item is currently being published)
  attribute status { text }?,
  
  ## indicates the relationship of this bibliographic entry to
  ##       that of its parent bibl or biblItem.
  ## Sample values include: 1] host (this bibliographic item has a host relationship to
  ##	  the item encoded in the parent bibl or biblItem; e.g., this item is the
  ##	  magazine in which the article described by the parent bibl or biblItem
  ##	  appeared.); 2] original (the item is original source); 3] workReviewed (this bibliographic item was reviewed in the ancestor work); 4] edition (indicates that this entry contains separate
  ##	  information for a particular edition of the parent bibl or biblItem); 5] basedOn (indicates that the parent bibl or biblItem is the base work from which this one was
  ##	  derived); 6] referencedBy (indicates that the element is a reference for the work in question); 7] copyOf (indicates that this entry is for a facsimile of that
  ##	  which is referred to by the parent bibl or biblItem)
  attribute role { text }?,
  empty
tei_biblStruct =
  
  ## (structured bibliographic citation) contains a structured bibliographic citation, in which only
  ## bibliographic subelements appear and in a specified order. 
  element biblStruct {
    tei_biblStruct.content, tei_biblStruct.attributes
  }
tei_biblStruct.content =
  tei_analytic*,
  (tei_monogr, tei_series*)+,
  (tei_model.noteLike | tei_idno)*
tei_biblStruct.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  att.declarable.attribute.default,
  empty
tei_biblFull =
  
  ## contains a fully-structured bibliographic citation, in which all
  ## components of the TEI file description
  ## are present.
  element biblFull { tei_biblFull.content, tei_biblFull.attributes }
tei_biblFull.content = tei_macro.fileDescPart, tei_sourceDesc*
tei_biblFull.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  att.declarable.attribute.default,
  empty
tei_listBibl =
  
  ## (citation list) contains a list of bibliographic citations of any kind. 
  element listBibl { tei_listBibl.content, tei_listBibl.attributes }
tei_listBibl.content =
  (tei_model.divWrapper | tei_model.global)*,
  (tei_model.biblLike, tei_model.global*)+,
  (tei_model.divWrapper.bottom, tei_model.global*)*
tei_listBibl.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  att.declarable.attribute.default,
  empty
tei_analytic =
  
  ## (analytic level) contains bibliographic elements describing an item (e.g. an
  ## article or poem) published within a monograph or journal and not as an
  ## independent publication.
  element analytic { tei_analytic.content, tei_analytic.attributes }
tei_analytic.content =
  (tei_author | tei_editor | tei_respStmt | tei_title)*
tei_analytic.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  empty
tei_monogr =
  
  ## (monographic level) contains bibliographic elements describing an item (e.g. a book
  ## or journal) published as an independent item (i.e. as a separate
  ## physical object).
  element monogr { tei_monogr.content, tei_monogr.attributes }
tei_monogr.content =
  (((tei_author | tei_editor | tei_respStmt),
    (tei_author | tei_editor | tei_respStmt)*,
    tei_title+,
    (tei_editor | tei_respStmt)*)
   | (tei_title+, (tei_author | tei_editor | tei_respStmt)*))?,
  (tei_model.noteLike | tei_meeting)*,
  (tei_edition, (tei_editor | tei_respStmt)*)*,
  tei_imprint,
  (tei_imprint | tei_extent | tei_biblScope)*
tei_monogr.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  empty
tei_series =
  
  ## (series information) contains information about the series in which a book or other
  ## bibliographic item has appeared.
  element series { tei_series.content, tei_series.attributes }
tei_series.content =
  (text
   | tei_model.gLike
   | tei_title
   | tei_editor
   | tei_respStmt
   | tei_biblScope
   | tei_model.global)*
tei_series.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  empty
tei_author =
  
  ## in a bibliographic reference, contains the name of the author(s),
  ## personal or corporate,
  ## of a work; the primary statement of responsibility for any
  ## bibliographic item. 
  element author { tei_author.content, tei_author.attributes }
tei_author.content = tei_macro.phraseSeq
tei_author.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  empty
tei_editor =
  
  ## secondary statement of responsibility for a
  ## bibliographic item, for example the name of an individual, institution
  ## or organization, (or of several such) acting as editor, compiler,
  ## translator, etc. 
  element editor { tei_editor.content, tei_editor.attributes }
tei_editor.content = tei_macro.phraseSeq
tei_editor.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  
  ## specifies the nature of the intellectual responsibility
  [ a1:defaultValue = "editor" ]
  attribute role { tei_data.enumerated }?,
  empty
tei_respStmt =
  
  ## (statement of responsibility) supplies a statement of responsibility for someone responsible
  ##   for the intellectual content of a text, edition, recording, or
  ##   series, where the specialized elements for authors, editors, etc. do
  ##   not suffice or do not apply.
  element respStmt { tei_respStmt.content, tei_respStmt.attributes }
tei_respStmt.content =
  (tei_resp+, tei_model.nameLike.agent+)
  | (tei_model.nameLike.agent+, tei_resp+)
tei_respStmt.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  empty
tei_resp =
  
  ## contains a phrase describing the nature of a person's
  ##   intellectual responsibility.
  element resp { tei_resp.content, tei_resp.attributes }
tei_resp.content = tei_macro.phraseSeq
tei_resp.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  empty
tei_title =
  
  ## contains the full title of a work of any kind.
  element title { tei_title.content, tei_title.attributes }
tei_title.content = tei_macro.paraContent
tei_title.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  
  ## indicates the bibliographic level for a title, that is,
  ##	whether it identifies  an article, book, journal,
  ## series, or unpublished material.
  attribute level {
    
    ## (analytic title (article, poem, or other item published as
    ##           part of a larger item)
    ##     ) 
    "a"
    | 
      ## (monographic title (book, collection, or other item published
      ##           as a distinct item, including single volumes of multi-volume
      ##           works)
      ##     ) 
      "m"
    | 
      ## (journal title
      ##     ) 
      "j"
    | 
      ## (series title
      ##     ) 
      "s"
    | 
      ## (title of unpublished material (including theses and
      ##           dissertations unless published by a commercial press)) 
      "u"
  }?,
  
  ## classifies the title according to some convenient typology.
  ## Sample values include: 1] main (main title
  ##     ); 2] sub (subtitle, title of part
  ##     ); 3] alt (alternate title, often in another language,
  ##                            by which the work is also known
  ##     ); 4] short (abbreviated form of title); 5] desc (descriptive paraphrase of the work functioning as a title)
  attribute type { tei_data.enumerated }?,
  empty
tei_meeting =
  
  ## in bibliographic references,
  ## contains a description of the meeting or conference from which
  ## the bibliographic item derives.
  element meeting { tei_meeting.content, tei_meeting.attributes }
tei_meeting.content = tei_macro.paraContent
tei_meeting.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  empty
tei_imprint =
  
  ## groups information relating to the publication or distribution
  ##   of a bibliographic item.
  element imprint { tei_imprint.content, tei_imprint.attributes }
tei_imprint.content =
  ((tei_model.imprintPart | tei_model.dateLike), tei_model.global*)+
tei_imprint.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  empty
tei_publisher =
  
  ## provides the name of the organization responsible for
  ## the publication or distribution of a bibliographic item.
  element publisher { tei_publisher.content, tei_publisher.attributes }
tei_publisher.content = tei_macro.phraseSeq
tei_publisher.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  empty
tei_biblScope =
  
  ## (scope of citation) defines the scope of a bibliographic reference, for example as a
  ## list of pagenumbers, or a named subdivision of a larger work.
  element biblScope { tei_biblScope.content, tei_biblScope.attributes }
tei_biblScope.content = tei_macro.phraseSeq
tei_biblScope.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  
  ## identifies the type of information conveyed by the element, e.g.
  ## pages, volume.
  ## Suggested values include: 1] vol (the element contains a volume number.); 2] issue (the element contains an issue number, or volume and
  ## issue numbers.); 3] pp (the element contains a page number or page range.); 4] cap (the element contains a chapter indication (number
  ## and/or title)); 5] part (the element identifies a part of a book or collection.)
  attribute type { tei_data.enumerated }?,
  empty
tei_pubPlace =
  
  ## contains the name of the place where a bibliographic item was
  ## published.
  element pubPlace { tei_pubPlace.content, tei_pubPlace.attributes }
tei_pubPlace.content = tei_macro.phraseSeq
tei_pubPlace.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  att.naming.attribute.key,
  empty
tei_l =
  
  ## (verse line) contains a single, possibly incomplete, line of verse.
  element l { tei_l.content, tei_l.attributes }
tei_l.content = tei_macro.paraContent
tei_l.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  
  ## specifies whether or not the line is metrically complete. 
  [ a1:defaultValue = "N" ]
  attribute part {
    
    ## (the line is metrically incomplete) 
    "Y"
    | 
      ## (either the line is complete, or no claim is made as to its
      ## completeness) 
      "N"
    | 
      ## (the initial part of an incomplete line) 
      "I"
    | 
      ## (a medial part of an incomplete line) 
      "M"
    | 
      ## (the final part of an incomplete line) 
      "F"
  }?,
  empty
tei_lg =
  
  ## (line group) contains a group of verse lines functioning as a formal unit,
  ## e.g. a stanza, refrain, verse paragraph, etc.
  element lg { tei_lg.content, tei_lg.attributes }
tei_lg.content =
  (tei_model.divWrapper | tei_model.global)*,
  (tei_model.lLike | tei_lg),
  (tei_model.lLike | tei_lg | tei_model.global)*,
  (tei_model.divWrapper.bottom, tei_model.global*)*
tei_lg.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  att.divLike.attribute.type,
  att.divLike.attribute.org,
  att.divLike.attribute.sample,
  att.divLike.attribute.part,
  empty
tei_sp =
  
  ## (speech) An individual speech in a performance text, or a passage
  ##	  presented as such in a prose or verse text.
  element sp { tei_sp.content, tei_sp.attributes }
tei_sp.content =
  tei_model.global*,
  (tei_speaker, tei_model.global*)?,
  ((tei_model.lLike
    | tei_lg
    | tei_model.pLike
    | tei_model.blockLike
    | tei_model.stageLike),
   tei_model.global*)+
tei_sp.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  att.ascribed.attribute.who,
  empty
tei_speaker =
  
  ## A specialized form of heading or label, giving the name of
  ## one or more speakers in a dramatic text or fragment.
  element speaker { tei_speaker.content, tei_speaker.attributes }
tei_speaker.content = tei_macro.phraseSeq
tei_speaker.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  empty
tei_stage =
  
  ## (stage direction) contains any kind of stage direction within a dramatic text or
  ## fragment.
  element stage { tei_stage.content, tei_stage.attributes }
tei_stage.content = tei_macro.specialPara
tei_stage.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  
  ## indicates the kind of stage direction.
  ## Suggested values include: 1] setting (describes a setting.); 2] entrance (describes an entrance.); 3] exit (describes an exit.); 4] business (describes stage business.); 5] novelistic (is a narrative, motivating stage direction.); 6] delivery (describes how a character speaks.); 7] modifier (gives some detail about a character.); 8] location (describes a location.); 9] mixed (more than one of the above)
  attribute type { tei_data.enumerated }?,
  empty
tei_teiCorpus =
  
  ## (TEI corpus) contains the whole of a TEI encoded corpus, comprising a
  ## single corpus header and one or more TEI elements, each containing
  ## a single text header and a text.
  element teiCorpus { tei_teiCorpus.content, tei_teiCorpus.attributes }
tei_teiCorpus.content = tei_teiHeader, (tei_TEI | tei_teiCorpus)+
tei_teiCorpus.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  
  ## The version of the TEI scheme
  [ a1:defaultValue = "5.0" ] attribute version { xsd:decimal }?,
  empty
tei_teiHeader =
  
  ## (TEI Header) supplies the descriptive and declarative information making
  ##	up an electronic title page prefixed to every TEI-conformant
  ##	text.
  element teiHeader { tei_teiHeader.content, tei_teiHeader.attributes }
tei_teiHeader.content =
  tei_fileDesc, tei_model.headerPart*, tei_revisionDesc?
tei_teiHeader.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  
  ## specifies the kind of document to which the header is attached.
  ## Sample values include: 1] text (the header is attached to a single text.); 2] corpus (the header is attached to a corpus.)
  [ a1:defaultValue = "text" ] attribute type { tei_data.enumerated }?,
  empty
tei_fileDesc =
  
  ## (File Description) contains a full bibliographic description of an electronic
  ## file.
  element fileDesc { tei_fileDesc.content, tei_fileDesc.attributes }
tei_fileDesc.content = tei_macro.fileDescPart, tei_sourceDesc+
tei_fileDesc.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  empty
tei_titleStmt =
  
  ## (title statement) groups information about the title of a work and those
  ## responsible for its intellectual content.
  element titleStmt { tei_titleStmt.content, tei_titleStmt.attributes }
tei_titleStmt.content =
  tei_title+,
  (tei_author
   | tei_editor
   | tei_sponsor
   | tei_funder
   | tei_principal
   | tei_respStmt)*
tei_titleStmt.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  empty
tei_sponsor =
  
  ## specifies the name of a sponsoring organization or
  ## institution.
  element sponsor { tei_sponsor.content, tei_sponsor.attributes }
tei_sponsor.content = tei_macro.phraseSeq
tei_sponsor.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  empty
tei_funder =
  
  ## (Funding body) specifies the name of an individual, institution, or organization
  ## responsible for the funding of a project or text.
  element funder { tei_funder.content, tei_funder.attributes }
tei_funder.content = tei_macro.phraseSeq
tei_funder.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  empty
tei_principal =
  
  ## (principal researcher) supplies the name of the principal researcher responsible for the
  ## creation of an electronic text.
  element principal { tei_principal.content, tei_principal.attributes }
tei_principal.content = tei_macro.phraseSeq
tei_principal.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  empty
tei_editionStmt =
  
  ## (edition statement) groups information relating to one edition of a text.
  element editionStmt {
    tei_editionStmt.content, tei_editionStmt.attributes
  }
tei_editionStmt.content =
  tei_model.pLike+ | (tei_edition, tei_respStmt*)
tei_editionStmt.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  empty
tei_edition =
  
  ## (Edition) describes the particularities of one edition of a text.
  element edition { tei_edition.content, tei_edition.attributes }
tei_edition.content = tei_macro.phraseSeq
tei_edition.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  empty
tei_extent =
  
  ## describes the approximate size of a text as stored on
  ## some carrier medium, whether digital or non-digital, specified in any convenient units.
  element extent { tei_extent.content, tei_extent.attributes }
tei_extent.content = tei_macro.phraseSeq
tei_extent.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  empty
tei_publicationStmt =
  
  ## (publication statement) groups information concerning the publication or distribution
  ## of an electronic or other text. 
  element publicationStmt {
    tei_publicationStmt.content, tei_publicationStmt.attributes
  }
tei_publicationStmt.content =
  tei_model.pLike+ | tei_model.publicationStmtPart+
tei_publicationStmt.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  empty
tei_distributor =
  
  ## supplies the name of a person or other agency responsible for the
  ## distribution of a text.
  element distributor {
    tei_distributor.content, tei_distributor.attributes
  }
tei_distributor.content = tei_macro.phraseSeq
tei_distributor.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  empty
tei_authority =
  
  ## (release authority) supplies the name of a person or other agency responsible for
  ##   making an electronic file available, other than a publisher or
  ##   distributor.
  element authority { tei_authority.content, tei_authority.attributes }
tei_authority.content = tei_macro.phraseSeq
tei_authority.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  empty
tei_idno =
  
  ## (identifying number) supplies any standard or non-standard number used to identify a
  ## bibliographic item.
  element idno { tei_idno.content, tei_idno.attributes }
tei_idno.content = text
tei_idno.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  
  ## categorizes the number, for example as an ISBN or other
  ##          standard series.
  ##    
  attribute type { tei_data.enumerated }?,
  empty
tei_availability =
  
  ## supplies information about the availability of a text, for
  ##   example any restrictions on its use or distribution, its copyright
  ##   status, etc.
  element availability {
    tei_availability.content, tei_availability.attributes
  }
tei_availability.content = tei_model.pLike+
tei_availability.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  
  ## supplies a code identifying the current availability of the
  ## text.
  ##    
  [ a1:defaultValue = "unknown" ]
  attribute status {
    
    ## (the text is freely available.
    ##     ) 
    "free"
    | 
      ## (the status of the text is unknown.
      ##     ) 
      "unknown"
    | 
      ## (the text is not freely available.
      ##    ) 
      "restricted"
  }?,
  empty
tei_seriesStmt =
  
  ## (series statement) groups information about the series, if any, to which
  ## a publication belongs.
  element seriesStmt {
    tei_seriesStmt.content, tei_seriesStmt.attributes
  }
tei_seriesStmt.content =
  tei_model.pLike+
  | (tei_title+, (tei_idno | tei_respStmt)*)
tei_seriesStmt.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  empty
tei_notesStmt =
  
  ## (Notes statement) collects together any notes providing information about a text
  ## additional to that recorded in other parts of the bibliographic
  ## description.
  element notesStmt { tei_notesStmt.content, tei_notesStmt.attributes }
tei_notesStmt.content = tei_model.noteLike+
tei_notesStmt.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  empty
tei_sourceDesc =
  
  ## supplies a description of the source text(s) from
  ## which an electronic text was derived or generated.
  element sourceDesc {
    tei_sourceDesc.content, tei_sourceDesc.attributes
  }
tei_sourceDesc.content =
  tei_model.pLike+
  | tei_listBibl
  | (tei_model.biblLike | tei_model.sourceDescPart)+
tei_sourceDesc.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  att.declarable.attribute.default,
  empty
tei_scriptStmt =
  
  ## (script statement) contains a citation giving details of the script used for
  ## a spoken text.
  element scriptStmt {
    tei_scriptStmt.content, tei_scriptStmt.attributes
  }
tei_scriptStmt.content = tei_model.pLike+ | tei_model.biblLike
tei_scriptStmt.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  att.declarable.attribute.default,
  empty
tei_recordingStmt =
  
  ## (recording statement) describes a set of recordings used in transcription of a
  ## spoken text.
  element recordingStmt {
    tei_recordingStmt.content, tei_recordingStmt.attributes
  }
tei_recordingStmt.content = tei_model.pLike+ | tei_recording+
tei_recordingStmt.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  empty
tei_recording =
  
  ## (recording event) details of an audio or video recording event
  ## used as the source of a spoken text, either directly or from
  ## a public broadcast. 
  element recording { tei_recording.content, tei_recording.attributes }
tei_recording.content = tei_model.pLike+ | tei_model.recordingPart*
tei_recording.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  att.declarable.attribute.default,
  
  ## the kind of recording.
  [ a1:defaultValue = "audio" ]
  attribute type {
    
    ## (audio recording) 
    "audio"
    | 
      ## (audio and video recording) 
      "video"
  }?,
  
  ## the original duration of the recording. 
  attribute dur { tei_data.duration }?,
  empty
tei_equipment =
  
  ## (equipment) provides technical details of the equipment and media used for
  ## an audio or video recording used as the source for a spoken text.
  element equipment { tei_equipment.content, tei_equipment.attributes }
tei_equipment.content = tei_model.pLike+
tei_equipment.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  att.declarable.attribute.default,
  empty
tei_broadcast =
  
  ## (broadcast) describes a broadcast used as the source of a spoken text.
  element broadcast { tei_broadcast.content, tei_broadcast.attributes }
tei_broadcast.content =
  tei_model.pLike+ | tei_model.biblLike | tei_recording
tei_broadcast.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  att.declarable.attribute.default,
  empty
tei_encodingDesc =
  
  ## (Encoding description) documents the relationship between an electronic text and the
  ## source or sources from which it was derived.
  element encodingDesc {
    tei_encodingDesc.content, tei_encodingDesc.attributes
  }
tei_encodingDesc.content = (tei_model.encodingPart | tei_model.pLike)+
tei_encodingDesc.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  empty
tei_projectDesc =
  
  ## (project description) describes in detail the aim or purpose for which an electronic
  ## file was encoded, together with any other relevant information
  ## concerning the process by which it was assembled or collected.
  element projectDesc {
    tei_projectDesc.content, tei_projectDesc.attributes
  }
tei_projectDesc.content = tei_model.pLike+
tei_projectDesc.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  att.declarable.attribute.default,
  empty
tei_samplingDecl =
  
  ## (sampling declaration) contains a prose description of the rationale and methods used
  ## in sampling texts in the creation of a corpus or collection.
  element samplingDecl {
    tei_samplingDecl.content, tei_samplingDecl.attributes
  }
tei_samplingDecl.content = tei_model.pLike+
tei_samplingDecl.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  att.declarable.attribute.default,
  empty
tei_editorialDecl =
  
  ## (editorial practice declaration) provides details of editorial principles and practices applied
  ## during the encoding of a text.
  element editorialDecl {
    tei_editorialDecl.content, tei_editorialDecl.attributes
  }
tei_editorialDecl.content =
  tei_model.pLike+ | tei_model.editorialDeclPart+
tei_editorialDecl.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  att.declarable.attribute.default,
  empty
tei_correction =
  
  ## (correction principles) states how and under what circumstances corrections have been
  ## made in the text.
  element correction {
    tei_correction.content, tei_correction.attributes
  }
tei_correction.content = tei_model.pLike+
tei_correction.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  att.declarable.attribute.default,
  
  ## indicates the degree of correction applied to the text.
  ##    
  [ a1:defaultValue = "unknown" ]
  attribute status {
    
    ## (the text has been thoroughly checked and
    ##                        proofread.
    ##     ) 
    "high"
    | 
      ## (the text has been checked at least once.
      ##     ) 
      "medium"
    | 
      ## (the text has not been checked.
      ##     ) 
      "low"
    | 
      ## (the correction status of the text is unknown.
      ##    ) 
      "unknown"
  }?,
  
  ## indicates the method adopted to indicate corrections within the
  ##          text.
  ##    
  [ a1:defaultValue = "silent" ]
  attribute method {
    
    ## (corrections have been made silently
    ##     ) 
    "silent"
    | 
      ## (corrections have been represented using editorial tags
      ##    ) 
      "tags"
  }?,
  empty
tei_normalization =
  
  ## indicates the extent of normalization or regularization of the
  ## original source carried out in converting it to electronic form.
  element normalization {
    tei_normalization.content, tei_normalization.attributes
  }
tei_normalization.content = tei_model.pLike+
tei_normalization.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  att.declarable.attribute.default,
  
  ## indicates the authority for any normalization carried out.
  ##     
  attribute source { tei_data.pointer }?,
  
  ## indicates the method adopted to indicate normalizations within
  ##          the text.
  ##    
  [ a1:defaultValue = "silent" ]
  attribute method {
    
    ## (normalization made silently
    ##   ) 
    "silent"
    | 
      ## (normalization represented using editorial tags
      ##    ) 
      "tags"
  }?,
  empty
tei_quotation =
  
  ## specifies editorial practice adopted with respect to quotation
  ##   marks in the original. 
  element quotation { tei_quotation.content, tei_quotation.attributes }
tei_quotation.content = tei_model.pLike+
tei_quotation.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  att.declarable.attribute.default,
  
  ## indicates whether or not quotation marks have been retained as
  ##       content within the text. 
  [ a1:defaultValue = "all" ]
  attribute marks {
    
    ## (no quotation marks have been retained ) 
    "none"
    | 
      ## (some quotation marks have been retained ) 
      "some"
    | 
      ## (all quotation marks have been retained ) 
      "all"
  }?,
  
  ## specifies how quotation marks are indicated within the
  ##       text.
  [ a1:defaultValue = "unknown" ]
  attribute form {
    
    ## (quotation marks are retained as data.) 
    "data"
    | 
      ## (the rendition attribute is consistently used to
      ##           indicate the form of quotation marks.) 
      "rend"
    | 
      ## (use of quotation marks has been standardized.) 
      "std"
    | 
      ## (quotation marks are represented inconsistently.) 
      "nonstd"
    | 
      ## (use of quotation marks is unknown.) 
      "unknown"
  }?,
  empty
tei_hyphenation =
  
  ## (Hyphenation) summarizes the way in which hyphenation in a source text has been
  ## treated in an encoded version of it.
  element hyphenation {
    tei_hyphenation.content, tei_hyphenation.attributes
  }
tei_hyphenation.content = tei_model.pLike+
tei_hyphenation.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  att.declarable.attribute.default,
  
  ## indicates whether or not end-of-line hyphenation has been
  ##	retained in a text.
  [ a1:defaultValue = "some" ]
  attribute eol {
    
    ## (all end-of-line hyphenation has been retained,
    ##                    even though the lineation of the original
    ##                    may not have been.
    ##    ) 
    "all"
    | 
      ## (end-of-line hyphenation has been retained in some
      ##                    cases.
      ##    ) 
      "some"
    | 
      ## (all soft end-of-line hyphenation has been removed:
      ##                    any remaining end-od-line hyphenation should be retained.
      ##   ) 
      "hard"
    | 
      ## (all end-of-line hyphenation has been removed:
      ##                   any remaining hyphenation occurred within the line.
      ##    ) 
      "none"
  }?,
  empty
tei_segmentation =
  
  ## describes the principles according to which the text has been
  ## segmented, for example into sentences, tone-units, graphemic strata,
  ## etc.
  element segmentation {
    tei_segmentation.content, tei_segmentation.attributes
  }
tei_segmentation.content = tei_model.pLike+
tei_segmentation.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  att.declarable.attribute.default,
  empty
tei_stdVals =
  
  ## (Standard values) specifies the format used when standardized date or number
  ## values are supplied.
  element stdVals { tei_stdVals.content, tei_stdVals.attributes }
tei_stdVals.content = tei_model.pLike+
tei_stdVals.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  att.declarable.attribute.default,
  empty
tei_interpretation =
  
  ## describes the scope of any analytic or interpretive information
  ## added to the text in addition to the transcription. 
  element interpretation {
    tei_interpretation.content, tei_interpretation.attributes
  }
tei_interpretation.content = tei_model.pLike+
tei_interpretation.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  att.declarable.attribute.default,
  empty
tei_tagsDecl =
  
  ## (tagging declaration) provides detailed information about the tagging applied to an SGML or XML document.
  element tagsDecl { tei_tagsDecl.content, tei_tagsDecl.attributes }
tei_tagsDecl.content = tei_rendition*, tei_namespace*
tei_tagsDecl.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  empty
tei_tagUsage =
  
  ## (tag usage) supplies information about the usage of a specific element
  ## within a text. 
  element tagUsage { tei_tagUsage.content, tei_tagUsage.attributes }
tei_tagUsage.content = tei_macro.paraContent
tei_tagUsage.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  
  ## the name (generic identifier)
  ## of the element indicated by the tag.
  attribute gi { tei_data.name },
  
  ## specifies the number of occurrences of this element within the text.
  ##  
  attribute occurs { tei_data.count }?,
  
  ## specifies the number of occurrences of this element within the text
  ## which bear a distinct value for the global xml:id attribute. 
  attribute withId { tei_data.count }?,
  
  ## specifies the identifier of a rendition element which
  ## defines how this element is to be rendered.
  attribute render { tei_data.pointer }?,
  empty
tei_namespace =
  
  ## supplies the formal name of the namespace to which the elements
  ## documented by its children belong. 
  element namespace { tei_namespace.content, tei_namespace.attributes }
tei_namespace.content = tei_tagUsage+
tei_namespace.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  
  ## the full formal name of the namespace concerned.
  attribute name { tei_data.namespace },
  empty
tei_rendition =
  
  ## (rendition) supplies information about the intended rendition of one or more
  ## elements.
  element rendition { tei_rendition.content, tei_rendition.attributes }
tei_rendition.content = tei_macro.paraContent
tei_rendition.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  empty
tei_refsDecl =
  
  ## (references declaration) specifies how canonical references are constructed for this
  ##   text.
  element refsDecl { tei_refsDecl.content, tei_refsDecl.attributes }
tei_refsDecl.content = tei_model.pLike+ | tei_cRefPattern+ | tei_state+
tei_refsDecl.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  att.declarable.attribute.default,
  
  ## identifies the document type within which
  ##       this reference declaration is used.
  [ a1:defaultValue = "TEI" ] attribute doctype { tei_data.name }?,
  empty
tei_cRefPattern =
  
  ## (defines how to convert a canonical reference into a URI) specifies an expression and replacement pattern for
  ##   tranforming a canonical reference into a URI
  element cRefPattern {
    tei_cRefPattern.content, tei_cRefPattern.attributes
  }
tei_cRefPattern.content = tei_model.pLike*
tei_cRefPattern.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  
  ## specifies a regular expression against which the values of
  ##       cRef attributes can be matched.
  attribute matchPattern { tei_data.pattern },
  
  ## specifies a replacement pattern
  ##       which, once subpattern substitution has been performed, provides
  ##       a URI.
  attribute replacementPattern { text },
  empty
tei_state =
  
  ## specifies one component of a canonical reference defined by
  ## the milestone method.
  element state { tei_state.content, tei_state.attributes }
tei_state.content = empty
tei_state.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  
  ## indicates which edition or version the milestone applies to.
  attribute ed { tei_data.code }?,
  
  ## indicates what kind of state is changing at this milestone.
  ## Suggested values include: 1] page (page breaks in the reference edition.
  ##     ); 2] column (column breaks.
  ##     ); 3] line (line breaks.
  ##     ); 4] book (any units termed book, liber, etc.
  ##     ); 5] poem (individual poems in a collection.
  ##     ); 6] canto (cantos or other major sections of a poem.
  ##     ); 7] stanza (stanzas within a poem, book, or canto.
  ##     ); 8] act (acts within a play.
  ##     ); 9] scene (scenes within a play or act.
  ##     ); 10] section (sections of any kind.
  ##     ); 11] absent (passages not present in the reference edition.)
  attribute unit { tei_data.enumerated },
  
  ## specifies the fixed length of the reference component.
  attribute length { tei_data.count }?,
  
  ## supplies a delimiting string following the reference
  ##           component.
  attribute delim { text }?,
  empty
tei_classDecl =
  
  ## (classification declarations) contains one or more taxonomies defining any classificatory
  ## codes used elsewhere in the text.
  element classDecl { tei_classDecl.content, tei_classDecl.attributes }
tei_classDecl.content = tei_taxonomy+
tei_classDecl.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  empty
tei_taxonomy =
  
  ## (taxonomy) defines a typology used to classify texts either implicitly, by
  ## means of a bibliographic citation, or explicitly by a structured
  ## taxonomy.
  element taxonomy { tei_taxonomy.content, tei_taxonomy.attributes }
tei_taxonomy.content =
  tei_model.glossLike*
  | tei_category+
  | (tei_model.biblLike, tei_category*)
tei_taxonomy.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  empty
tei_category =
  
  ## (category) contains an individual descriptive category, possibly nested
  ## within a superordinate category, within a user-defined taxonomy.
  element category { tei_category.content, tei_category.attributes }
tei_category.content =
  (tei_catDesc | tei_model.glossLike), tei_category*
tei_category.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  empty
tei_catDesc =
  
  ## (category description) describes some category within a taxonomy
  ## or text typology, either in the form of a brief prose description
  ## or in terms of the situational parameters used by the TEI
  ## formal textDesc.
  element catDesc { tei_catDesc.content, tei_catDesc.attributes }
tei_catDesc.content = (text | tei_model.phrase | tei_model.catDescPart)*
tei_catDesc.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  empty
tei_fsdDecl =
  
  ## (FSD (feature-system declaration) declaration) identifies the feature system declaration which contains
  ## definitions for a particular type of feature structure.
  element fsdDecl { tei_fsdDecl.content, tei_fsdDecl.attributes }
tei_fsdDecl.content = empty
tei_fsdDecl.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  
  ## identifies the type of feature structure documented by the FSD;
  ## this will be the value of the type attribute on at least one
  ## feature structure.
  attribute type { tei_data.enumerated },
  
  ## supplies a link to the entity containing the feature system
  ## declaration. 
  attribute url { tei_data.pointer },
  empty
tei_metDecl =
  
  ## documents the notation employed to represent a metrical
  ##   pattern when this is specified as the value of a met,
  ##   real, or rhyme attribute on any structural
  ##   element of a metrical text (e.g. lg, l, or
  ##   seg).
  element metDecl { tei_metDecl.content, tei_metDecl.attributes }
tei_metDecl.content = tei_macro.componentSeq | tei_metSym+
tei_metDecl.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  att.declarable.attribute.default,
  
  ## indicates whether the notation conveys the abstract
  ##       metrical form, its actual prosodic realization, or the rhyme
  ##       scheme, or some combination thereof.
  
  ## Sorry, unable to create schema that uses actual counts minOccurs=1 and maxOccurs=3; approximating to minOccurs=1 and maxOccurs=unbounded.
  [ a1:defaultValue = "met real" ]
  attribute type {
    list { tei_data.enumerated, tei_data.enumerated* }
  }?,
  
  ## specifies a regular expression defining any value that
  ##	is legal for this notation.
  attribute pattern { tei_data.pattern }?,
  empty
tei_metSym =
  
  ## documents the intended significance of a particular character or
  ## character sequence within a metrical notation, either explicitly or in
  ## terms of other symbol elements in the same metDecl.
  element metSym { tei_metSym.content, tei_metSym.attributes }
tei_metSym.content = tei_macro.phraseSeq
tei_metSym.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  
  ## specifies the character or character sequence being documented.
  attribute value {
    list { tei_data.word+ }
  },
  
  ## specifies whether the symbol is defined in terms of other
  ## symbols (terminal is set to false) or in prose
  ## (terminal is set to true).
  [ a1:defaultValue = "true" ]
  attribute terminal {
    
    ## (the element contains a prose definition of its meaning.) 
    "true"
    | 
      ## (the element contains a definition of its meaning given using
      ## symbols defined elsewhere in the same metDecl element.) 
      "false"
  }?,
  empty
tei_variantEncoding =
  
  ## declares the method used to encode text-critical variants.
  element variantEncoding {
    tei_variantEncoding.content, tei_variantEncoding.attributes
  }
tei_variantEncoding.content = empty
tei_variantEncoding.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  
  ## indicates which method is used to encode the apparatus of
  ## variants.
  attribute method {
    
    ## (apparatus uses line numbers or other canonical reference scheme
    ## referenced in a base text.) 
    "location-referenced"
    | 
      ## (apparatus indicates the precise locations of the beginning and
      ## ending of each lemma relative to a base text.) 
      "double-end-point"
    | 
      ## (alternate readings of a passage are given in parallel in the
      ## text; no notion of a base text is necessary.) 
      "parallel-segmentation"
  },
  
  ## indicates whether the apparatus appears within the running text
  ## or external to it.
  attribute location {
    
    ## (apparatus appears within the running text.) 
    "internal"
    | 
      ## (apparatus appears outside the base text.) 
      "external"
  },
  empty
tei_profileDesc =
  
  ## (text-profile description) provides a detailed description of non-bibliographic aspects of a
  ## text, specifically the languages and sublanguages used, the situation in
  ## which it was produced, the participants and their setting.
  element profileDesc {
    tei_profileDesc.content, tei_profileDesc.attributes
  }
tei_profileDesc.content = tei_creation?, tei_model.profileDescPart*
tei_profileDesc.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  empty
tei_creation =
  
  ## contains information about the creation of a text.
  element creation { tei_creation.content, tei_creation.attributes }
tei_creation.content = tei_macro.phraseSeq
tei_creation.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  empty
tei_langUsage =
  
  ## (language usage) describes the languages, sublanguages, registers, dialects etc.
  ## represented within a text.
  element langUsage { tei_langUsage.content, tei_langUsage.attributes }
tei_langUsage.content = tei_language+
tei_langUsage.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  att.declarable.attribute.default,
  empty
tei_language =
  
  ## characterizes a single language or sublanguage used within a
  ##   text.
  element language { tei_language.content, tei_language.attributes }
tei_language.content = tei_macro.phraseSeq
tei_language.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  
  ## Supplies a language code constructed as defined in RFC 3066 (or
  ##       its successor) which is used to identify the language documented
  ##       by this element, and which is referenced by the global xml:lang attribute.
  attribute ident { tei_data.language },
  
  ## specifies the approximate percentage (by volume) of the
  ##       text which uses this language.
  ##       
  attribute usage {
    xsd:nonNegativeInteger { maxInclusive = "100" }
  }?,
  empty
tei_textClass =
  
  ## (text classification) groups information which describes the nature or topic of a text
  ## in terms of a standard classification scheme, thesaurus, etc.
  element textClass { tei_textClass.content, tei_textClass.attributes }
tei_textClass.content = (tei_classCode | tei_catRef | tei_keywords)*
tei_textClass.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  att.declarable.attribute.default,
  empty
tei_keywords =
  
  ## contains a list of keywords or phrases identifying the topic or
  ## nature of a text.
  element keywords { tei_keywords.content, tei_keywords.attributes }
tei_keywords.content = tei_term+ | tei_list
tei_keywords.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  
  ## identifies the controlled vocabulary within which the set of
  ##   keywords concerned is defined.
  ##    
  attribute scheme { tei_data.pointer },
  empty
tei_classCode =
  
  ## contains the classification code used for this text in some
  ## standard classification system.
  element classCode { tei_classCode.content, tei_classCode.attributes }
tei_classCode.content = tei_macro.phraseSeq
tei_classCode.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  
  ## identifies the classification system or taxonomy in use.
  attribute scheme { tei_data.pointer },
  empty
tei_catRef =
  
  ## (category reference) specifies one or more defined categories
  ## within some taxonomy or text typology.
  element catRef { tei_catRef.content, tei_catRef.attributes }
tei_catRef.content = empty
tei_catRef.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  
  ## identifies the categories concerned
  ##    
  attribute target {
    list { tei_data.pointer+ }
  },
  
  ## identifies the classification scheme within which the set of
  ##     categories concerned is defined
  ##    
  attribute scheme { tei_data.pointer }?,
  empty
tei_revisionDesc =
  
  ## (revision description) summarizes the revision history for a file.
  element revisionDesc {
    tei_revisionDesc.content, tei_revisionDesc.attributes
  }
tei_revisionDesc.content = tei_list | tei_change+
tei_revisionDesc.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  empty
tei_change =
  
  ## summarizes a particular change or correction made
  ## to a particular version of an electronic text which is
  ## shared between several researchers.
  element change { tei_change.content, tei_change.attributes }
tei_change.content = tei_macro.specialPara
tei_change.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  att.ascribed.attribute.who,
  
  ## supplies the date of the change in standard form,  i.e. yyyy-mm-dd.
  attribute date { tei_data.temporal }?,
  empty
tei_model.headerPart = tei_encodingDesc | tei_profileDesc
tei_model.headerPart_sequence = tei_encodingDesc, tei_profileDesc
tei_model.headerPart_sequenceOptional =
  tei_encodingDesc?, tei_profileDesc?
tei_model.headerPart_sequenceOptionalRepeatable =
  tei_encodingDesc*, tei_profileDesc*
tei_model.headerPart_sequenceRepeatable =
  tei_encodingDesc+, tei_profileDesc+
tei_model.sourceDescPart = tei_scriptStmt | tei_recordingStmt
tei_model.sourceDescPart_sequence = tei_scriptStmt, tei_recordingStmt
tei_model.sourceDescPart_sequenceOptional =
  tei_scriptStmt?, tei_recordingStmt?
tei_model.sourceDescPart_sequenceOptionalRepeatable =
  tei_scriptStmt*, tei_recordingStmt*
tei_model.sourceDescPart_sequenceRepeatable =
  tei_scriptStmt+, tei_recordingStmt+
tei_model.encodingPart =
  tei_projectDesc
  | tei_samplingDecl
  | tei_editorialDecl
  | tei_tagsDecl
  | tei_refsDecl
  | tei_classDecl
  | tei_fsdDecl
  | tei_metDecl
  | tei_variantEncoding
tei_model.encodingPart_sequence =
  tei_projectDesc,
  tei_samplingDecl,
  tei_editorialDecl,
  tei_tagsDecl,
  tei_refsDecl,
  tei_classDecl,
  tei_fsdDecl,
  tei_metDecl,
  tei_variantEncoding
tei_model.encodingPart_sequenceOptional =
  tei_projectDesc?,
  tei_samplingDecl?,
  tei_editorialDecl?,
  tei_tagsDecl?,
  tei_refsDecl?,
  tei_classDecl?,
  tei_fsdDecl?,
  tei_metDecl?,
  tei_variantEncoding?
tei_model.encodingPart_sequenceOptionalRepeatable =
  tei_projectDesc*,
  tei_samplingDecl*,
  tei_editorialDecl*,
  tei_tagsDecl*,
  tei_refsDecl*,
  tei_classDecl*,
  tei_fsdDecl*,
  tei_metDecl*,
  tei_variantEncoding*
tei_model.encodingPart_sequenceRepeatable =
  tei_projectDesc+,
  tei_samplingDecl+,
  tei_editorialDecl+,
  tei_tagsDecl+,
  tei_refsDecl+,
  tei_classDecl+,
  tei_fsdDecl+,
  tei_metDecl+,
  tei_variantEncoding+
tei_model.editorialDeclPart =
  tei_correction
  | tei_normalization
  | tei_quotation
  | tei_hyphenation
  | tei_segmentation
  | tei_stdVals
  | tei_interpretation
tei_model.editorialDeclPart_sequence =
  tei_correction,
  tei_normalization,
  tei_quotation,
  tei_hyphenation,
  tei_segmentation,
  tei_stdVals,
  tei_interpretation
tei_model.editorialDeclPart_sequenceOptional =
  tei_correction?,
  tei_normalization?,
  tei_quotation?,
  tei_hyphenation?,
  tei_segmentation?,
  tei_stdVals?,
  tei_interpretation?
tei_model.editorialDeclPart_sequenceOptionalRepeatable =
  tei_correction*,
  tei_normalization*,
  tei_quotation*,
  tei_hyphenation*,
  tei_segmentation*,
  tei_stdVals*,
  tei_interpretation*
tei_model.editorialDeclPart_sequenceRepeatable =
  tei_correction+,
  tei_normalization+,
  tei_quotation+,
  tei_hyphenation+,
  tei_segmentation+,
  tei_stdVals+,
  tei_interpretation+
tei_model.profileDescPart = tei_langUsage | tei_textClass
tei_model.profileDescPart_sequence = tei_langUsage, tei_textClass
tei_model.profileDescPart_sequenceOptional =
  tei_langUsage?, tei_textClass?
tei_model.profileDescPart_sequenceOptionalRepeatable =
  tei_langUsage*, tei_textClass*
tei_model.profileDescPart_sequenceRepeatable =
  tei_langUsage+, tei_textClass+
tei_TEI =
  
  ## (TEI document) contains a single TEI-conformant document,
  ## comprising a TEI header and a text, either in isolation or as part of a
  ## teiCorpus element.
  element TEI { tei_TEI.content, tei_TEI.attributes }
tei_TEI.content = tei_teiHeader, tei_text
tei_TEI.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  
  ## The version of the TEI scheme
  [ a1:defaultValue = "5.0" ] attribute version { xsd:decimal }?,
  empty
tei_text =
  
  ## contains a single text of any kind, whether unitary or
  ## composite, for example a poem or drama, a collection of essays, a novel,
  ## a dictionary, or a corpus sample.
  element text { tei_text.content, tei_text.attributes }
tei_text.content =
  tei_model.global*,
  (tei_front, tei_model.global*)?,
  (tei_body | tei_group),
  tei_model.global*,
  (tei_back, tei_model.global*)?
tei_text.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  att.declaring.attribute.decls,
  empty
tei_body =
  
  ## (text body) contains the whole body of a single unitary text, excluding any front or back matter.
  element body { tei_body.content, tei_body.attributes }
tei_body.content =
  tei_model.global*,
  (tei_model.divWrapper, (tei_model.global | tei_model.divWrapper)*)?,
  (tei_model.divGenLike, (tei_model.global | tei_model.divGenLike)*)?,
  ((tei_model.divLike, (tei_model.global | tei_model.divGenLike)*)+
   | (tei_model.div1Like, (tei_model.global | tei_model.divGenLike)*)+
   | ((tei_macro.component, tei_model.global*)+,
      ((tei_model.divLike, (tei_model.global | tei_model.divGenLike)*)+
       | (tei_model.div1Like,
          (tei_model.global | tei_model.divGenLike)*)+)?)),
  (tei_model.divWrapper.bottom, tei_model.global*)*
tei_body.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  att.declaring.attribute.decls,
  empty
tei_group =
  
  ## contains the body of a composite text, grouping together a
  ## sequence of distinct texts (or groups of such texts) which are regarded
  ## as a unit for some purpose, for example the collected works of an
  ## author, a sequence of prose essays, etc.
  element group { tei_group.content, tei_group.attributes }
tei_group.content =
  (tei_model.divWrapper | tei_model.global)*,
  ((tei_text | tei_group), (tei_text | tei_group | tei_model.global)*),
  tei_model.divWrapper.bottom*
tei_group.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  att.declaring.attribute.decls,
  empty
tei_div =
  
  ## (text division) contains a subdivision of the front, body, or back of a
  ## text.
  element div { tei_div.content, tei_div.attributes }
tei_div.content =
  (tei_model.divWrapper | tei_model.global)*,
  ((((tei_div | tei_divGen), tei_model.global*)+
    | ((tei_macro.component, tei_model.global*)+,
       ((tei_div | tei_divGen), tei_model.global*)*)),
   ((tei_model.divWrapper | tei_model.divWrapper.bottom),
    tei_model.global*)*)?
tei_div.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  att.divLike.attribute.type,
  att.divLike.attribute.org,
  att.divLike.attribute.sample,
  att.divLike.attribute.part,
  att.declaring.attribute.decls,
  empty
tei_div1 =
  
  ## (level-1 text division) contains a first-level subdivision of the front, body, or back
  ## of a text.
  element div1 { tei_div1.content, tei_div1.attributes }
tei_div1.content =
  (tei_model.divWrapper | tei_model.global)*,
  (((tei_model.div2Like | tei_model.divGenLike), tei_model.global*)+
   | ((tei_macro.component, tei_model.global*)+,
      ((tei_model.div2Like | tei_model.divGenLike),
       tei_model.global*)*)),
  ((tei_model.divWrapper | tei_model.divWrapper.bottom),
   tei_model.global*)*
tei_div1.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  att.divLike.attribute.type,
  att.divLike.attribute.org,
  att.divLike.attribute.sample,
  att.divLike.attribute.part,
  att.declaring.attribute.decls,
  empty
tei_div2 =
  
  ## (level-2 text division) contains a second-level subdivision of the front, body, or back of a
  ##  text.
  element div2 { tei_div2.content, tei_div2.attributes }
tei_div2.content =
  (tei_model.divWrapper | tei_model.global)*,
  (((tei_model.div3Like | tei_model.divGenLike), tei_model.global*)+
   | ((tei_macro.component, tei_model.global*)+,
      ((tei_model.div3Like | tei_model.divGenLike),
       tei_model.global*)*)),
  ((tei_model.divWrapper | tei_model.divWrapper.bottom),
   tei_model.global*)*
tei_div2.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  att.divLike.attribute.type,
  att.divLike.attribute.org,
  att.divLike.attribute.sample,
  att.divLike.attribute.part,
  att.declaring.attribute.decls,
  empty
tei_div3 =
  
  ## (level-3 text division) contains a third-level subdivision of the front, body, or back of a
  ##  text.
  element div3 { tei_div3.content, tei_div3.attributes }
tei_div3.content =
  (tei_model.divWrapper | tei_model.global)*,
  (((tei_model.div4Like | tei_model.divGenLike), tei_model.global*)+
   | ((tei_macro.component, tei_model.global*)+,
      ((tei_model.div4Like | tei_model.divGenLike),
       tei_model.global*)*)),
  ((tei_model.divWrapper | tei_model.divWrapper.bottom),
   tei_model.global*)*
tei_div3.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  att.divLike.attribute.type,
  att.divLike.attribute.org,
  att.divLike.attribute.sample,
  att.divLike.attribute.part,
  att.declaring.attribute.decls,
  empty
tei_div4 =
  
  ## (level-4 text division) contains a fourth-level subdivision of the front, body, or back of a
  ##  text.
  element div4 { tei_div4.content, tei_div4.attributes }
tei_div4.content =
  (tei_model.divWrapper | tei_model.global)*,
  (((tei_model.div5Like | tei_model.divGenLike), tei_model.global*)+
   | ((tei_macro.component, tei_model.global*)+,
      ((tei_model.div5Like | tei_model.divGenLike),
       tei_model.global*)*)),
  ((tei_model.divWrapper | tei_model.divWrapper.bottom),
   tei_model.global*)*
tei_div4.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  att.divLike.attribute.type,
  att.divLike.attribute.org,
  att.divLike.attribute.sample,
  att.divLike.attribute.part,
  att.declaring.attribute.decls,
  empty
tei_div5 =
  
  ## (level-5 text division) contains a fifth-level subdivision of the front, body, or back of a
  ##  text.
  element div5 { tei_div5.content, tei_div5.attributes }
tei_div5.content =
  (tei_model.divWrapper | tei_model.global)*,
  (((tei_model.div6Like | tei_model.divGenLike), tei_model.global*)+
   | ((tei_macro.component, tei_model.global*)+,
      ((tei_model.div6Like | tei_model.divGenLike),
       tei_model.global*)*)),
  ((tei_model.divWrapper | tei_model.divWrapper.bottom),
   tei_model.global*)*
tei_div5.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  att.divLike.attribute.type,
  att.divLike.attribute.org,
  att.divLike.attribute.sample,
  att.divLike.attribute.part,
  att.declaring.attribute.decls,
  empty
tei_div6 =
  
  ## (level-6 text division) contains a sixth-level subdivision of the front, body, or back of a
  ##  text.
  element div6 { tei_div6.content, tei_div6.attributes }
tei_div6.content =
  (tei_model.divWrapper | tei_model.global)*,
  (((tei_model.div7Like | tei_model.divGenLike), tei_model.global*)+
   | ((tei_macro.component, tei_model.global*)+,
      ((tei_model.div7Like | tei_model.divGenLike),
       tei_model.global*)*)),
  ((tei_model.divWrapper | tei_model.divWrapper.bottom),
   tei_model.global*)*
tei_div6.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  att.divLike.attribute.type,
  att.divLike.attribute.org,
  att.divLike.attribute.sample,
  att.divLike.attribute.part,
  att.declaring.attribute.decls,
  empty
tei_div7 =
  
  ## (level-7 text division) contains the smallest possible subdivision of the front, body or
  ## back of a text, larger than a paragraph.
  element div7 { tei_div7.content, tei_div7.attributes }
tei_div7.content =
  (tei_model.divWrapper | tei_model.global)*,
  (tei_macro.component, tei_model.global*)+,
  ((tei_model.divWrapper | tei_model.divWrapper.bottom),
   tei_model.global*)*
tei_div7.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  att.divLike.attribute.type,
  att.divLike.attribute.org,
  att.divLike.attribute.sample,
  att.divLike.attribute.part,
  att.declaring.attribute.decls,
  empty
tei_trailer =
  
  ## (trailer) contains a closing title or footer appearing at the end of
  ## a division of a text. 
  element trailer { tei_trailer.content, tei_trailer.attributes }
tei_trailer.content = tei_macro.phraseSeq
tei_trailer.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  empty
tei_byline =
  
  ## contains the primary statement of responsibility given for a work
  ## on its title page or at the head or end of the work.
  element byline { tei_byline.content, tei_byline.attributes }
tei_byline.content =
  (text
   | tei_model.gLike
   | tei_model.phrase
   | tei_docAuthor
   | tei_model.global)*
tei_byline.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  empty
tei_dateline =
  
  ## contains a brief description of the place, date, time, etc. of
  ##	production of a letter, newspaper story, or other work, prefixed or
  ##	suffixed to it as a kind of heading or trailer. 
  element dateline { tei_dateline.content, tei_dateline.attributes }
tei_dateline.content = tei_macro.phraseSeq
tei_dateline.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  empty
tei_argument =
  
  ## A formal list or prose description of the topics addressed by
  ##	a subdivision of a text.
  element argument { tei_argument.content, tei_argument.attributes }
tei_argument.content =
  tei_model.global*,
  (tei_head, tei_model.global*)?,
  (tei_macro.component, tei_model.global*)+
tei_argument.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  empty
tei_epigraph =
  
  ## (epigraph) contains a quotation, anonymous or attributed, appearing at
  ## the start of a section or chapter, or on a title page. 
  element epigraph { tei_epigraph.content, tei_epigraph.attributes }
tei_epigraph.content = tei_macro.componentSeq
tei_epigraph.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  empty
tei_opener =
  
  ## groups together dateline, byline, salutation, and similar
  ## phrases appearing as a preliminary group at the start of a
  ## division, especially of a letter.
  element opener { tei_opener.content, tei_opener.attributes }
tei_opener.content =
  (text
   | tei_model.gLike
   | tei_model.phrase
   | tei_argument
   | tei_byline
   | tei_dateline
   | tei_epigraph
   | tei_salute
   | tei_signed
   | tei_model.global)*
tei_opener.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  empty
tei_closer =
  
  ## groups together dateline, byline, salutation, and similar
  ## phrases appearing as a final group at the end of a
  ## division, especially of a letter.
  element closer { tei_closer.content, tei_closer.attributes }
tei_closer.content =
  (text
   | tei_model.gLike
   | tei_signed
   | tei_dateline
   | tei_salute
   | tei_model.phrase
   | tei_model.global)*
tei_closer.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  empty
tei_salute =
  
  ## (salutation) contains a salutation or greeting prefixed to a foreword,
  ## dedicatory epistle, or other division of a text, or the
  ## salutation in the closing of a letter, preface, etc.
  element salute { tei_salute.content, tei_salute.attributes }
tei_salute.content = tei_macro.phraseSeq
tei_salute.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  empty
tei_signed =
  
  ## (signature) contains the closing salutation, etc., appended to a foreword,
  ## dedicatory epistle, or other division of a text. 
  element signed { tei_signed.content, tei_signed.attributes }
tei_signed.content = tei_macro.phraseSeq
tei_signed.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  empty
tei_titlePage =
  
  ## (title page) contains the title page of a text, appearing within the front
  ## or back matter. 
  element titlePage { tei_titlePage.content, tei_titlePage.attributes }
tei_titlePage.content =
  tei_model.global*,
  tei_model.titlepagePart,
  (tei_model.titlepagePart | tei_model.global)*
tei_titlePage.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  
  ## classifies the title page according to any convenient typology.
  attribute type { tei_data.enumerated }?,
  empty
tei_docTitle =
  
  ## (document title) contains the title of a document, including all its
  ## constituents, as given on a title page.
  element docTitle { tei_docTitle.content, tei_docTitle.attributes }
tei_docTitle.content =
  tei_model.global*, (tei_titlePart, tei_model.global*)+
tei_docTitle.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  empty
tei_titlePart =
  
  ## (title part) contains a subsection or division of the title of a work, as
  ## indicated on a title page.
  element titlePart { tei_titlePart.content, tei_titlePart.attributes }
tei_titlePart.content = tei_macro.paraContent
tei_titlePart.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  
  ## specifies the role of this subdivision of the title.
  ## Suggested values include: 1] main (main title of the work
  ##         ); 2] sub (subtitle  of the work
  ##         ); 3] alt (alternative title  of the work
  ##         ); 4] short (abbreviated form of title); 5] desc (descriptive paraphrase of the work 
  ##    )
  [ a1:defaultValue = "main" ] attribute type { tei_data.enumerated }?,
  empty
tei_docAuthor =
  
  ## (document author) contains the name of the author of the document, as given on the
  ## title page (often but not always contained in a byline).
  element docAuthor { tei_docAuthor.content, tei_docAuthor.attributes }
tei_docAuthor.content = tei_macro.phraseSeq
tei_docAuthor.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  empty
tei_imprimatur =
  
  ## contains a formal statement authorizing the publication of
  ## a work, sometimes required to appear on a title page or its verso.
  element imprimatur {
    tei_imprimatur.content, tei_imprimatur.attributes
  }
tei_imprimatur.content = tei_macro.paraContent
tei_imprimatur.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  empty
tei_docEdition =
  
  ## (document edition) contains an edition statement as presented on a title page of a
  ## document.
  element docEdition {
    tei_docEdition.content, tei_docEdition.attributes
  }
tei_docEdition.content = tei_macro.paraContent
tei_docEdition.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  empty
tei_docImprint =
  
  ## (document imprint) contains the imprint statement (place and date of publication,
  ## publisher name), as given
  ## (usually) at the foot of a title page.
  element docImprint {
    tei_docImprint.content, tei_docImprint.attributes
  }
tei_docImprint.content =
  (text
   | tei_model.gLike
   | tei_model.phrase
   | tei_pubPlace
   | tei_docDate
   | tei_publisher
   | tei_model.global)*
tei_docImprint.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  empty
tei_docDate =
  
  ## (document date) contains the date of a document, as given
  ## (usually) on a title page.
  element docDate { tei_docDate.content, tei_docDate.attributes }
tei_docDate.content = tei_macro.phraseSeq
tei_docDate.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  
  ## gives the value of the date in a standard form, generally YYYY-MM-DD.
  attribute value { tei_data.temporal }?,
  empty
tei_front =
  
  ## (front matter) contains any prefatory matter (headers,
  ## title page, prefaces, dedications, etc.)
  ## found  at the start of a document, before the main body.
  element front { tei_front.content, tei_front.attributes }
tei_front.content =
  (tei_model.frontPart | tei_model.pLike.front | tei_model.global)*,
  ((tei_model.div1Like,
    (tei_model.frontPart | tei_model.div1Like | tei_model.global)*)
   | (tei_model.divLike,
      (tei_model.frontPart | tei_model.divLike | tei_model.global)*))?
tei_front.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  att.declaring.attribute.decls,
  empty
tei_back =
  
  ## (back matter) contains any appendixes, etc. following the main part of a
  ## text.
  element back { tei_back.content, tei_back.attributes }
tei_back.content =
  (tei_model.frontPart | tei_model.global | tei_model.divWrapper)*,
  ((tei_model.divLike, (tei_model.global | tei_model.frontPart)*)+
   | (tei_model.div1Like, (tei_model.global | tei_model.frontPart)*)+)?,
  tei_model.divWrapper.bottom*
tei_back.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  att.declaring.attribute.decls,
  empty
tei_table =
  
  ## contains text displayed in tabular form, in
  ## rows and columns.
  element table { tei_table.content, tei_table.attributes }
tei_table.content =
  (tei_head | tei_model.global)*, (tei_row, tei_model.global*)+
tei_table.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  
  ## indicates the number of rows in the table.
  attribute rows { tei_data.count }?,
  
  ## indicates the number of columns in each row of the table.
  attribute cols { tei_data.count }?,
  empty
tei_row =
  
  ## contains one row of a table. 
  element row { tei_row.content, tei_row.attributes }
tei_row.content = ((tei_cell | tei_table), tei_model.global*)+
tei_row.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  att.tableDecoration.attribute.role,
  att.tableDecoration.attribute.rows,
  att.tableDecoration.attribute.cols,
  empty
tei_cell =
  
  ## contains one cell of a table. 
  element cell { tei_cell.content, tei_cell.attributes }
tei_cell.content = tei_macro.paraContent
tei_cell.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  att.tableDecoration.attribute.role,
  att.tableDecoration.attribute.rows,
  att.tableDecoration.attribute.cols,
  empty
tei_formula =
  
  ## contains a mathematical or other formula.
  element formula { tei_formula.content, tei_formula.attributes }
tei_formula.content = text
tei_formula.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  
  ## supplies the name of a previously defined notation used for the
  ## content of the
  ## element.
  attribute notation { tei_data.code }?,
  empty
tei_figure =
  
  ## contains a block containing graphics, illustrations, or figures.
  element figure { tei_figure.content, tei_figure.attributes }
tei_figure.content =
  (tei_model.pLike
   | tei_model.global
   | tei_figure
   | tei_figDesc
   | tei_model.graphicLike
   | tei_head)*
tei_figure.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  empty
tei_figDesc =
  
  ## (Description of Figure) contains a brief prose description of the appearance or content
  ## of a graphic figure, for use when documenting an image without
  ## displaying it.
  element figDesc { tei_figDesc.content, tei_figDesc.attributes }
tei_figDesc.content = tei_macro.paraContent
tei_figDesc.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  empty
start = tei_TEI
