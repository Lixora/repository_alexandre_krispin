namespace a1 = "http://relaxng.org/ns/compatibility/annotations/1.0"
namespace rng = "http://relaxng.org/ns/structure/1.0"

# Schema generated 2007-03-13T16:02:29Z..
# Copyright 2005 TEI Consortium.
# This is free software; you can redistribute it and/or
#	    modify it under the terms of the GNU General Public
#	    License as published by the Free Software Foundation;
#	    either version 2 of the License, or (at your option) any
#	    later version.
# This material is distributed in the hope that it will be
#	    useful, but WITHOUT ANY WARRANTY; without even the implied
#	    warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
#	    PURPOSE. See the GNU General Public License for more
#	    details.
# You should have received a copy of the GNU General Public
#	    License along with this file; if not, write to the Free
#	    Software Foundation, Inc., 59 Temple Place, Suite 330,
#	    Boston, MA 02111-1307, USA.
# To contact the TEI Consortium use the following addresses.
#	    For general (non-technical) enquiries: 
#		  target="mailto:info@tei-c.org"/>info@tei-c.orgFor membership enquiries: membership@tei-c.orgFor technical enquiries, particularly about the
#		Guidelines, DTDs, schemas, or software available from
#		the TEI-C: editors@tei-c.orgFor up to date information, consult the TEI web site at http://www.tei-c.org/P5Linking, segmentation and alignment

# Definitions from module linking

# Set global predeclared macros

# Set predeclared macros

# 0. predeclared macros

# 1. classes
att.global.linking.attributes =
  att.global.linking.attribute.corresp,
  att.global.linking.attribute.synch,
  att.global.linking.attribute.sameAs,
  att.global.linking.attribute.copyOf,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  att.global.linking.attribute.exclude,
  att.global.linking.attribute.select,
  empty
att.global.linking.attribute.corresp =
  ## points to elements that correspond to the current
  ##       element in some way.
  attribute corresp {
    list { data.pointer+ }
  }?
att.global.linking.attribute.synch =
  ## points to elements that are synchronous with the current
  ##       element.
  attribute synch {
    list { data.pointer+ }
  }?
att.global.linking.attribute.sameAs =
  ## points to an element that is the same as the current
  ##       element.
  attribute sameAs { data.pointer }?
att.global.linking.attribute.copyOf =
  ## points to an element of which the current element is a
  ##	copy.
  attribute copyOf { data.pointer }?
att.global.linking.attribute.next =
  ## points to the next element of a virtual aggregate of which
  ##       the current element is part.
  attribute next { data.pointer }?
att.global.linking.attribute.prev =
  ## points to the previous element of a virtual aggregate of
  ##       which the current element is part.
  attribute prev { data.pointer }?
att.global.linking.attribute.exclude =
  ## points to elements that are in exclusive alternation
  ##       with the current element.
  attribute exclude {
    list { data.pointer+ }
  }?
att.global.linking.attribute.select =
  ## selects one or more alternants; if one alternant is
  ##       selected, the ambiguity or uncertainty is marked as resolved. If
  ##       more than one alternant is selected, the degree of ambiguity or
  ##       uncertainty is marked as reduced by the number of alternants not
  ##       selected.
  attribute select {
    list { data.pointer+ }
  }?
att.pointing.attributes =
  att.pointing.attribute.type, att.pointing.attribute.evaluate, empty
att.pointing.attribute.type =
  ## categorizes the pointer in some respect, using any
  ##       convenient set of categories.
  attribute type { data.word }?
att.pointing.attribute.evaluate =
  ## specifies the intended meaning when the target of a
  ##       pointer is itself a pointer.
  attribute evaluate {
    ## (if the element pointed to is itself a pointer, then
    ##	  the target of that pointer will be taken, and so on, until
    ##	  an element is found which is not a pointer.) 
    "all" | ## (if the element pointed to is itself a pointer, then
      ##	  its target (whether a pointer or not) is taken as the target
      ##	  of this pointer.) 
      "one" | ## (no further evaluation of targets is carried out
      ##	  beyond that needed to find the element specified in the
      ##	  pointer's target.) 
      "none"
  }?
att.pointing.group.attributes =
  att.pointing.attributes,
  att.pointing.group.attribute.domains,
  att.pointing.group.attribute.targFunc,
  empty
att.pointing.group.attribute.domains =
  ## optionally specifies the identifiers of the elements
  ##       within which all elements indicated by the contents of this
  ##       element lie.
  attribute domains {
    list { data.name+ }
  }?
att.pointing.group.attribute.targFunc =
  ## describes the function of each of the values of the
  ##       targets attribute of the enclosed link,
  ##       join or alt tags.
  attribute targFunc {
    list { data.word+ }
  }?
# 2. elements

ab =
  ## (anonymous block) contains any arbitrary component-level unit of text, acting as
  ## an anonymous container for phrase or inter level elements analogous to, but
  ## without the semantic baggage of, a paragraph.
  element ab { ab.content, ab.attributes }
ab.content = macro.paraContent
ab.attributes =
  att.global.attributes,
  att.typed.attributes,
  ## specifies whether or not the block is complete. 
  [ a1:defaultValue = "N" ]
  attribute part {
    ## (the block is incomplete) 
    "Y" | ## (either the block is complete, or no claim is made as to its
      ## completeness) 
      "N" | ## (the initial part of an incomplete block) 
      "I" | ## (a medial part of an incomplete block) 
      "M" | ## (the final part of an incomplete block) 
      "F"
  }?,
  empty

alt =
  ## (alternation) identifies an alternation or a set of choices among elements or passages.
  element alt { alt.content, alt.attributes }
alt.content = empty
alt.attributes =
  att.global.attributes,
  att.pointing.attributes,
  ## specifies the identifiers of the alternative elements or passages.
  attribute targets {
    list { data.pointer, data.pointer+ }
  },
  ## states whether the alternations gathered in this collection are exclusive or inclusive.
  attribute mode {
    ## (indicates that the alternation is exclusive, i.e. that
    ##		  at most one of the alternatives occurs.) 
    "excl" | ## (indicates that the alternation is not exclusive, i.e. that
      ##		  one or more of the alternatives occur.) 
      "incl"
  }?,
  ## If mode is excl, each weight
  ##       states the probability that the corresponding alternative
  ##       occurs. If modeincl each weight states
  ##       the probability that the corresponding alternative occurs given
  ##       that at least one of the other alternatives occurs.
  attribute weights {
    list { data.probability+ }
  }?,
  empty

altGrp =
  ## (alternation group) groups a collection of alt elements and possibly
  ## pointers.
  element altGrp { altGrp.content, altGrp.attributes }
altGrp.content = (alt | ptr)*
altGrp.attributes =
  att.global.attributes,
  att.pointing.group.attributes,
  ## states whether the alternations gathered in this collection are
  ## exclusive or inclusive.
  [ a1:defaultValue = "excl" ]
  attribute mode {
    ## (indicates that the alternation is exclusive, i.e. that at
    ## most one of the alternatives occurs.) 
    "excl" | ## (indicates that the alternation is not exclusive, i.e. that
      ## one or more of the alternatives occur.) 
      "incl"
  }?,
  empty

anchor =
  ## (anchor point) attaches an identifier to a
  ## point within a text, whether or not it corresponds with a textual
  ## element.
  element anchor { anchor.content, anchor.attributes }
anchor.content = empty
anchor.attributes = att.global.attributes, att.typed.attributes, empty

join =
  ## identifies a possibly fragmented segment of text, by pointing
  ## at the possibly discontiguous elements which compose it.
  element join { join.content, join.attributes }
join.content = macro.glossSeq
join.attributes =
  att.global.attributes,
  att.pointing.attributes,
  ## specifies the identifiers of the elements or passages
  ##        to be joined into a virtual
  ##        element.
  attribute targets {
    list { data.pointer, data.pointer+ }
  },
  ## specifies the name of an element
  ## which this aggregation
  ## may be understood to represent.
  attribute result { data.name }?,
  ## indicates whether the targets to be joined include the
  ## entire element indicated (the entire subtree including its root),
  ## or just the children of the target (the branches of the subtree).
  [ a1:defaultValue = "root" ]
  attribute scope {
    ## (the rooted subtrees indicated by the targets
    ## attribute are joined, each subtree become a child of the virtual
    ## element created by the join) 
    "root" | ## (the children of the subtrees indicated by the
      ## targets attribute become the children of the virtual element
      ## (i.e. the roots of the subtrees are discarded)) 
      "branches"
  }?,
  empty

joinGrp =
  ## (join group) groups a collection of join elements and possibly
  ##   pointers.
  element joinGrp { joinGrp.content, joinGrp.attributes }
joinGrp.content = macro.glossSeq?, (join | ptr)+
joinGrp.attributes =
  att.global.attributes,
  att.pointing.group.attributes,
  ## describes the result of the joins gathered in this collection.
  attribute result { data.name }?,
  empty

link =
  ## defines an association or hypertextual link
  ## among elements or passages, of some type
  ## not more precisely specifiable by other elements.
  element link { link.content, link.attributes }
link.content = empty
link.attributes =
  att.global.attributes,
  att.pointing.attributes,
  ## specifies the identifiers of the elements or passages
  ##     to be linked or associated.
  attribute targets {
    list { data.pointer, data.pointer+ }
  },
  empty

linkGrp =
  ## defines a collection of associations or hypertextual links.
  element linkGrp { linkGrp.content, linkGrp.attributes }
linkGrp.content = (link | ptr)+
linkGrp.attributes =
  att.global.attributes, att.pointing.group.attributes, empty

seg =
  ## (arbitrary segment) contains any arbitrary phrase-level unit of text (including
  ## other seg elements).
  element seg { seg.content, seg.attributes }
seg.content = macro.paraContent
seg.attributes =
  att.global.attributes,
  att.segLike.attributes,
  ## provides a sub-categorization of the segment marked.
  attribute subtype { data.word }?,
  empty

timeline =
  ## (timeline) provides a set of ordered points in time which can be linked to
  ## elements of a spoken text to create a temporal alignment of that text.
  element timeline { timeline.content, timeline.attributes }
timeline.content = when+
timeline.attributes =
  att.global.attributes,
  ## designates the origin of the timeline, i.e. the time at which it
  ## begins.
  attribute origin { data.pointer },
  ## specifies the unit of time corresponding to the
  ##	interval value of the timeline or of its
  ##	constituent points in time.
  ## Suggested values include: 1] d (days); 2] h (hours); 3] m (minutes); 4] s (seconds); 5] ms (milliseconds)
  attribute unit { data.enumerated }?,
  ## specifies the numeric portion of a time interval
  attribute interval {
    xsd:float { minExclusive = "0" }
    | "regular"
    | "irregular"
  }?,
  empty

when =
  ## (when) indicates a point in time either relative to other elements in the
  ## same timeline tag, or absolutely.
  element when { when.content, when.attributes }
when.content = empty
when.attributes =
  att.global.attributes,
  ## supplies an absolute value for the time.
  attribute absolute { data.temporal }?,
  ## specifies the unit of time in which the  interval
  ## value is expressed, if this is not inherited from the parent timeLine.
  ## Suggested values include: 1] s (seconds); 2] ms (milliseconds); 3] m (minutes); 4] h (hours); 5] d (days)
  attribute unit { data.enumerated }?,
  ## specifies the numeric portion of a time interval
  attribute interval {
    xsd:float { minExclusive = "0" }
    | "unknown"
  }?,
  ## identifies the reference point for determining the time of the
  ## current when element, which is obtained by adding the interval to the
  ## time of the reference point.
  attribute since { data.pointer }?,
  empty
# 3. macros
