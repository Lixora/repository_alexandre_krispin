namespace a1 = "http://relaxng.org/ns/compatibility/annotations/1.0"
namespace rng = "http://relaxng.org/ns/structure/1.0"

# Schema generated 2007-03-13T16:02:29Z..
# Copyright 2005 TEI Consortium.
# This is free software; you can redistribute it and/or
#	    modify it under the terms of the GNU General Public
#	    License as published by the Free Software Foundation;
#	    either version 2 of the License, or (at your option) any
#	    later version.
# This material is distributed in the hope that it will be
#	    useful, but WITHOUT ANY WARRANTY; without even the implied
#	    warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
#	    PURPOSE. See the GNU General Public License for more
#	    details.
# You should have received a copy of the GNU General Public
#	    License along with this file; if not, write to the Free
#	    Software Foundation, Inc., 59 Temple Place, Suite 330,
#	    Boston, MA 02111-1307, USA.
# To contact the TEI Consortium use the following addresses.
#	    For general (non-technical) enquiries: 
#		  target="mailto:info@tei-c.org"/>info@tei-c.orgFor membership enquiries: membership@tei-c.orgFor technical enquiries, particularly about the
#		Guidelines, DTDs, schemas, or software available from
#		the TEI-C: editors@tei-c.orgFor up to date information, consult the TEI web site at http://www.tei-c.org/P5Graphs, networks and trees

# Definitions from module nets

# Set global predeclared macros

# Set predeclared macros

# 0. predeclared macros

# 1. classes

# 2. elements

arc =
  ## encodes an arc, the connection from one node to another in a graph.
  element arc { arc.content, arc.attributes }
arc.content = (label, label?)?
arc.attributes =
  att.global.attributes,
  ## gives the identifier of the node which is adjacent from this arc.
  attribute from { data.pointer },
  ## gives the identifier of the node which is adjacent to this arc.
  attribute to { data.pointer },
  empty

eLeaf =
  ## (Leaf of an embedding tree.) provides explicitly for a leaf of an embedding tree, which may also
  ## be encoded with the eTree element.
  element eLeaf { eLeaf.content, eLeaf.attributes }
eLeaf.content = label?
eLeaf.attributes =
  att.global.attributes,
  ## provides the value of an embedding leaf, which is a feature
  ## structure or other analytic element.
  attribute value { data.pointer }?,
  empty

eTree =
  ## (embedding tree) provides an alternative to tree element for representing
  ## ordered rooted tree structures.
  element eTree { eTree.content, eTree.attributes }
eTree.content = label?, (eTree | triangle | eLeaf)*
eTree.attributes =
  att.global.attributes,
  ## provides the value of an embedding tree, which is a feature
  ## structure or other analytic element.
  attribute value { data.pointer }?,
  empty

forest =
  ## provides for groups of rooted trees.
  element forest { forest.content, forest.attributes }
forest.content = (tree | eTree | triangle)+
forest.attributes =
  att.global.attributes,
  ## identifies the type of the forest.
  attribute type { data.enumerated }?,
  empty

forestGrp =
  ## (Forest group) provides for groups of forests.
  element forestGrp { forestGrp.content, forestGrp.attributes }
forestGrp.content = forest+
forestGrp.attributes =
  att.global.attributes,
  ## identifies the type of the forest group.
  attribute type { data.enumerated }?,
  empty

graph =
  ## encodes a graph, which is a collection of nodes, and arcs which
  ## connect the nodes.
  element graph { graph.content, graph.attributes }
graph.content =
  (label, model.global*)?,
  (((node, model.global*)+, (arc, model.global*)*)
   | ((arc, model.global*)+, (node, model.global*)+))
graph.attributes =
  att.global.attributes,
  ## describes the type of graph.
  ## Suggested values include: 1] undirected (undirected graph); 2] directed (directed graph); 3] transitionNetwork (a directed graph with distinguished initial and final nodes); 4] transducer (a transition network with up to two labels on each arc)
  attribute type { data.enumerated }?,
  ## states the order of the graph, i.e., the number of its nodes.
  attribute order { data.count }?,
  ## states the size of the graph, i.e., the number of its arcs.
  attribute size { data.count }?,
  empty

iNode =
  ## (intermediate (or internal) node) represents an intermediate (or internal) node of a tree.
  element iNode { iNode.content, iNode.attributes }
iNode.content = label?
iNode.attributes =
  att.global.attributes,
  ## provides the value of an intermediate node, which is a feature
  ## structure or other analytic element.
  attribute value { data.pointer }?,
  ## provides a list of identifiers of the elements which are the children of
  ## the intermediate node.
  attribute children {
    list { data.pointer+ }
  },
  ## provides the identifier of the element which is the parent of this node.
  attribute parent { data.pointer }?,
  ## indicates whether or not the internal node is ordered.
  attribute ord {
    ## (indicates that the children of the intermediate node are ordered.) 
    "true" | ## (indicates that the children of the intermediate node are unordered.) 
      "false"
  }?,
  ## provides an identifier of
  ## the element which this node
  ## follows.
  attribute follow { data.pointer }?,
  ## gives the out degree of an intermediate node, the number of its
  ## children.
  attribute outDegree { data.count }?,
  empty

leaf =
  ## encodes the leaves (terminal nodes) of a tree.
  element leaf { leaf.content, leaf.attributes }
leaf.content = label?
leaf.attributes =
  att.global.attributes,
  ## provides the value of a leaf, which is a feature
  ## structure or other analytic element.
  attribute value { data.pointer }?,
  ## provides the identifier of parent of a leaf.
  attribute parent { data.pointer }?,
  ## provides an identifier of an element which this leaf follows.
  attribute follow { data.pointer }?,
  empty

node =
  ## encodes a node, a possibly labeled point in a graph.
  element node { node.content, node.attributes }
node.content = (label, label?)?
node.attributes =
  att.global.attributes,
  ## provides the value of a node, which is a feature structure or
  ## other analytic element.
  attribute value { data.pointer }?,
  ## provides a type for a node.
  ## Suggested values include: 1] initial (initial node in a transition network); 2] final (final node in a transition network)
  attribute type { data.enumerated }?,
  ## gives the identifiers of the nodes which are adjacent to the current node.
  attribute adjTo {
    list { data.pointer+ }
  }?,
  ## gives the identifiers of the nodes which are adjacent from the current
  ## node.
  attribute adjFrom {
    list { data.pointer+ }
  }?,
  ## gives the identifiers of the nodes which are both adjacent to and
  ## adjacent from the current node.
  attribute adj {
    list { data.pointer+ }
  }?,
  ## gives the in degree of the node, the number of nodes which
  ## are adjacent from the given node.
  attribute inDegree { data.count }?,
  ## gives the out degree of the node, the number of nodes which
  ## are adjacent to the given node.
  attribute outDegree { data.count }?,
  ## gives the degree of the node, the number of arcs with which
  ## the node is incident.
  attribute degree { data.count }?,
  empty

root =
  ## (root node) represents the root node of a tree.
  element root { root.content, root.attributes }
root.content = label?
root.attributes =
  att.global.attributes,
  ## provides the value of the root, which is a feature structure or
  ## other analytic element.
  attribute value { data.pointer }?,
  ## provides a list of identifiers of the elements which are the children of
  ## the root node.
  attribute children {
    list { data.pointer+ }
  },
  ## indicates whether or not the root is ordered.
  attribute ord {
    ## (indicates that the children of the root are ordered.) 
    "true" | ## (indicates that the children of the root are unordered.) 
      "false"
  }?,
  ## gives the out degree of the root, the number of its children.
  attribute outDegree { data.count }?,
  empty

tree =
  ## encodes a tree, which is made up of a root, internal nodes,
  ## leaves, and arcs from root to leaves.
  element tree { tree.content, tree.attributes }
tree.content =
  label?,
  ((leaf | iNode)*, root, (leaf | iNode)*)
tree.attributes =
  att.global.attributes,
  ## gives the maximum number of children of the root and internal
  ## nodes of the tree.
  attribute arity { data.count }?,
  ## indicates whether or not the tree is ordered, or if it is
  ## partially ordered.
  [ a1:defaultValue = "true" ]
  attribute ord {
    ## (indicates that all of the branching nodes of the tree are ordered.) 
    "true" | ## (indicates that some of the branching nodes of the tree are ordered
      ## and some are unordered.) 
      "partial" | ## (indicates that all of the branching nodes of the tree are
      ## unordered.) 
      "false"
  },
  ## gives the order of the tree, i.e., the number of its nodes.
  attribute order { data.count }?,
  empty

triangle =
  ## (Underspecified embedding tree, so called because of its
  ##   characteristic shape when drawn.) provides for an underspecified eTree, that is, an eTree with
  ##   information left out.
  element triangle { triangle.content, triangle.attributes }
triangle.content = label?, (eTree | triangle | eLeaf)*
triangle.attributes =
  att.global.attributes,
  ## provides the value of a triangle, which is the identifier of a feature
  ## structure or other analytic element.
  attribute value { data.pointer }?,
  empty
# 3. macros
